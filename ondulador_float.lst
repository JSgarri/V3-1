CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 1

ADDR   CODE       LINE  SOURCE

                  00001 
                  00002 ; CC8E Version 1.4, Copyright (c) B Knudsen Data
                  00003 ; C compiler for the PIC18 microcontrollers
                  00004 ; ************  19. May 2015  15:23  *************
                  00005 
                  00006 	processor  PIC18F44K20
                  00007 	radix  DEC
                  00008 
300000 08FF       00009 	__config 0x300001, 0x8
                  00010 	__config 0x300002, 0x1
300002 1601       00011 	__config 0x300003, 0x16
300004 88FF       00012 	__config 0x300005, 0x88
300006 FF81       00013 	__config 0x300006, 0x81
                  00014 
       0FF6       00015 TBLPTR      EQU   0xFF6
       0FF5       00016 TABLAT      EQU   0xFF5
       0FF4       00017 PRODH       EQU   0xFF4
       0FF3       00018 PRODL       EQU   0xFF3
       0FF2       00019 INTCON      EQU   0xFF2
       0FF1       00020 INTCON2     EQU   0xFF1
       0FEF       00021 INDF0       EQU   0xFEF
       0FE9       00022 FSR0        EQU   0xFE9
       0FE0       00023 BSR         EQU   0xFE0
       0FD8       00024 STATUS      EQU   0xFD8
       0000       00025 Carry       EQU   0
       0002       00026 Zero_       EQU   2
       0FD5       00027 T0CON       EQU   0xFD5
       0FD3       00028 OSCCON      EQU   0xFD3
       0FD0       00029 RCON        EQU   0xFD0
       0FCB       00030 PR2         EQU   0xFCB
       0FCA       00031 T2CON       EQU   0xFCA
       0FC4       00032 ADRESH      EQU   0xFC4
       0FC3       00033 ADRESL      EQU   0xFC3
       0FC2       00034 ADCON0      EQU   0xFC2
       0FC1       00035 ADCON1      EQU   0xFC1
       0FC0       00036 ADCON2      EQU   0xFC0
       0FBE       00037 CCPR1L      EQU   0xFBE
       0FBD       00038 CCP1CON     EQU   0xFBD
       0FB7       00039 PWM1CON     EQU   0xFB7
       0F9B       00040 OSCTUNE     EQU   0xF9B
       0F95       00041 TRISD       EQU   0xF95
       0F94       00042 TRISC       EQU   0xF94
       0F93       00043 TRISB       EQU   0xF93
       0F92       00044 TRISA       EQU   0xF92
       0F8C       00045 LATD        EQU   0xF8C
       0F8A       00046 LATB        EQU   0xF8A
       0F83       00047 PORTD       EQU   0xF83
       0F82       00048 PORTC       EQU   0xF82
       0F81       00049 PORTB       EQU   0xF81
       0F7E       00050 ANSEL       EQU   0xF7E
       0002       00051 TMR0IF      EQU   2
       0007       00052 GIE         EQU   7
       0002       00053 TMR2ON      EQU   2
       0001       00054 GO          EQU   1
       0007       00055 ADFM        EQU   7
       0001       00056 TMR2IF      EQU   1
       0001       00057 TMR2IE      EQU   1
       0000       00058 bUdw        EQU   0
       00C0       00059 ancho_pwm   EQU   0xC0
       00C2       00060 r           EQU   0xC2
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 2

ADDR   CODE       LINE  SOURCE

       00C4       00061 Vmax        EQU   0xC4
       00C7       00062 SENO        EQU   0xC7
       00C9       00063 T           EQU   0xC9
       00CA       00064 i           EQU   0xCA
       00CB       00065 estado      EQU   0xCB
       0060       00066 svrSTATUS   EQU   0x60
       0061       00067 svrBSR      EQU   0x61
       0062       00068 svrWREG     EQU   0x62
       0063       00069 sv_PRODL    EQU   0x63
       0064       00070 sv_PRODH    EQU   0x64
       0065       00071 sv_TBLPTR   EQU   0x65
       0068       00072 sv_TABLAT   EQU   0x68
       0069       00073 C3cnt       EQU   0x69
       006A       00074 C4tmp       EQU   0x6A
       006C       00075 C5rem       EQU   0x6C
       00CC       00076 FpFlags     EQU   0xCC
       0001       00077 FpOverflow  EQU   1
       0002       00078 FpUnderFlow EQU   2
       0003       00079 FpDiv0      EQU   3
       0005       00080 FpDomainError EQU   5
       0006       00081 FpRounding  EQU   6
       00A4       00082 arg1f24     EQU   0xA4
       00A7       00083 arg2f24     EQU   0xA7
       00AF       00084 aarg        EQU   0xAF
       00B1       00085 sign        EQU   0xB1
       00B2       00086 tmpL        EQU   0xB2
       00AA       00087 aarg_2      EQU   0xAA
       00AC       00088 sign_2      EQU   0xAC
       00AD       00089 counter     EQU   0xAD
       00AF       00090 xtra        EQU   0xAF
       00B0       00091 temp        EQU   0xB0
       00B1       00092 expo        EQU   0xB1
       00B2       00093 sign_3      EQU   0xB2
       00AA       00094 expo_2      EQU   0xAA
       00AB       00095 xtra_2      EQU   0xAB
       00AC       00096 sign_4      EQU   0xAC
       00A4       00097 rval        EQU   0xA4
       00AA       00098 sign_6      EQU   0xAA
       00AB       00099 expo_4      EQU   0xAB
       00AC       00100 xtra_4      EQU   0xAC
       00A4       00101 rval_3      EQU   0xA4
       00B8       00102 arg1        EQU   0xB8
       00BA       00103 arg2        EQU   0xBA
       00BB       00104 rm          EQU   0xBB
       00BC       00105 counter_2   EQU   0xBC
       00BD       00106 tmp         EQU   0xBD
       00B8       00107 arg1_2      EQU   0xB8
       00BA       00108 arg2_2      EQU   0xBA
       00BC       00109 rm_2        EQU   0xBC
       00BE       00110 counter_3   EQU   0xBE
       00B8       00111 arg1_5      EQU   0xB8
       00BA       00112 arg2_5      EQU   0xBA
       00BB       00113 rm_5        EQU   0xBB
       00BC       00114 counter_6   EQU   0xBC
       00BD       00115 tmp_2       EQU   0xBD
       00B8       00116 arg1_6      EQU   0xB8
       00BA       00117 arg2_6      EQU   0xBA
       00BC       00118 rm_6        EQU   0xBC
       00BE       00119 counter_7   EQU   0xBE
       00AA       00120 cexp        EQU   0xAA
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 3

ADDR   CODE       LINE  SOURCE

       00AB       00121 savedFLAGS  EQU   0xAB
       00AC       00122 d_5         EQU   0xAC
       00B9       00123 PDel0       EQU   0xB9
       00B9       00124 PDel0_2     EQU   0xB9
       00BA       00125 PDel1       EQU   0xBA
       0F7F       00126 PDel0_3     EQU   0xF7F
       0F7F       00127 PDel1_2     EQU   0xF7F
       0F7F       00128 PDel2       EQU   0xF7F
       0F7F       00129 PDel0_4     EQU   0xF7F
       0F7F       00130 PDel1_3     EQU   0xF7F
       0F7F       00131 PDel2_2     EQU   0xF7F
       0F7F       00132 PDel0_5     EQU   0xF7F
       0F7F       00133 PDel1_4     EQU   0xF7F
       0F7F       00134 PDel2_3     EQU   0xF7F
       009E       00135 codigo      EQU   0x9E
       00B8       00136 comando     EQU   0xB8
       009E       00137 dato        EQU   0x9E
       009F       00138 i_3         EQU   0x9F
       0F7F       00139 dato_2      EQU   0xF7F
       0F7F       00140 i_4         EQU   0xF7F
       009D       00141 i_5         EQU   0x9D
       009D       00142 linea       EQU   0x9D
       009E       00143 columna     EQU   0x9E
       0F7F       00144 linea_2     EQU   0xF7F
       0F7F       00145 i_6         EQU   0xF7F
       0F7F       00146 linea_3     EQU   0xF7F
       0F7F       00147 columna_2   EQU   0xF7F
       0F7F       00148 dato_3      EQU   0xF7F
       0000       00149 bd          EQU   0
       0000       00150 dp          EQU   0
       0000       00151 xi          EQU   0
       0000       00152 ndp         EQU   0
       0F7F       00153 num         EQU   0xF7F
       0F7F       00154 u_milers    EQU   0xF7F
       0F7F       00155 cent        EQU   0xF7F
       0F7F       00156 dec         EQU   0xF7F
       0F7F       00157 unid        EQU   0xF7F
       0F7F       00158 resto1      EQU   0xF7F
       0F7F       00159 i_7         EQU   0xF7F
       0F7F       00160 xx          EQU   0xF7F
       0F7F       00161 dat         EQU   0xF7F
       0F7F       00162 xy          EQU   0xF7F
       00A4       00163 linea_4     EQU   0xA4
       00A5       00164 columna_3   EQU   0xA5
       00A6       00165 dato_4      EQU   0xA6
       00A8       00166 num_2       EQU   0xA8
       00AA       00167 u_milers_2  EQU   0xAA
       00AC       00168 cent_2      EQU   0xAC
       00AE       00169 d_milers    EQU   0xAE
       00B0       00170 dec_2       EQU   0xB0
       00B1       00171 unid_2      EQU   0xB1
       00B2       00172 resto1_2    EQU   0xB2
       00B3       00173 i_8         EQU   0xB3
       00B4       00174 xx_2        EQU   0xB4
       00B6       00175 dat_2       EQU   0xB6
       00A4       00176 linea_5     EQU   0xA4
       00A5       00177 columna_4   EQU   0xA5
       00A6       00178 dato_5      EQU   0xA6
       00A8       00179 cent_3      EQU   0xA8
       00A9       00180 dec_3       EQU   0xA9
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 4

ADDR   CODE       LINE  SOURCE

       00AA       00181 unid_3      EQU   0xAA
       00AB       00182 resto1_3    EQU   0xAB
       00AC       00183 i_9         EQU   0xAC
       00AD       00184 xx_3        EQU   0xAD
       00AF       00185 dat_3       EQU   0xAF
       009D       00186 i_10        EQU   0x9D
       00A2       00187 canal       EQU   0xA2
       00A3       00188 bits        EQU   0xA3
       00A4       00189 resultado   EQU   0xA4
       006D       00190 p           EQU   0x6D
       006E       00191 h           EQU   0x6E
       006F       00192 x           EQU   0x6F
       0070       00193 vac         EQU   0x70
       0080       00194 ac          EQU   0x80
       0091       00195 ic          EQU   0x91
       0092       00196 vbat        EQU   0x92
       0093       00197 o           EQU   0x93
       0094       00198 vuelta      EQU   0x94
       0000       00199 lectura     EQU   0
       0095       00200 raiz        EQU   0x95
       0098       00201 Mac0        EQU   0x98
       009A       00202 Mac1        EQU   0x9A
       00A2       00203 d_6         EQU   0xA2
       009D       00204 banda       EQU   0x9D
       00A0       00205 bat         EQU   0xA0
       00A2       00206 q           EQU   0xA2
       0069       00207 ci          EQU   0x69
                  00208 
000000 EFEA F009  00209 	GOTO main
                  00210 
                  00211   ; FILE ondulador_float.c
                  00212 			;/*
                  00213 			; * Autor: J_Sanchez
                  00214 			; * 
                  00215 			; * Fecha: 31-03-2015
                  00216 			; * Descripcion:Primera prueba con el 18F44K20 para el proyecto del ondulador v2.0
                  00217 			; *  Configuracion: 
                  00218 			; *		Modelo: 18F44K20
                  00219 			; *		Oscilador: Crystal 64Mhz
                  00220 			; *		Puente en H con PWM mejorado
                  00221 			; */
                  00222 			;
                  00223 			; //**************************************************************************************//
                  00224 			; //******************* C O N F I G  U R A C I O N    I N I C I A L  *********************//
                  00225 			; //**************************************************************************************//
                  00226 			; 
                  00227 			; #pragma chip PIC18F44K20
                  00228 			; #pragma config[1] = 0b.0000.1000//pagina 301 datasheet
                  00229 			; #pragma config[2] = 0b.0000.0001
                  00230 			; #pragma config[3] = 0b.0001.0110
                  00231 			; #pragma config[5] = 0b.1000.1000//Mirar CCP2 MUX bit 0 
                  00232 			; 				//-->1 = CCP2 input/output is multiplexed with RC1
                  00233 			;				//   -->0 = CCP2 input/output is multiplexed with RB3 
                  00234 			; #pragma config[6] = 0b.1000.0001
                  00235 			; // resto configs son para la proteccion del programa 
                  00236 			;
                  00237 			; #pragma sharedAllocation//evita error en las interrupciones
                  00238 			;
                  00239 			; //**************************************************************************************//
                  00240 			; //************************************  M A C R O S ************************************//
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 5

ADDR   CODE       LINE  SOURCE

                  00241 			; //**************************************************************************************//
                  00242 			;
                  00243 			;#define PORDEBAJO 0
                  00244 			;#define PORENCIMA 1
                  00245 			;//estados
                  00246 			;#define LECTURA_VAC  0
                  00247 			;#define CALCULOS_VAC 1
                  00248 			;#define CALCULOS_IAC 2
                  00249 			;#define LECTURAS_VARIAS 3
                  00250 			;#define ENVIO_LCD    4
                  00251 			;//lectura adc
                  00252 			;#define LEO_VAC		 0
                  00253 			;#define LEO_BAT		 1
                  00254 			;#define LEO_IAC		 2
                  00255 			;//envio caracter especial
                  00256 			;#define LOGO_SC		 0
                  00257 			;#define BATT_FULL	 1
                  00258 			;#define BATT_75		 2
                  00259 			;#define BATT_50		 3
                  00260 			;#define BATT_25		 4
                  00261 			;#define BATT_10		 5
                  00262 			;#define BATT_LW		 6 
                  00263 			;#define BATT_CLEAR	 7
                  00264 			;//valores PID
                  00265 			;#define REF_AC			  31
                  00266 			;#define BANDA_PROPORCINAL 10 //10%
                  00267 			;
                  00268 			; //**************************************************************************************//
                  00269 			; //********************************  V A R I A B L E S  *********************************//
                  00270 			; //**************************************************************************************//
                  00271 			;#pragma rambank 0
                  00272 			;bit bUdw; // a 1 puja en la taula (incrementa) , a 0 decrementa
                  00273 			;uns16 ancho_pwm,r;
                  00274 			;float Vmax;
                  00275 			;uns16 SENO;
                  00276 			;char T,i,estado; // Index de la taula
                  00277 			;
                  00278 			;
                  00279 			;static const char sen [26] = 			
                  00280 			;{0,8,16,23,31,39,47,54,61,68,75,81,87,93,98,103,108,112,115,119,121,123,125,126,127,128};
                  00281 			;
                  00282 			;// PWM maximo 799 para ser 100% 
                  00283 			;// equivale a 6.24 pero no llegaremos para no quemar los mosfets
                  00284 			;
                  00285 			; //**************************************************************************************//
                  00286 			; //************************** I N T E R R U P C I O N E S *******************************//
                  00287 			; //**************************************************************************************//
                  00288 			;
                  00289 			;#include "int18XXX.h"	 // Capçalera de interrupcions.
                  00290 			;
                  00291 			;
                  00292 			;#pragma origin 0x08	//#pragma origin 0x18	(PIC 16F88x)
       0000       00293 	ORG 0x0008
                  00294 			;
                  00295 			;interrupt highPriorityTimer_0 (void)		// Interrupción por desbordamiento de Timer 0.			
                  00296 			;{
                  00297 highPriorityTimer_0
                  00298 			;	int_save_registers 
000008 CFD8 F060  00299 	MOVFF STATUS,svrSTATUS
00000C CFE0 F061  00300 	MOVFF BSR,svrBSR
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 6

ADDR   CODE       LINE  SOURCE

000010 0100       00301 	MOVLB 0
000012 6F62       00302 	MOVWF svrWREG,1
                  00303 			;
                  00304 			;	// save remaining registers on demand (error/warning)
                  00305 			;	//uns16 sv_FSR0 = FSR0;
                  00306 			;	//uns16 sv_FSR1 = FSR1;
                  00307 			;	//uns16 sv_FSR2 = FSR2;
                  00308 			;	//uns8 sv_PCLATH = PCLATH;
                  00309 			;	//uns8 sv_PCLATU = PCLATU;
                  00310 			;	uns8 sv_PRODL = PRODL;
000014 CFF3 F063  00311 	MOVFF PRODL,sv_PRODL
                  00312 			;	uns8 sv_PRODH = PRODH;
000018 CFF4 F064  00313 	MOVFF PRODH,sv_PRODH
                  00314 			;	uns24 sv_TBLPTR = TBLPTR;
00001C CFF6 F065  00315 	MOVFF TBLPTR,sv_TBLPTR
000020 CFF7 F066  00316 	MOVFF TBLPTR+1,sv_TBLPTR+1
000024 CFF8 F067  00317 	MOVFF TBLPTR+2,sv_TBLPTR+2
                  00318 			;	uns8 sv_TABLAT = TABLAT;
000028 CFF5 F068  00319 	MOVFF TABLAT,sv_TABLAT
                  00320 			;
                  00321 			;	if(TMR2IF) 
00002C A29E       00322 	BTFSS 0xF9E,TMR2IF,0
00002E D070       00323 	BRA   m011
                  00324 			;	{ 
                  00325 			;		T2CON = 0b.0.0011.1.01; TMR2IF =0; //TMR2ON =1; // PostScaler per 4
000030 0E1D       00326 	MOVLW 29
000032 6ECA       00327 	MOVWF T2CON,0
000034 929E       00328 	BCF   0xF9E,TMR2IF,0
                  00329 			;		for (i = 1; i <= 6; i ++)  ancho_pwm = rl (ancho_pwm);
000036 0E01       00330 	MOVLW 1
000038 6FCA       00331 	MOVWF i,1
00003A 0E07       00332 m001	MOVLW 7
00003C 0100       00333 	MOVLB 0
00003E 61CA       00334 	CPFSLT i,1
000040 D004       00335 	BRA   m002
000042 37C0       00336 	RLCF  ancho_pwm,1,1
000044 37C1       00337 	RLCF  ancho_pwm+1,1,1
000046 2BCA       00338 	INCF  i,1,1
000048 D7F8       00339 	BRA   m001
                  00340 			;		CCPR1L = ancho_pwm.high8;
00004A C0C1 FFBE  00341 m002	MOVFF ancho_pwm+1,CCPR1L
                  00342 			;		CCP1CON.5 = ancho_pwm.7;
00004E 0100       00343 	MOVLB 0
000050 AFC0       00344 	BTFSS ancho_pwm,7,1
000052 9ABD       00345 	BCF   CCP1CON,5,0
000054 BFC0       00346 	BTFSC ancho_pwm,7,1
000056 8ABD       00347 	BSF   CCP1CON,5,0
                  00348 			;		CCP1CON.4 = ancho_pwm.6;
000058 ADC0       00349 	BTFSS ancho_pwm,6,1
00005A 98BD       00350 	BCF   CCP1CON,4,0
00005C BDC0       00351 	BTFSC ancho_pwm,6,1
00005E 88BD       00352 	BSF   CCP1CON,4,0
                  00353 			;				  
                  00354 			;		if(bUdw){ 
000060 A1BF       00355 	BTFSS 0xBF,bUdw,1
000062 D007       00356 	BRA   m004
                  00357 			;			if(T>=25)  bUdw=0;      
000064 0E18       00358 	MOVLW 24
000066 65C9       00359 	CPFSGT T,1
000068 D002       00360 	BRA   m003
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 7

ADDR   CODE       LINE  SOURCE

00006A 91BF       00361 	BCF   0xBF,bUdw,1
                  00362 			;			else T++;
00006C D002       00363 	BRA   m004
00006E 0100       00364 m003	MOVLB 0
000070 2BC9       00365 	INCF  T,1,1
                  00366 			;		} 
                  00367 			;		if(!bUdw) T--;                       
000072 0100       00368 m004	MOVLB 0
000074 A1BF       00369 	BTFSS 0xBF,bUdw,1
000076 07C9       00370 	DECF  T,1,1
                  00371 			;		if(T==0) {
000078 0100       00372 	MOVLB 0
00007A 53C9       00373 	MOVF  T,1,1
00007C A4D8       00374 	BTFSS 0xFD8,Zero_,0
00007E D019       00375 	BRA   m007
                  00376 			;		  	while(!TMR2IF);TMR2IF =0; // ESPERO QUE ACABI  T=1
000080 A29E       00377 m005	BTFSS 0xF9E,TMR2IF,0
000082 D7FE       00378 	BRA   m005
000084 929E       00379 	BCF   0xF9E,TMR2IF,0
                  00380 			;			T2CON = 0b.0.0001.1.01;
000086 0E0D       00381 	MOVLW 13
000088 6ECA       00382 	MOVWF T2CON,0
                  00383 			;			CCPR1L = 0;
00008A 6ABE       00384 	CLRF  CCPR1L,0
                  00385 			;			CCP1CON.5 = 0;
00008C 9ABD       00386 	BCF   CCP1CON,5,0
                  00387 			;			CCP1CON.4 = 0;	 
00008E 98BD       00388 	BCF   CCP1CON,4,0
                  00389 			;			while(!TMR2IF); // espeor que acabi la 1era meitat del T=0, postsclaer =2
000090 A29E       00390 m006	BTFSS 0xF9E,TMR2IF,0
000092 D7FE       00391 	BRA   m006
                  00392 			;			TMR2IF =0;
000094 929E       00393 	BCF   0xF9E,TMR2IF,0
                  00394 			;			T2CON = 0b.0.0000.1.01;
000096 0E05       00395 	MOVLW 5
000098 6ECA       00396 	MOVWF T2CON,0
                  00397 			;			CCPR1L = 0;
00009A 6ABE       00398 	CLRF  CCPR1L,0
                  00399 			;			CCP1CON.5 = 0;
00009C 9ABD       00400 	BCF   CCP1CON,5,0
                  00401 			;			CCP1CON.4 = 0;
00009E 98BD       00402 	BCF   CCP1CON,4,0
                  00403 			;			LATD.0= !LATD.0;
0000A0 708C       00404 	BTG   LATD,0,0
                  00405 			;			bUdw=1;  
0000A2 0100       00406 	MOVLB 0
0000A4 81BF       00407 	BSF   0xBF,bUdw,1
                  00408 			;			T=1;
0000A6 0E01       00409 	MOVLW 1
0000A8 6FC9       00410 	MOVWF T,1
                  00411 			;			if(estado==ENVIO_LCD) estado = LECTURA_VAC;  // el deixo sortir
0000AA 0E04       00412 	MOVLW 4
0000AC 63CB       00413 	CPFSEQ estado,1
0000AE D001       00414 	BRA   m007
0000B0 6BCB       00415 	CLRF  estado,1
                  00416 			;		}			  
                  00417 			;							
                  00418 			;		SENO = sen[T];
0000B2 0100       00419 m007	MOVLB 0
0000B4 51C9       00420 	MOVF  T,W,1
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 8

ADDR   CODE       LINE  SOURCE

0000B6 EC70 F00D  00421 	CALL  _const1
0000BA 0100       00422 	MOVLB 0
0000BC 6FC7       00423 	MOVWF SENO,1
0000BE 6BC8       00424 	CLRF  SENO+1,1
                  00425 			;		ancho_pwm = (uns16)SENO*r;
0000C0 51C7       00426 	MOVF  SENO,W,1
0000C2 03C2       00427 	MULWF r,1
0000C4 CFF3 F0C0  00428 	MOVFF PRODL,ancho_pwm
0000C8 CFF4 F0C1  00429 	MOVFF PRODH,ancho_pwm+1
0000CC 51C8       00430 	MOVF  SENO+1,W,1
0000CE 03C2       00431 	MULWF r,1
0000D0 50F3       00432 	MOVF  PRODL,W,0
0000D2 27C1       00433 	ADDWF ancho_pwm+1,1,1
0000D4 51C7       00434 	MOVF  SENO,W,1
0000D6 03C3       00435 	MULWF r+1,1
0000D8 50F3       00436 	MOVF  PRODL,W,0
0000DA 27C1       00437 	ADDWF ancho_pwm+1,1,1
                  00438 			;		ancho_pwm=ancho_pwm/10;
0000DC 51C0       00439 	MOVF  ancho_pwm,W,1
0000DE 6F6A       00440 	MOVWF C4tmp,1
0000E0 51C1       00441 	MOVF  ancho_pwm+1,W,1
0000E2 6F6B       00442 	MOVWF C4tmp+1,1
0000E4 6B6C       00443 	CLRF  C5rem,1
0000E6 0E10       00444 	MOVLW 16
0000E8 6F69       00445 	MOVWF C3cnt,1
0000EA 0100       00446 m008	MOVLB 0
0000EC 376A       00447 	RLCF  C4tmp,1,1
0000EE 376B       00448 	RLCF  C4tmp+1,1,1
0000F0 376C       00449 	RLCF  C5rem,1,1
0000F2 B0D8       00450 	BTFSC 0xFD8,Carry,0
0000F4 D004       00451 	BRA   m009
0000F6 0E0A       00452 	MOVLW 10
0000F8 5D6C       00453 	SUBWF C5rem,W,1
0000FA A0D8       00454 	BTFSS 0xFD8,Carry,0
0000FC D004       00455 	BRA   m010
0000FE 0E0A       00456 m009	MOVLW 10
000100 0100       00457 	MOVLB 0
000102 5F6C       00458 	SUBWF C5rem,1,1
000104 80D8       00459 	BSF   0xFD8,Carry,0
000106 0100       00460 m010	MOVLB 0
000108 37C0       00461 	RLCF  ancho_pwm,1,1
00010A 37C1       00462 	RLCF  ancho_pwm+1,1,1
00010C 2F69       00463 	DECFSZ C3cnt,1,1
00010E D7ED       00464 	BRA   m008
                  00465 			;		//Vmax=3.0;
                  00466 			;				  			  
                  00467 			;	} 
                  00468 			;			
                  00469 			;	// restore registers that are saved
                  00470 			;	//FSR0 = sv_FSR0;
                  00471 			;	//FSR1 = sv_FSR1;
                  00472 			;	//FSR2 = sv_FSR2;
                  00473 			;	//PCLATH = sv_PCLATH;
                  00474 			;	//PCLATU = sv_PCLATU;
                  00475 			;	PRODL = sv_PRODL;
000110 C063 FFF3  00476 m011	MOVFF sv_PRODL,PRODL
                  00477 			;	PRODH = sv_PRODH;
000114 C064 FFF4  00478 	MOVFF sv_PRODH,PRODH
                  00479 			;	TBLPTR = sv_TBLPTR;
000118 C065 FFF6  00480 	MOVFF sv_TBLPTR,TBLPTR
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 9

ADDR   CODE       LINE  SOURCE

00011C C066 FFF7  00481 	MOVFF sv_TBLPTR+1,TBLPTR+1
000120 C067 FFF8  00482 	MOVFF sv_TBLPTR+2,TBLPTR+2
                  00483 			;	TABLAT = sv_TABLAT;
000124 C068 FFF5  00484 	MOVFF sv_TABLAT,TABLAT
                  00485 			;
                  00486 			;    int_restore_registers 					// Devuelve W, STATUS y PCLATH.
000128 0100       00487 	MOVLB 0
00012A 5162       00488 	MOVF  svrWREG,W,1
00012C C061 FFE0  00489 	MOVFF svrBSR,BSR
000130 C060 FFD8  00490 	MOVFF svrSTATUS,STATUS
                  00491 			;}
000134 0010       00492 	RETFIE
                  00493 
                  00494   ; FILE MATH24F.H
                  00495 			;// *************************************************
                  00496 			;// 24 bit basic floating point math operations
                  00497 			;// Copyright (c) B Knudsen Data, Norway, 2000 - 2005
                  00498 			;// *************************************************
                  00499 			;
                  00500 			;#pragma library 1
                  00501 			;/* PROTOTYPES for page definition in application header file:
                  00502 			;float24 operator* _fmul24( float24 arg1f24, float24 arg2f24);
                  00503 			;float24 operator/ _fdiv24( float24 arg1f24, float24 arg2f24);
                  00504 			;float24 operator+ _fadd24( float24 arg1f24, float24 arg2f24);
                  00505 			;float24 operator- _fsub24( float24 arg1f24, float24 arg2f24);
                  00506 			;float24 operator= _int24ToFloat24( int24 arg1f24);
                  00507 			;float24 operator= _int32ToFloat24( int32 arg32);
                  00508 			;int24 operator= _float24ToInt24( float24 arg1f24);
                  00509 			;bit operator< _f24_LT_f24( float24 arg1f24, float24 arg2f24);
                  00510 			;bit operator>= _f24_GE_f24( float24 arg1f24, float24 arg2f24);
                  00511 			;bit operator> _f24_GT_f24( float24 arg1f24, float24 arg2f24);
                  00512 			;bit operator<= _f24_LE_f24( float24 arg1f24, float24 arg2f24);
                  00513 			;*/
                  00514 			;
                  00515 			;// DEFINABLE SYMBOLS (in the application code):
                  00516 			;//#define FP_OPTIM_SPEED  // optimize for SPEED: default
                  00517 			;//#define FP_OPTIM_SIZE   // optimize for SIZE
                  00518 			;//#define DISABLE_ROUNDING   // disable rounding and save code space
                  00519 			;
                  00520 			;#define float24ToIEEE754(a) { a.mid8=rl(a.mid8); a.high8=rr(a.high8);\
                  00521 			;                              a.mid8=rr(a.mid8); }
                  00522 			;#define IEEE754ToFloat24(a) { a.mid8=rl(a.mid8); a.high8=rl(a.high8);\
                  00523 			;                              a.mid8=rr(a.mid8); }
                  00524 			;
                  00525 			;
                  00526 			;/*  24 bit floating point format:
                  00527 			;
                  00528 			;  address  ID
                  00529 			;    X      a.low8  : LSB, bit 0-7 of mantissa
                  00530 			;    X+1    a.mid8  : bit 8-14 of mantissa, bit 15 is the sign bit
                  00531 			;    X+2    a.high8 : MSB, bit 0-7 of exponent, with bias 0x7F
                  00532 			;
                  00533 			;    bit 15 of mantissa is a hidden bit, always equal to 1
                  00534 			;    zero (0.0) :  a.high8 = 0 (mantissa & sign ignored)
                  00535 			;
                  00536 			;   MSB    LSB
                  00537 			;    7F 00 00  : 1.0   =  1.0  * 2**(0x7F-0x7F) = 1.0 * 1
                  00538 			;    7F 80 00  : -1.0  = -1.0  * 2**(0x7F-0x7F) = -1.0 * 1
                  00539 			;    80 00 00  : 2.0   =  1.0  * 2**(0x80-0x7F) = 1.0 * 2
                  00540 			;    80 40 00  : 3.0   =  1.5  * 2**(0x80-0x7F) = 1.5 * 2
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 10

ADDR   CODE       LINE  SOURCE

                  00541 			;    7E 60 00  : 0.875 =  1.75 * 2**(0x7E-0x7F) = 1.75 * 0.5
                  00542 			;    7F 60 00  : 1.75  =  1.75 * 2**(0x7E-0x7F) = 1.75 * 1
                  00543 			;    7F 7F FF  : 1.999969482
                  00544 			;    00 7C 5A  : 0.0 (mantissa & sign ignored)
                  00545 			;    01 00 00  : 1.17549435e-38 =  1.0 * 2**(0x01-0x7F)
                  00546 			;    FE 7F FF  : 3.40277175e+38 =  1.999969482 * 2**(0xFE-0x7F)
                  00547 			;    FF 00 00  : +INF : positive infinity
                  00548 			;    FF 80 00  : -INF : negative infinity
                  00549 			;*/                 
                  00550 			;
                  00551 			;#define  FpBIAS  0x7F
                  00552 			;
                  00553 			;#ifndef FpFlags_defined
                  00554 			; #define FpFlags_defined
                  00555 			;
                  00556 			; char FpFlags;
                  00557 			; //bit IOV         @ FpFlags.0; // integer overflow flag: NOT USED
                  00558 			; bit FpOverflow    @ FpFlags.1; // floating point overflow flag
                  00559 			; bit FpUnderFlow   @ FpFlags.2; // floating point underflow flag
                  00560 			; bit FpDiv0        @ FpFlags.3; // floating point divide by zero flag
                  00561 			; //bit FpNAN       @ FpFlags.4; // not-a-number exception flag: NOT USED
                  00562 			; bit FpDomainError @ FpFlags.5; // domain error exception flag
                  00563 			; bit FpRounding    @ FpFlags.6; // floating point rounding flag, 0=truncation
                  00564 			;                                // 1 = unbiased rounding to nearest LSB
                  00565 			; //bit FpSaturate  @ FpFlags.7; // floating point saturate flag: NOT USED
                  00566 			;
                  00567 			; #pragma floatOverflow FpOverflow
                  00568 			; #pragma floatUnderflow FpUnderFlow
                  00569 			;
                  00570 			; #define InitFpFlags()  FpFlags = 0x40 /* enable rounding as default */
                  00571 			;#endif
                  00572 			;
                  00573 			;#ifdef DISABLE_ROUNDING
                  00574 			; #pragma floatRounding 0
                  00575 			;#endif
                  00576 			;
                  00577 			;
                  00578 			;#if __CoreSet__ < 1600
                  00579 			; #define genAdd(r,a) W=a; btsc(Carry); W=incsz(a); r+=W
                  00580 			; #define genSub(r,a) W=a; btss(Carry); W=incsz(a); r-=W
                  00581 			; #define genAddW(r,a) W=a; btsc(Carry); W=incsz(a); W=r+W
                  00582 			; #define genSubW(r,a) W=a; btss(Carry); W=incsz(a); W=r-W
                  00583 			;#else
                  00584 			; #define genAdd(r,a) W=a; r=addWFC(r)
                  00585 			; #define genSub(r,a) W=a; r=subWFB(r)
                  00586 			; #define genAddW(r,a) W=a; W=addWFC(r)
                  00587 			; #define genSubW(r,a) W=a; W=subWFB(r)
                  00588 			;#endif
                  00589 			;
                  00590 			;#if __CoreSet__ == 1700 || __CoreSet__ == 1800
                  00591 			; #define hw_mult8x8(a,b)  W = a; multiply(b)
                  00592 			; #define loRES PRODL
                  00593 			; #define hiRES PRODH
                  00594 			;#endif
                  00595 			;
                  00596 			;#if __CoreSet__ == 2000
                  00597 			; #define hw_mult8x8(a,b)  W = a; multiply(b)
                  00598 			; #define loRES W
                  00599 			; #define hiRES MULH
                  00600 			;#endif
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 11

ADDR   CODE       LINE  SOURCE

                  00601 			;
                  00602 			;
                  00603 			;float24 operator* _fmul24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  00604 			;{
                  00605 _fmul24
                  00606 			;    uns16 aarg;
                  00607 			;    W = arg1f24.mid8;
000136 0100       00608 	MOVLB 0
000138 51A5       00609 	MOVF  arg1f24+1,W,1
                  00610 			;    aarg.high8 = W;
00013A 6FB0       00611 	MOVWF aarg+1,1
                  00612 			;
                  00613 			;    // save sign
                  00614 			;    char sign = arg2f24.mid8 ^ W;  // before first overflow test
00013C 19A8       00615 	XORWF arg2f24+1,W,1
00013E 6FB1       00616 	MOVWF sign,1
                  00617 			;
                  00618 			;    W = arg1f24.high8;
000140 51A6       00619 	MOVF  arg1f24+2,W,1
                  00620 			;   #if __CoreSet__ / 100 == 17
                  00621 			;    if (W != 0)
                  00622 			;        W = arg2f24.high8;
                  00623 			;    if (W == 0)
                  00624 			;        goto RES0;
                  00625 			;   #else
                  00626 			;    if (!Zero_)
000142 A4D8       00627 	BTFSS 0xFD8,Zero_,0
                  00628 			;        W = arg2f24.high8;
000144 51A9       00629 	MOVF  arg2f24+2,W,1
                  00630 			;    if (Zero_)
000146 B4D8       00631 	BTFSC 0xFD8,Zero_,0
                  00632 			;        goto RES0;
000148 D04A       00633 	BRA   m016
                  00634 			;   #endif
                  00635 			;
                  00636 			;    arg1f24.high8 += W /* arg2f24.high8 */;
00014A 0100       00637 	MOVLB 0
00014C 27A6       00638 	ADDWF arg1f24+2,1,1
                  00639 			;    W = FpBIAS-1;
00014E 0E7E       00640 	MOVLW 126
                  00641 			;    if (Carry)  {
000150 A0D8       00642 	BTFSS 0xFD8,Carry,0
000152 D004       00643 	BRA   m012
                  00644 			;        arg1f24.high8 -= W;
000154 5FA6       00645 	SUBWF arg1f24+2,1,1
                  00646 			;        if (Carry)
000156 A0D8       00647 	BTFSS 0xFD8,Carry,0
000158 D005       00648 	BRA   m013
                  00649 			;            goto OVERFLOW;
00015A D044       00650 	BRA   m017
                  00651 			;    }
                  00652 			;    else  {
                  00653 			;        arg1f24.high8 -= W;
00015C 0100       00654 m012	MOVLB 0
00015E 5FA6       00655 	SUBWF arg1f24+2,1,1
                  00656 			;        if (!Carry)
000160 A0D8       00657 	BTFSS 0xFD8,Carry,0
                  00658 			;            goto UNDERFLOW;
000162 D03B       00659 	BRA   m015
                  00660 			;    }
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 12

ADDR   CODE       LINE  SOURCE

                  00661 			;    aarg.low8 = arg1f24.low8;
000164 C0A4 F0AF  00662 m013	MOVFF arg1f24,aarg
                  00663 			;
                  00664 			;    aarg.15 = 1;
000168 0100       00665 	MOVLB 0
00016A 8FB0       00666 	BSF   aarg+1,7,1
                  00667 			;    arg2f24.15 = 1;
00016C 8FA8       00668 	BSF   arg2f24+1,7,1
                  00669 			;
                  00670 			;   #if defined hw_mult8x8  &&  !defined FP_OPTIM_SIZE
                  00671 			;
                  00672 			;    char tmpL;
                  00673 			;    arg1f24.low16 = 0;
00016E 6BA4       00674 	CLRF  arg1f24,1
000170 6BA5       00675 	CLRF  arg1f24+1,1
                  00676 			;
                  00677 			;    hw_mult8x8( arg2f24.low8, aarg.low8);   // p1
000172 51A7       00678 	MOVF  arg2f24,W,1
000174 03AF       00679 	MULWF aarg,1
                  00680 			;    tmpL = hiRES;
000176 CFF4 F0B2  00681 	MOVFF PRODH,tmpL
                  00682 			;
                  00683 			;    hw_mult8x8( arg2f24.mid8, aarg.low8);  // p2
00017A 51A8       00684 	MOVF  arg2f24+1,W,1
00017C 03AF       00685 	MULWF aarg,1
                  00686 			;    tmpL += loRES;
00017E 50F3       00687 	MOVF  PRODL,W,0
000180 27B2       00688 	ADDWF tmpL,1,1
                  00689 			;    genAdd( arg1f24.low8, hiRES);
000182 50F4       00690 	MOVF  PRODH,W,0
000184 23A4       00691 	ADDWFC arg1f24,1,1
                  00692 			;    genAdd( arg1f24.mid8, 0);
000186 0E00       00693 	MOVLW 0
000188 23A5       00694 	ADDWFC arg1f24+1,1,1
                  00695 			;
                  00696 			;    hw_mult8x8( arg2f24.low8, aarg.mid8);  // p2
00018A 51A7       00697 	MOVF  arg2f24,W,1
00018C 03B0       00698 	MULWF aarg+1,1
                  00699 			;    tmpL += loRES;
00018E 50F3       00700 	MOVF  PRODL,W,0
000190 27B2       00701 	ADDWF tmpL,1,1
                  00702 			;    genAdd( arg1f24.low8, hiRES);
000192 50F4       00703 	MOVF  PRODH,W,0
000194 23A4       00704 	ADDWFC arg1f24,1,1
                  00705 			;    genAdd( arg1f24.mid8, 0);
000196 0E00       00706 	MOVLW 0
000198 23A5       00707 	ADDWFC arg1f24+1,1,1
                  00708 			;
                  00709 			;    hw_mult8x8( arg2f24.mid8, aarg.mid8);  // p3
00019A 51A8       00710 	MOVF  arg2f24+1,W,1
00019C 03B0       00711 	MULWF aarg+1,1
                  00712 			;    arg1f24.low8 += loRES;
00019E 50F3       00713 	MOVF  PRODL,W,0
0001A0 27A4       00714 	ADDWF arg1f24,1,1
                  00715 			;    genAdd( arg1f24.mid8, hiRES);
0001A2 50F4       00716 	MOVF  PRODH,W,0
0001A4 23A5       00717 	ADDWFC arg1f24+1,1,1
                  00718 			;
                  00719 			;   #undef hw_mult8x8
                  00720 			;   #undef loRES
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 13

ADDR   CODE       LINE  SOURCE

                  00721 			;   #undef hiRES
                  00722 			;
                  00723 			;    if (!arg1f24.15)  {
0001A6 BFA5       00724 	BTFSC arg1f24+1,7,1
0001A8 D009       00725 	BRA   m014
                  00726 			;        tmpL = rl( tmpL);
0001AA 37B2       00727 	RLCF  tmpL,1,1
                  00728 			;        arg1f24.low16 = rl( arg1f24.low16);
0001AC 37A4       00729 	RLCF  arg1f24,1,1
0001AE 37A5       00730 	RLCF  arg1f24+1,1,1
                  00731 			;        if (arg1f24.high8 == 0)
0001B0 53A6       00732 	MOVF  arg1f24+2,1,1
0001B2 B4D8       00733 	BTFSC 0xFD8,Zero_,0
                  00734 			;            goto UNDERFLOW;
0001B4 D012       00735 	BRA   m015
                  00736 			;        arg1f24.high8 -= 1;
0001B6 0100       00737 	MOVLB 0
0001B8 07A6       00738 	DECF  arg1f24+2,1,1
                  00739 			;        W = rl( tmpL);  // restore bit behind LSB in Carry
0001BA 35B2       00740 	RLCF  tmpL,W,1
                  00741 			;    }
                  00742 			;
                  00743 			;   #else
                  00744 			;
                  00745 			;    arg1f24.low16 = 0;
                  00746 			;
                  00747 			;    char counter = sizeof(aarg)*8;
                  00748 			;
                  00749 			;    do  {
                  00750 			;        aarg = rr( aarg);
                  00751 			;        if (Carry)  {
                  00752 			;            arg1f24.low8 += arg2f24.low8;
                  00753 			;            genAdd( arg1f24.mid8, arg2f24.mid8);
                  00754 			;        }
                  00755 			;        arg1f24.low16 = rr( arg1f24.low16);
                  00756 			;        counter = decsz(counter);
                  00757 			;    } while (1);
                  00758 			;
                  00759 			;    if (!arg1f24.15)  {
                  00760 			;        // catch Carry bit that was shifted out previously
                  00761 			;        arg1f24.low16 = rl( arg1f24.low16);
                  00762 			;        if (arg1f24.high8 == 0)
                  00763 			;            goto UNDERFLOW;
                  00764 			;        arg1f24.high8 -= 1;
                  00765 			;        W = rl( aarg.high8);
                  00766 			;        // restore bit behind LSB in Carry
                  00767 			;    }
                  00768 			;
                  00769 			;   #endif
                  00770 			;
                  00771 			;   #ifndef DISABLE_ROUNDING
                  00772 			;    if (FpRounding  &&  Carry)  {
0001BC 0100       00773 m014	MOVLB 0
0001BE ADCC       00774 	BTFSS 0xCC,FpRounding,1
0001C0 D018       00775 	BRA   m019
0001C2 A0D8       00776 	BTFSS 0xFD8,Carry,0
0001C4 D016       00777 	BRA   m019
                  00778 			;        arg1f24.low8 += 1;
0001C6 3FA4       00779 	INCFSZ arg1f24,1,1
                  00780 			;        if (!arg1f24.low8)  {
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 14

ADDR   CODE       LINE  SOURCE

0001C8 D014       00781 	BRA   m019
                  00782 			;            arg1f24.mid8 += 1;
0001CA 3FA5       00783 	INCFSZ arg1f24+1,1,1
                  00784 			;            if (!arg1f24.mid8)  {
0001CC D012       00785 	BRA   m019
                  00786 			;               #if __CoreSet__ >= 1700 && __CoreSet__ <= 1800
                  00787 			;                Carry = 1; // previous INCF changes Carry
0001CE 80D8       00788 	BSF   0xFD8,Carry,0
                  00789 			;               #else
                  00790 			;                // Carry = 1; //OK
                  00791 			;               #endif
                  00792 			;                arg1f24.low16 = rr( arg1f24.low16);
0001D0 33A5       00793 	RRCF  arg1f24+1,1,1
0001D2 33A4       00794 	RRCF  arg1f24,1,1
                  00795 			;                arg1f24.high8 += 1;
0001D4 3FA6       00796 	INCFSZ arg1f24+2,1,1
                  00797 			;                if (Zero_)
0001D6 D00D       00798 	BRA   m019
                  00799 			;                    goto OVERFLOW;
0001D8 D005       00800 	BRA   m017
                  00801 			;            }
                  00802 			;        }
                  00803 			;    }
                  00804 			;   #endif
                  00805 			;    goto SET_SIGN;
                  00806 			;
                  00807 			;  UNDERFLOW:
                  00808 			;    FpUnderFlow = 1;
0001DA 0100       00809 m015	MOVLB 0
0001DC 85CC       00810 	BSF   0xCC,FpUnderFlow,1
                  00811 			;  RES0:
                  00812 			;    arg1f24.high8 = 0;
0001DE 0100       00813 m016	MOVLB 0
0001E0 6BA6       00814 	CLRF  arg1f24+2,1
                  00815 			;    goto MANTISSA;
0001E2 D003       00816 	BRA   m018
                  00817 			;
                  00818 			;  OVERFLOW:
                  00819 			;    FpOverflow = 1;
0001E4 0100       00820 m017	MOVLB 0
0001E6 83CC       00821 	BSF   0xCC,FpOverflow,1
                  00822 			;    arg1f24.high8 = 0xFF;
0001E8 69A6       00823 	SETF  arg1f24+2,1
                  00824 			;  MANTISSA:
                  00825 			;    arg1f24.low16 = 0x8000;
0001EA 0100       00826 m018	MOVLB 0
0001EC 6BA4       00827 	CLRF  arg1f24,1
0001EE 0E80       00828 	MOVLW 128
0001F0 6FA5       00829 	MOVWF arg1f24+1,1
                  00830 			;
                  00831 			;  SET_SIGN:
                  00832 			;    if (!(sign & 0x80))
0001F2 0100       00833 m019	MOVLB 0
0001F4 AFB1       00834 	BTFSS sign,7,1
                  00835 			;        arg1f24.15 = 0;
0001F6 9FA5       00836 	BCF   arg1f24+1,7,1
                  00837 			;    return arg1f24;
0001F8 0100       00838 	MOVLB 0
0001FA 51A4       00839 	MOVF  arg1f24,W,1
0001FC 0012       00840 	RETURN
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 15

ADDR   CODE       LINE  SOURCE

                  00841 			;}
                  00842 			;
                  00843 			;
                  00844 			;
                  00845 			;float24 operator/ _fdiv24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  00846 			;{
                  00847 _fdiv24
                  00848 			;    uns16 aarg;
                  00849 			;    W = arg1f24.mid8;
0001FE 0100       00850 	MOVLB 0
000200 51A5       00851 	MOVF  arg1f24+1,W,1
                  00852 			;    aarg.high8 = W;
000202 6FAB       00853 	MOVWF aarg_2+1,1
                  00854 			;
                  00855 			;    // save sign
                  00856 			;    char sign = arg2f24.mid8 ^ W;  // before first overflow test
000204 19A8       00857 	XORWF arg2f24+1,W,1
000206 6FAC       00858 	MOVWF sign_2,1
                  00859 			;
                  00860 			;   #if __CoreSet__ / 100 == 17
                  00861 			;    if (!arg2f24.high8)
                  00862 			;        goto Div0;
                  00863 			;   #else
                  00864 			;    W = arg2f24.high8;
000208 51A9       00865 	MOVF  arg2f24+2,W,1
                  00866 			;    if (Zero_)
00020A B4D8       00867 	BTFSC 0xFD8,Zero_,0
                  00868 			;        goto Div0;
00020C D05C       00869 	BRA   m030
                  00870 			;   #endif
                  00871 			;    if (!arg1f24.high8)
00020E 0100       00872 	MOVLB 0
000210 53A6       00873 	MOVF  arg1f24+2,1,1
000212 B4D8       00874 	BTFSC 0xFD8,Zero_,0
                  00875 			;        goto RES0;
000214 D05D       00876 	BRA   m032
                  00877 			;
                  00878 			;    arg1f24.high8 -= arg2f24.high8;
000216 0100       00879 	MOVLB 0
000218 51A9       00880 	MOVF  arg2f24+2,W,1
00021A 5FA6       00881 	SUBWF arg1f24+2,1,1
                  00882 			;    W = FpBIAS;
00021C 0E7F       00883 	MOVLW 127
                  00884 			;    if (!Carry)  {
00021E B0D8       00885 	BTFSC 0xFD8,Carry,0
000220 D004       00886 	BRA   m020
                  00887 			;        arg1f24.high8 += W;
000222 27A6       00888 	ADDWF arg1f24+2,1,1
                  00889 			;        if (!Carry)
000224 B0D8       00890 	BTFSC 0xFD8,Carry,0
000226 D005       00891 	BRA   m021
                  00892 			;            goto UNDERFLOW;
000228 D051       00893 	BRA   m031
                  00894 			;    }
                  00895 			;    else  {
                  00896 			;        arg1f24.high8 += W;
00022A 0100       00897 m020	MOVLB 0
00022C 27A6       00898 	ADDWF arg1f24+2,1,1
                  00899 			;        if (Carry)
00022E B0D8       00900 	BTFSC 0xFD8,Carry,0
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 16

ADDR   CODE       LINE  SOURCE

                  00901 			;            goto OVERFLOW;
000230 D052       00902 	BRA   m033
                  00903 			;    }
                  00904 			;
                  00905 			;    aarg.low8 = arg1f24.low8;
000232 C0A4 F0AA  00906 m021	MOVFF arg1f24,aarg_2
                  00907 			;    aarg.15 = 1;
000236 0100       00908 	MOVLB 0
000238 8FAB       00909 	BSF   aarg_2+1,7,1
                  00910 			;    arg2f24.15 = 1;
00023A 8FA8       00911 	BSF   arg2f24+1,7,1
                  00912 			;
                  00913 			;    // division: shift & add
                  00914 			;    char counter = 16;
00023C 0E10       00915 	MOVLW 16
00023E 6FAD       00916 	MOVWF counter,1
                  00917 			;    arg1f24.low16 = 0;  // speedup
000240 6BA4       00918 	CLRF  arg1f24,1
000242 6BA5       00919 	CLRF  arg1f24+1,1
                  00920 			;
                  00921 			;#if defined FP_OPTIM_SPEED || !defined FP_OPTIM_SIZE  // SPEED
                  00922 			;
                  00923 			;    goto START_ML;
000244 D00B       00924 	BRA   m024
                  00925 			;
                  00926 			;  TEST_ZERO_L:
                  00927 			;    W = aarg.low8 - arg2f24.low8;
000246 0100       00928 m022	MOVLB 0
000248 51A7       00929 	MOVF  arg2f24,W,1
00024A 5DAA       00930 	SUBWF aarg_2,W,1
                  00931 			;    if (!Carry)
00024C A0D8       00932 	BTFSS 0xFD8,Carry,0
                  00933 			;        goto SHIFT_IN_CARRY;
00024E D013       00934 	BRA   m027
                  00935 			;    aarg.low8 = W;
000250 0100       00936 	MOVLB 0
000252 6FAA       00937 	MOVWF aarg_2,1
                  00938 			;    aarg.high8 = 0;
000254 6BAB       00939 	CLRF  aarg_2+1,1
                  00940 			;    goto SET_AND_SHIFT_IN_CARRY;
000256 D00E       00941 	BRA   m026
                  00942 			;
                  00943 			;// MAIN LOOP
                  00944 			;    do  {
                  00945 			;      LOOP_ML:
                  00946 			;        if (!Carry)  {
000258 B0D8       00947 m023	BTFSC 0xFD8,Carry,0
00025A D007       00948 	BRA   m025
                  00949 			;           START_ML:
                  00950 			;            W = aarg.high8 - arg2f24.mid8;
00025C 0100       00951 m024	MOVLB 0
00025E 51A8       00952 	MOVF  arg2f24+1,W,1
000260 5DAB       00953 	SUBWF aarg_2+1,W,1
                  00954 			;            if (Zero_)
000262 B4D8       00955 	BTFSC 0xFD8,Zero_,0
                  00956 			;                goto TEST_ZERO_L;
000264 D7F0       00957 	BRA   m022
                  00958 			;            if (!Carry)
000266 A0D8       00959 	BTFSS 0xFD8,Carry,0
                  00960 			;                goto SHIFT_IN_CARRY;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 17

ADDR   CODE       LINE  SOURCE

000268 D006       00961 	BRA   m027
                  00962 			;        }
                  00963 			;        aarg.low8 -= arg2f24.low8;
00026A 0100       00964 m025	MOVLB 0
00026C 51A7       00965 	MOVF  arg2f24,W,1
00026E 5FAA       00966 	SUBWF aarg_2,1,1
                  00967 			;        genSub( aarg.high8, arg2f24.mid8);
000270 51A8       00968 	MOVF  arg2f24+1,W,1
000272 5BAB       00969 	SUBWFB aarg_2+1,1,1
                  00970 			;      SET_AND_SHIFT_IN_CARRY:
                  00971 			;        Carry = 1;
000274 80D8       00972 m026	BSF   0xFD8,Carry,0
                  00973 			;      SHIFT_IN_CARRY:
                  00974 			;        arg1f24.low16 = rl( arg1f24.low16);
000276 0100       00975 m027	MOVLB 0
000278 37A4       00976 	RLCF  arg1f24,1,1
00027A 37A5       00977 	RLCF  arg1f24+1,1,1
                  00978 			;        // Carry = 0;  // ok, speedup
                  00979 			;        aarg = rl( aarg);
00027C 37AA       00980 	RLCF  aarg_2,1,1
00027E 37AB       00981 	RLCF  aarg_2+1,1,1
                  00982 			;        counter = decsz(counter);
000280 2FAD       00983 	DECFSZ counter,1,1
                  00984 			;    } while (1);
000282 D7EA       00985 	BRA   m023
                  00986 			;
                  00987 			;
                  00988 			;
                  00989 			;#else  // SIZE
                  00990 			;
                  00991 			;    goto START_ML;
                  00992 			;
                  00993 			;// MAIN LOOP
                  00994 			;    do  {
                  00995 			;      LOOP_ML:
                  00996 			;        if (Carry)
                  00997 			;            goto SUBTRACT;
                  00998 			;      START_ML:
                  00999 			;        W = aarg.low8 - arg2f24.low8;
                  01000 			;        genSubW( aarg.high8, arg2f24.mid8);
                  01001 			;        if (!Carry)
                  01002 			;            goto SKIP_SUB;
                  01003 			;       SUBTRACT:
                  01004 			;        aarg.low8 -= arg2f24.low8;
                  01005 			;        genSub( aarg.high8, arg2f24.mid8);
                  01006 			;        Carry = 1;
                  01007 			;       SKIP_SUB:
                  01008 			;        arg1f24.low16 = rl( arg1f24.low16);
                  01009 			;        // Carry = 0;  // ok
                  01010 			;        aarg = rl( aarg);
                  01011 			;        counter = decsz(counter);
                  01012 			;    } while (1);
                  01013 			;
                  01014 			;#endif
                  01015 			;
                  01016 			;    if (!arg1f24.15)  {
000284 BFA5       01017 	BTFSC arg1f24+1,7,1
000286 D009       01018 	BRA   m028
                  01019 			;        if (!arg1f24.high8)
000288 53A6       01020 	MOVF  arg1f24+2,1,1
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 18

ADDR   CODE       LINE  SOURCE

00028A B4D8       01021 	BTFSC 0xFD8,Zero_,0
                  01022 			;            goto UNDERFLOW;
00028C D01F       01023 	BRA   m031
                  01024 			;       #if __CoreSet__ >= 1700 && __CoreSet__ <= 1800
                  01025 			;        sign = rr( sign);   // Save Carry
00028E 0100       01026 	MOVLB 0
000290 33AC       01027 	RRCF  sign_2,1,1
                  01028 			;       #endif
                  01029 			;        arg1f24.high8 --;
000292 07A6       01030 	DECF  arg1f24+2,1,1
                  01031 			;        counter ++;
000294 2BAD       01032 	INCF  counter,1,1
                  01033 			;       #if __CoreSet__ >= 1700 && __CoreSet__ <= 1800
                  01034 			;        sign = rl( sign);   // Restore Carry, changed by INCF/DECF
000296 37AC       01035 	RLCF  sign_2,1,1
                  01036 			;       #endif
                  01037 			;        goto LOOP_ML;
000298 D7DF       01038 	BRA   m023
                  01039 			;    }
                  01040 			;
                  01041 			;   #ifndef DISABLE_ROUNDING
                  01042 			;    if (FpRounding)  {
00029A 0100       01043 m028	MOVLB 0
00029C ADCC       01044 	BTFSS 0xCC,FpRounding,1
00029E D023       01045 	BRA   m036
                  01046 			;        if (Carry)
0002A0 B0D8       01047 	BTFSC 0xFD8,Carry,0
                  01048 			;            goto ADD_1;
0002A2 D007       01049 	BRA   m029
                  01050 			;        aarg.low8 -= arg2f24.low8;
0002A4 0100       01051 	MOVLB 0
0002A6 51A7       01052 	MOVF  arg2f24,W,1
0002A8 5FAA       01053 	SUBWF aarg_2,1,1
                  01054 			;        genSub( aarg.high8, arg2f24.mid8);
0002AA 51A8       01055 	MOVF  arg2f24+1,W,1
0002AC 5BAB       01056 	SUBWFB aarg_2+1,1,1
                  01057 			;        if (Carry)  {
0002AE A0D8       01058 	BTFSS 0xFD8,Carry,0
0002B0 D01A       01059 	BRA   m036
                  01060 			;          ADD_1:
                  01061 			;            arg1f24.low8 += 1;
0002B2 0100       01062 m029	MOVLB 0
0002B4 3FA4       01063 	INCFSZ arg1f24,1,1
                  01064 			;            if (!arg1f24.low8)  {
0002B6 D017       01065 	BRA   m036
                  01066 			;                arg1f24.mid8 ++;
0002B8 3FA5       01067 	INCFSZ arg1f24+1,1,1
                  01068 			;                if (!arg1f24.mid8)  {
0002BA D015       01069 	BRA   m036
                  01070 			;                    arg1f24.low16 = rr( arg1f24.low16);
0002BC 33A5       01071 	RRCF  arg1f24+1,1,1
0002BE 33A4       01072 	RRCF  arg1f24,1,1
                  01073 			;                    arg1f24.high8 ++;
0002C0 3FA6       01074 	INCFSZ arg1f24+2,1,1
                  01075 			;                    if (!arg1f24.high8)
0002C2 D011       01076 	BRA   m036
                  01077 			;                        goto OVERFLOW;
0002C4 D008       01078 	BRA   m033
                  01079 			;                }
                  01080 			;            }
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 19

ADDR   CODE       LINE  SOURCE

                  01081 			;        }
                  01082 			;    }
                  01083 			;   #endif
                  01084 			;    goto SET_SIGN;
                  01085 			;
                  01086 			;  Div0:
                  01087 			;    FpDiv0 = 1;
0002C6 0100       01088 m030	MOVLB 0
0002C8 87CC       01089 	BSF   0xCC,FpDiv0,1
                  01090 			;    goto SATURATE;
0002CA D007       01091 	BRA   m034
                  01092 			;
                  01093 			;  UNDERFLOW:
                  01094 			;    FpUnderFlow = 1;
0002CC 0100       01095 m031	MOVLB 0
0002CE 85CC       01096 	BSF   0xCC,FpUnderFlow,1
                  01097 			;  RES0:
                  01098 			;    arg1f24.high8 = 0;
0002D0 0100       01099 m032	MOVLB 0
0002D2 6BA6       01100 	CLRF  arg1f24+2,1
                  01101 			;    goto MANTISSA;
0002D4 D004       01102 	BRA   m035
                  01103 			;
                  01104 			;  OVERFLOW:
                  01105 			;    FpOverflow = 1;
0002D6 0100       01106 m033	MOVLB 0
0002D8 83CC       01107 	BSF   0xCC,FpOverflow,1
                  01108 			;  SATURATE:
                  01109 			;    arg1f24.high8 = 0xFF;
0002DA 0100       01110 m034	MOVLB 0
0002DC 69A6       01111 	SETF  arg1f24+2,1
                  01112 			;  MANTISSA:
                  01113 			;    arg1f24.low16 = 0x8000;
0002DE 0100       01114 m035	MOVLB 0
0002E0 6BA4       01115 	CLRF  arg1f24,1
0002E2 0E80       01116 	MOVLW 128
0002E4 6FA5       01117 	MOVWF arg1f24+1,1
                  01118 			;
                  01119 			;  SET_SIGN:
                  01120 			;    if (!(sign & 0x80))
0002E6 0100       01121 m036	MOVLB 0
0002E8 AFAC       01122 	BTFSS sign_2,7,1
                  01123 			;        arg1f24.15 = 0;
0002EA 9FA5       01124 	BCF   arg1f24+1,7,1
                  01125 			;    return arg1f24;
0002EC 0100       01126 	MOVLB 0
0002EE 51A4       01127 	MOVF  arg1f24,W,1
0002F0 0012       01128 	RETURN
                  01129 			;}
                  01130 			;
                  01131 			;
                  01132 			;float24 operator+ _fadd24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  01133 			;{
                  01134 _fadd24
                  01135 			;    char xtra, temp;
                  01136 			;    char expo = arg1f24.high8 - arg2f24.high8;
0002F2 0100       01137 	MOVLB 0
0002F4 51A9       01138 	MOVF  arg2f24+2,W,1
0002F6 5DA6       01139 	SUBWF arg1f24+2,W,1
0002F8 6FB1       01140 	MOVWF expo,1
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 20

ADDR   CODE       LINE  SOURCE

                  01141 			;    if (!Carry)  {
0002FA B0D8       01142 	BTFSC 0xFD8,Carry,0
0002FC D013       01143 	BRA   m037
                  01144 			;        expo = -expo;
0002FE 6DB1       01145 	NEGF  expo,1
                  01146 			;        temp = arg1f24.high8;
000300 C0A6 F0B0  01147 	MOVFF arg1f24+2,temp
                  01148 			;        arg1f24.high8 = arg2f24.high8;
000304 C0A9 F0A6  01149 	MOVFF arg2f24+2,arg1f24+2
                  01150 			;        arg2f24.high8 = temp;
000308 C0B0 F0A9  01151 	MOVFF temp,arg2f24+2
                  01152 			;        temp = arg1f24.mid8;
00030C C0A5 F0B0  01153 	MOVFF arg1f24+1,temp
                  01154 			;        arg1f24.mid8 = arg2f24.mid8;
000310 C0A8 F0A5  01155 	MOVFF arg2f24+1,arg1f24+1
                  01156 			;        arg2f24.mid8 = temp;
000314 C0B0 F0A8  01157 	MOVFF temp,arg2f24+1
                  01158 			;        temp = arg1f24.low8;
000318 C0A4 F0B0  01159 	MOVFF arg1f24,temp
                  01160 			;        arg1f24.low8 = arg2f24.low8;
00031C C0A7 F0A4  01161 	MOVFF arg2f24,arg1f24
                  01162 			;        arg2f24.low8 = temp;
000320 C0B0 F0A7  01163 	MOVFF temp,arg2f24
                  01164 			;    }
                  01165 			;    if (expo > sizeof(arg1f24)*8-7)
000324 0E11       01166 m037	MOVLW 17
000326 0100       01167 	MOVLB 0
000328 65B1       01168 	CPFSGT expo,1
00032A D001       01169 	BRA   m038
                  01170 			;        goto _RETURN_MF;
00032C D086       01171 	BRA   m056
                  01172 			;    if (!arg2f24.high8)
00032E 0100       01173 m038	MOVLB 0
000330 53A9       01174 	MOVF  arg2f24+2,1,1
000332 B4D8       01175 	BTFSC 0xFD8,Zero_,0
                  01176 			;        goto _RETURN_MF;   // result is arg1f24
000334 D082       01177 	BRA   m056
                  01178 			;
                  01179 			;    xtra = 0;
000336 0100       01180 	MOVLB 0
000338 6BAF       01181 	CLRF  xtra,1
                  01182 			;
                  01183 			;    W = arg1f24.mid8;
00033A 51A5       01184 	MOVF  arg1f24+1,W,1
                  01185 			;    temp = W;
00033C 6FB0       01186 	MOVWF temp,1
                  01187 			;    char sign = arg2f24.mid8 ^ W;
00033E 19A8       01188 	XORWF arg2f24+1,W,1
000340 6FB2       01189 	MOVWF sign_3,1
                  01190 			;    arg1f24.15 = 1;
000342 8FA5       01191 	BSF   arg1f24+1,7,1
                  01192 			;    arg2f24.15 = 1;
000344 8FA8       01193 	BSF   arg2f24+1,7,1
                  01194 			;
                  01195 			;    while (1)  {
                  01196 			;        W = 8;
000346 0E08       01197 m039	MOVLW 8
                  01198 			;        expo -= W;
000348 0100       01199 	MOVLB 0
00034A 5FB1       01200 	SUBWF expo,1,1
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 21

ADDR   CODE       LINE  SOURCE

                  01201 			;        if (!Carry)
00034C A0D8       01202 	BTFSS 0xFD8,Carry,0
                  01203 			;            break;
00034E D007       01204 	BRA   m040
                  01205 			;        xtra = arg2f24.low8;
000350 C0A7 F0AF  01206 	MOVFF arg2f24,xtra
                  01207 			;        arg2f24.low8 = arg2f24.mid8;
000354 C0A8 F0A7  01208 	MOVFF arg2f24+1,arg2f24
                  01209 			;        arg2f24.mid8 = 0;
000358 0100       01210 	MOVLB 0
00035A 6BA8       01211 	CLRF  arg2f24+1,1
                  01212 			;    }
00035C D7F4       01213 	BRA   m039
                  01214 			;    expo += W;
00035E 0100       01215 m040	MOVLB 0
000360 27B1       01216 	ADDWF expo,1,1
                  01217 			;    if (expo)  {
000362 B4D8       01218 	BTFSC 0xFD8,Zero_,0
000364 D007       01219 	BRA   m042
                  01220 			;        do  {
                  01221 			;            Carry = 0;
000366 90D8       01222 m041	BCF   0xFD8,Carry,0
                  01223 			;            arg2f24.low16 = rr( arg2f24.low16);
000368 0100       01224 	MOVLB 0
00036A 33A8       01225 	RRCF  arg2f24+1,1,1
00036C 33A7       01226 	RRCF  arg2f24,1,1
                  01227 			;            xtra = rr( xtra);
00036E 33AF       01228 	RRCF  xtra,1,1
                  01229 			;        } while (--expo > 0);
000370 2FB1       01230 	DECFSZ expo,1,1
000372 D7F9       01231 	BRA   m041
                  01232 			;    }
                  01233 			;
                  01234 			;
                  01235 			;    if (sign & 0x80)  {
000374 0100       01236 m042	MOVLB 0
000376 AFB2       01237 	BTFSS sign_3,7,1
000378 D039       01238 	BRA   m048
                  01239 			;        // SUBTRACT
                  01240 			;        arg1f24.low8 -= arg2f24.low8;
00037A 51A7       01241 	MOVF  arg2f24,W,1
00037C 5FA4       01242 	SUBWF arg1f24,1,1
                  01243 			;        genSub( arg1f24.mid8, arg2f24.mid8);
00037E 51A8       01244 	MOVF  arg2f24+1,W,1
000380 5BA5       01245 	SUBWFB arg1f24+1,1,1
                  01246 			;        if (!Carry)  {  // arg2f24 > arg1f24
000382 B0D8       01247 	BTFSC 0xFD8,Carry,0
000384 D007       01248 	BRA   m043
                  01249 			;            arg1f24.low16 = -arg1f24.low16;
000386 80D8       01250 	BSF   0xFD8,Carry,0
000388 0E00       01251 	MOVLW 0
00038A 57A4       01252 	SUBFWB arg1f24,1,1
00038C 0E00       01253 	MOVLW 0
00038E 57A5       01254 	SUBFWB arg1f24+1,1,1
                  01255 			;            // xtra == 0 because arg1f24.exp == arg2f24.exp
                  01256 			;            temp ^= 0x80;  // invert sign
000390 0E80       01257 	MOVLW 128
000392 1BB0       01258 	XORWF temp,1,1
                  01259 			;        }
                  01260 			;        xtra = -xtra;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 22

ADDR   CODE       LINE  SOURCE

000394 0100       01261 m043	MOVLB 0
000396 6DAF       01262 	NEGF  xtra,1
                  01263 			;        if (xtra)
000398 B4D8       01264 	BTFSC 0xFD8,Zero_,0
00039A D003       01265 	BRA   m044
                  01266 			;            arg1f24.low16 --;
00039C 07A4       01267 	DECF  arg1f24,1,1
00039E 0E00       01268 	MOVLW 0
0003A0 5BA5       01269 	SUBWFB arg1f24+1,1,1
                  01270 			;        // adjust result left
                  01271 			;       #define counter expo
                  01272 			;        counter = 3;
0003A2 0E03       01273 m044	MOVLW 3
0003A4 0100       01274 	MOVLB 0
0003A6 6FB1       01275 	MOVWF expo,1
                  01276 			;        while (!arg1f24.mid8)  {
0003A8 0100       01277 m045	MOVLB 0
0003AA 53A5       01278 	MOVF  arg1f24+1,1,1
0003AC A4D8       01279 	BTFSS 0xFD8,Zero_,0
0003AE D00D       01280 	BRA   m046
                  01281 			;            arg1f24.mid8 = arg1f24.low8;
0003B0 C0A4 F0A5  01282 	MOVFF arg1f24,arg1f24+1
                  01283 			;            arg1f24.low8 = xtra;
0003B4 C0AF F0A4  01284 	MOVFF xtra,arg1f24
                  01285 			;            xtra = 0;
0003B8 6BAF       01286 	CLRF  xtra,1
                  01287 			;            arg1f24.high8 -= 8;
0003BA 0E08       01288 	MOVLW 8
0003BC 5FA6       01289 	SUBWF arg1f24+2,1,1
                  01290 			;            if (!Carry)
0003BE A0D8       01291 	BTFSS 0xFD8,Carry,0
                  01292 			;                goto RES0;
0003C0 D02F       01293 	BRA   m052
                  01294 			;            if (--counter == 0)  // max 2 iterations
0003C2 0100       01295 	MOVLB 0
0003C4 2FB1       01296 	DECFSZ expo,1,1
0003C6 D7F0       01297 	BRA   m045
                  01298 			;                goto RES0;
0003C8 D02B       01299 	BRA   m052
                  01300 			;        }
                  01301 			;       #undef counter
                  01302 			;        while (!arg1f24.15)  {
0003CA 0100       01303 m046	MOVLB 0
0003CC BFA5       01304 	BTFSC arg1f24+1,7,1
0003CE D007       01305 	BRA   m047
                  01306 			;            Carry = 0;
0003D0 90D8       01307 	BCF   0xFD8,Carry,0
                  01308 			;            xtra = rl( xtra);
0003D2 37AF       01309 	RLCF  xtra,1,1
                  01310 			;            arg1f24.low16 = rl( arg1f24.low16);
0003D4 37A4       01311 	RLCF  arg1f24,1,1
0003D6 37A5       01312 	RLCF  arg1f24+1,1,1
                  01313 			;            arg1f24.high8 --;
0003D8 2FA6       01314 	DECFSZ arg1f24+2,1,1
                  01315 			;            if (!arg1f24.high8)
0003DA D7F7       01316 	BRA   m046
                  01317 			;                goto RES0;   // UNDERFLOW?
0003DC D021       01318 	BRA   m052
                  01319 			;        }
                  01320 			;       #ifndef DISABLE_ROUNDING
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 23

ADDR   CODE       LINE  SOURCE

                  01321 			;        if (FpRounding  &&  (xtra & 0x80))  {
0003DE 0100       01322 m047	MOVLB 0
0003E0 ADCC       01323 	BTFSS 0xCC,FpRounding,1
0003E2 D028       01324 	BRA   m055
0003E4 AFAF       01325 	BTFSS xtra,7,1
0003E6 D026       01326 	BRA   m055
                  01327 			;            xtra = 0; // disable recursion
0003E8 6BAF       01328 	CLRF  xtra,1
                  01329 			;            goto INCREMENT;
0003EA D012       01330 	BRA   m051
                  01331 			;        }
                  01332 			;       #endif
                  01333 			;    }
                  01334 			;    else  {
                  01335 			;        // ADD arg1f24 and arg2f24
                  01336 			;        arg1f24.low8 += arg2f24.low8;
0003EC 0100       01337 m048	MOVLB 0
0003EE 51A7       01338 	MOVF  arg2f24,W,1
0003F0 27A4       01339 	ADDWF arg1f24,1,1
                  01340 			;        genAdd( arg1f24.mid8, arg2f24.mid8);
0003F2 51A8       01341 	MOVF  arg2f24+1,W,1
0003F4 23A5       01342 	ADDWFC arg1f24+1,1,1
                  01343 			;        if (Carry)  {
0003F6 A0D8       01344 	BTFSS 0xFD8,Carry,0
0003F8 D006       01345 	BRA   m050
                  01346 			;          ADJUST_RIGHT:
                  01347 			;            arg1f24.low16 = rr( arg1f24.low16);
0003FA 0100       01348 m049	MOVLB 0
0003FC 33A5       01349 	RRCF  arg1f24+1,1,1
0003FE 33A4       01350 	RRCF  arg1f24,1,1
                  01351 			;            xtra = rr( xtra);
000400 33AF       01352 	RRCF  xtra,1,1
                  01353 			;            arg1f24.high8 += 1;  // exp
000402 4BA6       01354 	INFSNZ arg1f24+2,1,1
                  01355 			;            if (!arg1f24.high8)
                  01356 			;                goto OVERFLOW;
000404 D010       01357 	BRA   m053
                  01358 			;        }
                  01359 			;       #ifndef DISABLE_ROUNDING
                  01360 			;        if (FpRounding  &&  (xtra & 0x80))  {
000406 0100       01361 m050	MOVLB 0
000408 ADCC       01362 	BTFSS 0xCC,FpRounding,1
00040A D014       01363 	BRA   m055
00040C AFAF       01364 	BTFSS xtra,7,1
00040E D012       01365 	BRA   m055
                  01366 			;          INCREMENT:
                  01367 			;            arg1f24.low8 += 1;
000410 0100       01368 m051	MOVLB 0
000412 3FA4       01369 	INCFSZ arg1f24,1,1
                  01370 			;            if (!arg1f24.low8)  {
000414 D00F       01371 	BRA   m055
                  01372 			;                arg1f24.mid8 += 1;
000416 3FA5       01373 	INCFSZ arg1f24+1,1,1
                  01374 			;                if (!arg1f24.mid8)  {
000418 D00D       01375 	BRA   m055
                  01376 			;                    Carry = 1; // prepare for shift
00041A 80D8       01377 	BSF   0xFD8,Carry,0
                  01378 			;                    arg1f24.0 = 0;  // disable recursion
00041C 91A4       01379 	BCF   arg1f24,0,1
                  01380 			;                    goto ADJUST_RIGHT;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 24

ADDR   CODE       LINE  SOURCE

00041E D7ED       01381 	BRA   m049
                  01382 			;                }
                  01383 			;            }
                  01384 			;        }
                  01385 			;       #endif
                  01386 			;    }
                  01387 			;    goto SET_SIGN;
                  01388 			;
                  01389 			;//  UNDERFLOW:
                  01390 			;//    FpUnderFlow = 1;
                  01391 			;  RES0:
                  01392 			;    arg1f24.high8 = 0;
000420 0100       01393 m052	MOVLB 0
000422 6BA6       01394 	CLRF  arg1f24+2,1
                  01395 			;    goto MANTISSA;
000424 D003       01396 	BRA   m054
                  01397 			;
                  01398 			;  OVERFLOW:
                  01399 			;    FpOverflow = 1;
000426 0100       01400 m053	MOVLB 0
000428 83CC       01401 	BSF   0xCC,FpOverflow,1
                  01402 			;    arg1f24.high8 = 0xFF;
00042A 69A6       01403 	SETF  arg1f24+2,1
                  01404 			;  MANTISSA:
                  01405 			;    arg1f24.low16 = 0x8000;
00042C 0100       01406 m054	MOVLB 0
00042E 6BA4       01407 	CLRF  arg1f24,1
000430 0E80       01408 	MOVLW 128
000432 6FA5       01409 	MOVWF arg1f24+1,1
                  01410 			;
                  01411 			;  SET_SIGN:
                  01412 			;    if (!(temp & 0x80))
000434 0100       01413 m055	MOVLB 0
000436 AFB0       01414 	BTFSS temp,7,1
                  01415 			;        arg1f24.15 = 0;
000438 9FA5       01416 	BCF   arg1f24+1,7,1
                  01417 			;
                  01418 			;  _RETURN_MF:
                  01419 			;    return arg1f24;
00043A 0100       01420 m056	MOVLB 0
00043C 51A4       01421 	MOVF  arg1f24,W,1
00043E 0012       01422 	RETURN
                  01423 			;}
                  01424 			;
                  01425 			;
                  01426 			;// SUBTRACTION
                  01427 			;
                  01428 			;float24 operator- _fsub24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  01429 			;{
                  01430 _fsub24
                  01431 			;    arg2f24.mid8 ^= 0x80;
000440 0E80       01432 	MOVLW 128
000442 0100       01433 	MOVLB 0
000444 1BA8       01434 	XORWF arg2f24+1,1,1
                  01435 			;    arg1f24 += arg2f24;
000446 DF55       01436 	RCALL _fadd24
                  01437 			;    return arg1f24;
000448 0100       01438 	MOVLB 0
00044A 51A4       01439 	MOVF  arg1f24,W,1
00044C 0012       01440 	RETURN
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 25

ADDR   CODE       LINE  SOURCE

                  01441 			;}
                  01442 			;
                  01443 			;
                  01444 			;float24 operator=( int8 arg) @
                  01445 			;float24 operator=( uns8 arg) @
                  01446 			;float24 operator=( int16 arg) @
                  01447 			;float24 operator=( uns16 arg) @
                  01448 			;float24 operator= _int24ToFloat24( sharedM int24 arg1f24)
                  01449 			;{
                  01450 _int24ToFloat24
                  01451 			;    sharedM float24 arg2f24;   // unused, but required
                  01452 			;    char expo = FpBIAS + 16 - 1;
00044E 0E8E       01453 	MOVLW 142
000450 0100       01454 	MOVLB 0
000452 6FAA       01455 	MOVWF expo_2,1
                  01456 			;    char xtra = 0;
000454 6BAB       01457 	CLRF  xtra_2,1
                  01458 			;    char sign = 0;
000456 6BAC       01459 	CLRF  sign_4,1
                  01460 			;    if (arg1f24 < 0)  {
000458 AFA6       01461 	BTFSS arg1f24+2,7,1
00045A D008       01462 	BRA   m057
                  01463 			;        arg1f24 = -arg1f24;
00045C 80D8       01464 	BSF   0xFD8,Carry,0
00045E 0E00       01465 	MOVLW 0
000460 57A4       01466 	SUBFWB arg1f24,1,1
000462 0E00       01467 	MOVLW 0
000464 57A5       01468 	SUBFWB arg1f24+1,1,1
000466 0E00       01469 	MOVLW 0
000468 57A6       01470 	SUBFWB arg1f24+2,1,1
                  01471 			;        sign |= 0x80;
00046A 8FAC       01472 	BSF   sign_4,7,1
                  01473 			;    }
                  01474 			;    if (arg1f24.high8)  {
00046C 0100       01475 m057	MOVLB 0
00046E 53A6       01476 	MOVF  arg1f24+2,1,1
000470 B4D8       01477 	BTFSC 0xFD8,Zero_,0
000472 D009       01478 	BRA   m058
                  01479 			;        expo += 8;
000474 0E08       01480 	MOVLW 8
000476 27AA       01481 	ADDWF expo_2,1,1
                  01482 			;        xtra = arg1f24.low8;
000478 C0A4 F0AB  01483 	MOVFF arg1f24,xtra_2
                  01484 			;        arg1f24.low8 = arg1f24.mid8;
00047C C0A5 F0A4  01485 	MOVFF arg1f24+1,arg1f24
                  01486 			;        arg1f24.mid8 = arg1f24.high8;
000480 C0A6 F0A5  01487 	MOVFF arg1f24+2,arg1f24+1
                  01488 			;    }
                  01489 			;    else if (!arg1f24.mid8)  {
000484 D012       01490 	BRA   m060
000486 0100       01491 m058	MOVLB 0
000488 53A5       01492 	MOVF  arg1f24+1,1,1
00048A A4D8       01493 	BTFSS 0xFD8,Zero_,0
00048C D00E       01494 	BRA   m060
                  01495 			;        expo -= 8;
00048E 0E08       01496 	MOVLW 8
000490 5FAA       01497 	SUBWF expo_2,1,1
                  01498 			;        W = arg1f24.low8;
000492 51A4       01499 	MOVF  arg1f24,W,1
                  01500 			;        if (!W)
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 26

ADDR   CODE       LINE  SOURCE

000494 B4D8       01501 	BTFSC 0xFD8,Zero_,0
                  01502 			;            goto _RETURN_MF;
000496 D01D       01503 	BRA   m062
                  01504 			;        arg1f24.mid8 = W;
000498 0100       01505 	MOVLB 0
00049A 6FA5       01506 	MOVWF arg1f24+1,1
                  01507 			;        arg1f24.low8 = 0;
00049C 6BA4       01508 	CLRF  arg1f24,1
                  01509 			;    }
                  01510 			;
                  01511 			;    // arg1f24.mid8 != 0
                  01512 			;    goto TEST_ARG1_B15;
00049E D005       01513 	BRA   m060
                  01514 			;    do  {
                  01515 			;        xtra = rl( xtra);
0004A0 0100       01516 m059	MOVLB 0
0004A2 37AB       01517 	RLCF  xtra_2,1,1
                  01518 			;        arg1f24.low16 = rl( arg1f24.low16);
0004A4 37A4       01519 	RLCF  arg1f24,1,1
0004A6 37A5       01520 	RLCF  arg1f24+1,1,1
                  01521 			;        expo --;
0004A8 07AA       01522 	DECF  expo_2,1,1
                  01523 			;      TEST_ARG1_B15:
                  01524 			;    } while (!arg1f24.15);
0004AA 0100       01525 m060	MOVLB 0
0004AC AFA5       01526 	BTFSS arg1f24+1,7,1
0004AE D7F8       01527 	BRA   m059
                  01528 			;
                  01529 			;   #ifndef DISABLE_ROUNDING
                  01530 			;    if (FpRounding && (xtra & 0x80))  {
0004B0 ADCC       01531 	BTFSS 0xCC,FpRounding,1
0004B2 D00A       01532 	BRA   m061
0004B4 AFAB       01533 	BTFSS xtra_2,7,1
0004B6 D008       01534 	BRA   m061
                  01535 			;        arg1f24.low8 += 1;
0004B8 3FA4       01536 	INCFSZ arg1f24,1,1
                  01537 			;        if (!arg1f24.low8)  {
0004BA D006       01538 	BRA   m061
                  01539 			;            arg1f24.mid8 += 1;
0004BC 3FA5       01540 	INCFSZ arg1f24+1,1,1
                  01541 			;            if (!arg1f24.mid8)  {
0004BE D004       01542 	BRA   m061
                  01543 			;                Carry = 1;
0004C0 80D8       01544 	BSF   0xFD8,Carry,0
                  01545 			;                arg1f24.low16 = rr( arg1f24.low16);
0004C2 33A5       01546 	RRCF  arg1f24+1,1,1
0004C4 33A4       01547 	RRCF  arg1f24,1,1
                  01548 			;                expo ++;
0004C6 2BAA       01549 	INCF  expo_2,1,1
                  01550 			;            }
                  01551 			;        }
                  01552 			;    }
                  01553 			;   #endif
                  01554 			;
                  01555 			;    arg1f24.high8 = expo;
0004C8 C0AA F0A6  01556 m061	MOVFF expo_2,arg1f24+2
                  01557 			;    if (!(sign & 0x80))
0004CC 0100       01558 	MOVLB 0
0004CE AFAC       01559 	BTFSS sign_4,7,1
                  01560 			;        arg1f24.15 = 0;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 27

ADDR   CODE       LINE  SOURCE

0004D0 9FA5       01561 	BCF   arg1f24+1,7,1
                  01562 			;
                  01563 			;  _RETURN_MF:
                  01564 			;    float24 rval @ arg1f24;
                  01565 			;    rval.low24 = arg1f24.low24;
                  01566 			;    return rval;
0004D2 0100       01567 m062	MOVLB 0
0004D4 51A4       01568 	MOVF  rval,W,1
0004D6 0012       01569 	RETURN
                  01570 			;}
                  01571 			;
                  01572 			;
                  01573 			;float24 operator=( uns24 arg) @
                  01574 			;float24 operator= _int32ToFloat24( int32 arg32)
                  01575 			;{
                  01576 _int32ToFloat24
                  01577 			;    char expo = FpBIAS + 16 - 1;
                  01578 			;    char xtra @ arg32.high8;
                  01579 			;    char sign = 0;
                  01580 			;    if (arg32 < 0)  {
                  01581 			;        arg32 = -arg32;
                  01582 			;        sign |= 0x80;
                  01583 			;    }
                  01584 			;    if (arg32.high8)  {
                  01585 			;        expo += 8;
                  01586 			;        arg32.low8 = arg32.midL8;
                  01587 			;        arg32.midL8 = arg32.midH8;
                  01588 			;        arg32.midH8 = arg32.high8;
                  01589 			;        arg32.high8 = 0;
                  01590 			;    }
                  01591 			;    if (arg32.midH8)  {
                  01592 			;        expo += 8;
                  01593 			;        xtra = arg32.low8;
                  01594 			;        arg32.low8 = arg32.midL8;
                  01595 			;        arg32.midL8 = arg32.midH8;
                  01596 			;    }
                  01597 			;    else if (!arg32.midL8)  {
                  01598 			;        expo -= 8;
                  01599 			;        W = arg32.low8;
                  01600 			;        if (!W)
                  01601 			;            goto _RETURN_MF;
                  01602 			;        arg32.midL8 = W;
                  01603 			;        arg32.low8 = 0;
                  01604 			;    }
                  01605 			;
                  01606 			;    // arg32.midL8 != 0
                  01607 			;    goto TEST_ARG_B15;
                  01608 			;    do  {
                  01609 			;        xtra = rl( xtra);
                  01610 			;        arg32.low16 = rl( arg32.low16);
                  01611 			;        expo --;
                  01612 			;      TEST_ARG_B15:
                  01613 			;    } while (!arg32.15);
                  01614 			;
                  01615 			;   #ifndef DISABLE_ROUNDING
                  01616 			;    if (FpRounding && (xtra & 0x80))  {
                  01617 			;        arg32.low8 += 1;
                  01618 			;        if (!arg32.low8)  {
                  01619 			;            arg32.midL8 += 1;
                  01620 			;            if (!arg32.midL8)  {
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 28

ADDR   CODE       LINE  SOURCE

                  01621 			;                Carry = 1;
                  01622 			;                arg32.low16 = rr( arg32.low16);
                  01623 			;                expo ++;
                  01624 			;            }
                  01625 			;        }
                  01626 			;    }
                  01627 			;   #endif
                  01628 			;
                  01629 			;    arg32.midH8 = expo;
                  01630 			;    if (!(sign & 0x80))
                  01631 			;        arg32.15 = 0;
                  01632 			;
                  01633 			;  _RETURN_MF:
                  01634 			;    float24 rval @ arg32;
                  01635 			;    rval.low24 = arg32.low24;
                  01636 			;    return rval;
                  01637 			;}
                  01638 			;
                  01639 			;
                  01640 			;uns8 operator=( sharedM float24 arg1f24) @
                  01641 			;int8 operator=( sharedM float24 arg1f24) @
                  01642 			;uns16 operator=( sharedM float24 arg1f24) @
                  01643 			;int16 operator=( sharedM float24 arg1f24) @
                  01644 			;int24 operator= _float24ToInt24( sharedM float24 arg1f24)
                  01645 			;{
                  01646 _float24ToInt24
                  01647 			;    sharedM float24 arg2f24;   // unused, but required
                  01648 			;    char sign = arg1f24.mid8;
0004D8 C0A5 F0AA  01649 	MOVFF arg1f24+1,sign_6
                  01650 			;    char expo = arg1f24.high8 - (FpBIAS-1);
0004DC 0E7E       01651 	MOVLW 126
0004DE 0100       01652 	MOVLB 0
0004E0 5DA6       01653 	SUBWF arg1f24+2,W,1
0004E2 6FAB       01654 	MOVWF expo_4,1
                  01655 			;    if (!Carry)
0004E4 A0D8       01656 	BTFSS 0xFD8,Carry,0
                  01657 			;        goto RES0;
0004E6 D032       01658 	BRA   m068
                  01659 			;    arg1f24.15 = 1;
0004E8 0100       01660 	MOVLB 0
0004EA 8FA5       01661 	BSF   arg1f24+1,7,1
                  01662 			;
                  01663 			;    arg1f24.high8 = 0;
0004EC 6BA6       01664 	CLRF  arg1f24+2,1
                  01665 			;   #ifndef DISABLE_ROUNDING
                  01666 			;    char xtra = 0;
0004EE 6BAC       01667 	CLRF  xtra_4,1
                  01668 			;   #endif
                  01669 			;
                  01670 			;    // (a): expo = 0..8 : shift 1 byte to the right
                  01671 			;    // (b): expo = 9..16: shift 0 byte
                  01672 			;    // (c): expo = 17..24: shift 1 byte to the left
                  01673 			;   #if __CoreSet__ / 100 == 12
                  01674 			;    expo -= 17;
                  01675 			;    expo = 0xFF - expo;  // COMF (Carry unchanged)
                  01676 			;    if (Carry)  {  // (c)
                  01677 			;   #else
                  01678 			;    expo = 16 - expo;
0004F0 51AB       01679 	MOVF  expo_4,W,1
0004F2 0810       01680 	SUBLW 16
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 29

ADDR   CODE       LINE  SOURCE

0004F4 6FAB       01681 	MOVWF expo_4,1
                  01682 			;    if (!Carry)  {  // (c)
0004F6 B0D8       01683 	BTFSC 0xFD8,Carry,0
0004F8 D00B       01684 	BRA   m063
                  01685 			;   #endif
                  01686 			;        expo += 8;
0004FA 0E08       01687 	MOVLW 8
0004FC 27AB       01688 	ADDWF expo_4,1,1
                  01689 			;        if (!Carry)
0004FE A0D8       01690 	BTFSS 0xFD8,Carry,0
                  01691 			;            goto OVERFLOW;
000500 D021       01692 	BRA   m067
                  01693 			;        arg1f24.high8 = arg1f24.mid8;
000502 C0A5 F0A6  01694 	MOVFF arg1f24+1,arg1f24+2
                  01695 			;        arg1f24.mid8 = arg1f24.low8;
000506 C0A4 F0A5  01696 	MOVFF arg1f24,arg1f24+1
                  01697 			;        arg1f24.low8 = 0;
00050A 0100       01698 	MOVLB 0
00050C 6BA4       01699 	CLRF  arg1f24,1
                  01700 			;    }
                  01701 			;    else  {  // (a) (b)
00050E D00B       01702 	BRA   m064
                  01703 			;        // expo = 0 .. 16
                  01704 			;        W = expo - 8;
000510 0E08       01705 m063	MOVLW 8
000512 0100       01706 	MOVLB 0
000514 5DAB       01707 	SUBWF expo_4,W,1
                  01708 			;        if (Carry)  {  // (a)
000516 A0D8       01709 	BTFSS 0xFD8,Carry,0
000518 D006       01710 	BRA   m064
                  01711 			;            expo = W;
00051A 6FAB       01712 	MOVWF expo_4,1
                  01713 			;           #ifndef DISABLE_ROUNDING
                  01714 			;            xtra = arg1f24.low8;
00051C C0A4 F0AC  01715 	MOVFF arg1f24,xtra_4
                  01716 			;           #endif
                  01717 			;            arg1f24.low8 = arg1f24.mid8;
000520 C0A5 F0A4  01718 	MOVFF arg1f24+1,arg1f24
                  01719 			;            arg1f24.mid8 = 0;
000524 6BA5       01720 	CLRF  arg1f24+1,1
                  01721 			;        }
                  01722 			;    }
                  01723 			;    if (expo)  {
000526 0100       01724 m064	MOVLB 0
000528 53AB       01725 	MOVF  expo_4,1,1
00052A B4D8       01726 	BTFSC 0xFD8,Zero_,0
00052C D008       01727 	BRA   m066
                  01728 			;        do  {
                  01729 			;            Carry = 0;
00052E 90D8       01730 m065	BCF   0xFD8,Carry,0
                  01731 			;            arg1f24.high8 = rr( arg1f24.high8);
000530 0100       01732 	MOVLB 0
000532 33A6       01733 	RRCF  arg1f24+2,1,1
                  01734 			;            arg1f24.low16 = rr( arg1f24.low16);
000534 33A5       01735 	RRCF  arg1f24+1,1,1
000536 33A4       01736 	RRCF  arg1f24,1,1
                  01737 			;           #ifndef DISABLE_ROUNDING
                  01738 			;            xtra = rr( xtra);
000538 33AC       01739 	RRCF  xtra_4,1,1
                  01740 			;           #endif
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 30

ADDR   CODE       LINE  SOURCE

                  01741 			;        } while (--expo);
00053A 2FAB       01742 	DECFSZ expo_4,1,1
00053C D7F8       01743 	BRA   m065
                  01744 			;    }
                  01745 			;    if (arg1f24.23)  {
00053E 0100       01746 m066	MOVLB 0
000540 AFA6       01747 	BTFSS arg1f24+2,7,1
000542 D00B       01748 	BRA   m070
                  01749 			;       OVERFLOW:
                  01750 			;        FpOverflow = 1;
000544 0100       01751 m067	MOVLB 0
000546 83CC       01752 	BSF   0xCC,FpOverflow,1
                  01753 			;        W = 0xFF;
000548 0EFF       01754 	MOVLW 255
                  01755 			;        goto ASSIGNW;
00054A D001       01756 	BRA   m069
                  01757 			;       RES0:
                  01758 			;        W = 0;
00054C 0E00       01759 m068	MOVLW 0
                  01760 			;       ASSIGNW:
                  01761 			;        arg1f24.low8 = W;
00054E 0100       01762 m069	MOVLB 0
000550 6FA4       01763 	MOVWF arg1f24,1
                  01764 			;        arg1f24.mid8 = W;
000552 6FA5       01765 	MOVWF arg1f24+1,1
                  01766 			;        arg1f24.high8 = W;
000554 6FA6       01767 	MOVWF arg1f24+2,1
                  01768 			;        arg1f24.23 = 0;
000556 9FA6       01769 	BCF   arg1f24+2,7,1
                  01770 			;    }
                  01771 			;    else  {
000558 D011       01772 	BRA   m072
                  01773 			;       #ifndef DISABLE_ROUNDING
                  01774 			;        if (FpRounding && (xtra & 0x80))  {
00055A 0100       01775 m070	MOVLB 0
00055C ADCC       01776 	BTFSS 0xCC,FpRounding,1
00055E D004       01777 	BRA   m071
000560 AFAC       01778 	BTFSS xtra_4,7,1
000562 D002       01779 	BRA   m071
                  01780 			;            arg1f24.low8 += 1;
000564 4BA4       01781 	INFSNZ arg1f24,1,1
                  01782 			;            if (!arg1f24.low8)
                  01783 			;                arg1f24.mid8 += 1;
000566 2BA5       01784 	INCF  arg1f24+1,1,1
                  01785 			;        }
                  01786 			;       #endif
                  01787 			;        if (sign & 0x80)
000568 0100       01788 m071	MOVLB 0
00056A AFAA       01789 	BTFSS sign_6,7,1
00056C D007       01790 	BRA   m072
                  01791 			;            arg1f24.low24 = -arg1f24.low24;
00056E 80D8       01792 	BSF   0xFD8,Carry,0
000570 0E00       01793 	MOVLW 0
000572 57A4       01794 	SUBFWB arg1f24,1,1
000574 0E00       01795 	MOVLW 0
000576 57A5       01796 	SUBFWB arg1f24+1,1,1
000578 0E00       01797 	MOVLW 0
00057A 57A6       01798 	SUBFWB arg1f24+2,1,1
                  01799 			;    }
                  01800 			;    int24 rval @ arg1f24;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 31

ADDR   CODE       LINE  SOURCE

                  01801 			;    rval = arg1f24.low24;
                  01802 			;    return rval;
00057C 0100       01803 m072	MOVLB 0
00057E 51A4       01804 	MOVF  rval_3,W,1
000580 0012       01805 	RETURN
                  01806 			;}
                  01807 			;
                  01808 			;
                  01809 			;bit operator< _f24_LT_f24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  01810 			;{
                  01811 _f24_LT_f24
                  01812 			;    Carry = 0;
                  01813 			;    if (!(arg1f24.high8 | arg2f24.high8))
                  01814 			;        return Carry;
                  01815 			;    if (!arg1f24.15)  {
                  01816 			;        if (arg2f24.15)
                  01817 			;            return Carry;
                  01818 			;        W = arg1f24.low8 - arg2f24.low8;
                  01819 			;        genSubW( arg1f24.mid8, arg2f24.mid8);
                  01820 			;        genSubW( arg1f24.high8, arg2f24.high8);
                  01821 			;        goto _RETURN_MF;
                  01822 			;    }
                  01823 			;    if (!arg2f24.15)
                  01824 			;        goto _RETURN_MF;
                  01825 			;    W = arg2f24.low8 - arg1f24.low8;
                  01826 			;    genSubW( arg2f24.mid8, arg1f24.mid8);
                  01827 			;    genSubW( arg2f24.high8, arg1f24.high8);
                  01828 			;  _RETURN_MF:
                  01829 			;    if (Carry)
                  01830 			;        return 0;
                  01831 			;    return 1;
                  01832 			;}
                  01833 			;
                  01834 			;
                  01835 			;bit operator>= _f24_GE_f24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  01836 			;{
                  01837 _f24_GE_f24
                  01838 			;    Carry = 1;
                  01839 			;    if (!(arg1f24.high8 | arg2f24.high8))
                  01840 			;        return Carry;
                  01841 			;    if (!arg1f24.15)  {
                  01842 			;        if (arg2f24.15)
                  01843 			;            return Carry;
                  01844 			;        W = arg1f24.low8 - arg2f24.low8;
                  01845 			;        genSubW( arg1f24.mid8, arg2f24.mid8);
                  01846 			;        genSubW( arg1f24.high8, arg2f24.high8);
                  01847 			;        return Carry;
                  01848 			;    }
                  01849 			;    Carry = 0;
                  01850 			;    if (!arg2f24.15)
                  01851 			;        return Carry;
                  01852 			;    W = arg2f24.low8 - arg1f24.low8;
                  01853 			;    genSubW( arg2f24.mid8, arg1f24.mid8);
                  01854 			;    genSubW( arg2f24.high8, arg1f24.high8);
                  01855 			;    return Carry;
                  01856 			;}
                  01857 			;
                  01858 			;
                  01859 			;
                  01860 			;bit operator> _f24_GT_f24( sharedM float24 arg1f24, sharedM float24 arg2f24)
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 32

ADDR   CODE       LINE  SOURCE

                  01861 			;{
                  01862 _f24_GT_f24
                  01863 			;    Carry = 0;
                  01864 			;    if (!(arg1f24.high8 | arg2f24.high8))
                  01865 			;        return Carry;
                  01866 			;    if (!arg1f24.15)  {
                  01867 			;        if (arg2f24.15)
                  01868 			;            goto _RETURN_MF;
                  01869 			;        W = arg2f24.low8 - arg1f24.low8;
                  01870 			;        genSubW( arg2f24.mid8, arg1f24.mid8);
                  01871 			;        genSubW( arg2f24.high8, arg1f24.high8);
                  01872 			;        goto _RETURN_MF;
                  01873 			;    }
                  01874 			;    if (!arg2f24.15)
                  01875 			;        return Carry;
                  01876 			;    W = arg1f24.low8 - arg2f24.low8;
                  01877 			;    genSubW( arg1f24.mid8, arg2f24.mid8);
                  01878 			;    genSubW( arg1f24.high8, arg2f24.high8);
                  01879 			;  _RETURN_MF:
                  01880 			;    if (Carry)
                  01881 			;        return 0;
                  01882 			;    return 1;
                  01883 			;}
                  01884 			;
                  01885 			;
                  01886 			;
                  01887 			;bit operator<= _f24_LE_f24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  01888 			;{
                  01889 _f24_LE_f24
                  01890 			;    Carry = 1;
                  01891 			;    if (!(arg1f24.high8 | arg2f24.high8))
                  01892 			;        return Carry;
                  01893 			;    if (!arg1f24.15)  {
                  01894 			;        Carry = 0;
                  01895 			;        if (arg2f24.15)
                  01896 			;            return Carry;
                  01897 			;        W = arg2f24.low8 - arg1f24.low8;
                  01898 			;        genSubW( arg2f24.mid8, arg1f24.mid8);
                  01899 			;        genSubW( arg2f24.high8, arg1f24.high8);
                  01900 			;        return Carry;
                  01901 			;    }
                  01902 			;    if (!arg2f24.15)
                  01903 			;        return Carry;
                  01904 			;    W = arg1f24.low8 - arg2f24.low8;
                  01905 			;    genSubW( arg1f24.mid8, arg2f24.mid8);
                  01906 			;    genSubW( arg1f24.high8, arg2f24.high8);
                  01907 			;    return Carry;
                  01908 
                  01909   ; FILE C:\PIC\CC8E\MATH16.H
                  01910 			;// SIZE
                  01911 			;
                  01912 			;#pragma library 1
                  01913 			;/*
                  01914 			;uns16 operator* _mult8x8( uns8 arg1, uns8 arg2);
                  01915 			;uns16 operator* _multU16x8( uns16 arg1, uns8 arg2);
                  01916 			;uns16 operator* _mult16x16( uns16 arg1, uns16 arg2);
                  01917 			;uns16 operator/ _divU16_8( uns16 arg1, uns8 arg2);
                  01918 			;uns16 operator/ _divU16_16( uns16 arg1, uns16 arg2);
                  01919 			;int16 operator/ _divS16_8( int16 arg1, int8 arg2);
                  01920 			;int16 operator/ _divS16_16( int16 arg1, int16 arg2);
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 33

ADDR   CODE       LINE  SOURCE

                  01921 			;uns8 operator% _remU16_8( uns16 arg1, uns8 arg2);
                  01922 			;uns16 operator% _remU16_16( uns16 arg1, uns16 arg2);
                  01923 			;int8 operator% _remS16_8( int16 arg1, int8 arg2);
                  01924 			;int16 operator% _remS16_16( int16 arg1, int16 arg2);
                  01925 			;*/
                  01926 			;
                  01927 			;#if __CoreSet__ < 1600
                  01928 			; #define genAdd(r,a) W=a; btsc(Carry); W=incsz(a); r+=W
                  01929 			; #define genSub(r,a) W=a; btss(Carry); W=incsz(a); r-=W
                  01930 			; #define genAddW(r,a) W=a; btsc(Carry); W=incsz(a); W=r+W
                  01931 			; #define genSubW(r,a) W=a; btss(Carry); W=incsz(a); W=r-W
                  01932 			;#else
                  01933 			; #define genAdd(r,a) W=a; r=addWFC(r)
                  01934 			; #define genSub(r,a) W=a; r=subWFB(r)
                  01935 			; #define genAddW(r,a) W=a; W=addWFC(r)
                  01936 			; #define genSubW(r,a) W=a; W=subWFB(r)
                  01937 			;#endif
                  01938 			;
                  01939 			;#if __CoreSet__ == 1700 || __CoreSet__ == 1800
                  01940 			; #define hw_mult8x8(a,b)  W = a; multiply(b)
                  01941 			; #define loRES PRODL
                  01942 			; #define hiRES PRODH
                  01943 			;#endif
                  01944 			;
                  01945 			;#if __CoreSet__ == 2000
                  01946 			; #define hw_mult8x8(a,b)  W = a; multiply(b)
                  01947 			; #define loRES W
                  01948 			; #define hiRES MULH
                  01949 			;#endif
                  01950 			;
                  01951 			;
                  01952 			;
                  01953 			;#ifdef hw_mult8x8
                  01954 			;
                  01955 			;inline int16 operator*( int8 arg1, int8 arg2);
                  01956 			;inline uns16 operator*( uns8 arg1, uns8 arg2);
                  01957 			;inline int16 operator*( int8 arg1, int16 arg2);
                  01958 			;inline uns16 operator*( uns8 arg1, uns16 arg2);
                  01959 			;inline int16 operator*( int16 arg1, int8 arg2);
                  01960 			;inline uns16 operator*( uns16 arg1, uns8 arg2);
                  01961 			;inline int16 operator*( int16 arg1, int16 arg2);
                  01962 			;inline uns16 operator*( uns16 arg1, uns16 arg2);
                  01963 			;
                  01964 			;#undef hw_mult8x8
                  01965 			;#undef loRES
                  01966 			;#undef hiRES
                  01967 			;
                  01968 			;#else
                  01969 			;
                  01970 			;int8 operator*( int8 arg1, int8 arg2)  @
                  01971 			;
                  01972 			;uns16 operator* _mult8x8( uns8 arg1, uns8 arg2)
                  01973 			;{
                  01974 			;    uns16 rval;
                  01975 			;    char counter = sizeof(arg2)*8;
                  01976 			;    rval.high8 = 0;
                  01977 			;    W = arg1;
                  01978 			;    do  {
                  01979 			;        arg2 = rr( arg2);
                  01980 			;        if (Carry)
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 34

ADDR   CODE       LINE  SOURCE

                  01981 			;            rval.high8 += W;
                  01982 			;        rval = rr( rval);
                  01983 			;        counter = decsz(counter);
                  01984 			;    } while (1);
                  01985 			;    return rval;
                  01986 			;}
                  01987 			;
                  01988 			;
                  01989 			;uns16 operator*( uns8 arg1, uns16 arg2) exchangeArgs @
                  01990 			;
                  01991 			;uns16 operator* _multU16x8( uns16 arg1, uns8 arg2)
                  01992 			;{
                  01993 			;    uns16 rval;
                  01994 			;    uns8 rvalH = 0;
                  01995 			;    char counter = sizeof(arg1)*8;
                  01996 			;    W = arg2;
                  01997 			;    do  {
                  01998 			;        arg1 = rr( arg1);
                  01999 			;        if (Carry)
                  02000 			;            rvalH += W;
                  02001 			;        rvalH = rr(rvalH);
                  02002 			;        rval = rr(rval);
                  02003 			;        counter = decsz(counter);
                  02004 			;    } while (1);
                  02005 			;    return rval;
                  02006 			;}
                  02007 			;
                  02008 			;
                  02009 			;int16 operator*( int16 arg1, int16 arg2) @
                  02010 			;
                  02011 			;uns16 operator* _mult16x16( uns16 arg1, uns16 arg2)
                  02012 			;{
                  02013 			;    uns16 rval;
                  02014 			;    char counter = sizeof(arg1)*8;
                  02015 			;    do  {
                  02016 			;        Carry = 0;
                  02017 			;        rval = rl( rval);
                  02018 			;        arg1 = rl( arg1);
                  02019 			;        if (Carry)
                  02020 			;            rval += arg2;
                  02021 			;        counter = decsz(counter);
                  02022 			;    } while (1);
                  02023 			;    return rval;
                  02024 			;}
                  02025 			;
                  02026 			;#endif
                  02027 			;
                  02028 			;
                  02029 			;uns16 operator/ _divU16_8( uns16 arg1, uns8 arg2)
                  02030 			;{
                  02031 _divU16_8
000582 0100       02032 	MOVLB 0
000584 6FBA       02033 	MOVWF arg2,1
                  02034 			;    uns8 rm = 0;
000586 6BBB       02035 	CLRF  rm,1
                  02036 			;    char counter = sizeof(arg1)*8+1;
000588 0E11       02037 	MOVLW 17
00058A 6FBC       02038 	MOVWF counter_2,1
                  02039 			;    goto ENTRY_ML;
00058C D00B       02040 	BRA   m074
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 35

ADDR   CODE       LINE  SOURCE

                  02041 			;    do  {
                  02042 			;        rm = rl( rm);
00058E 0100       02043 m073	MOVLB 0
000590 37BB       02044 	RLCF  rm,1,1
                  02045 			;        uns8 tmp = rl( tmp);
000592 37BD       02046 	RLCF  tmp,1,1
                  02047 			;        W = rm - arg2;
000594 51BA       02048 	MOVF  arg2,W,1
000596 5DBB       02049 	SUBWF rm,W,1
                  02050 			;        if (tmp&1)
000598 B1BD       02051 	BTFSC tmp,0,1
                  02052 			;            Carry = 1;
00059A 80D8       02053 	BSF   0xFD8,Carry,0
                  02054 			;        if (Carry)
00059C A0D8       02055 	BTFSS 0xFD8,Carry,0
00059E D002       02056 	BRA   m074
                  02057 			;            rm = W;
0005A0 0100       02058 	MOVLB 0
0005A2 6FBB       02059 	MOVWF rm,1
                  02060 			;       ENTRY_ML:
                  02061 			;        arg1 = rl( arg1);
0005A4 0100       02062 m074	MOVLB 0
0005A6 37B8       02063 	RLCF  arg1,1,1
0005A8 37B9       02064 	RLCF  arg1+1,1,1
                  02065 			;        counter = decsz(counter);
0005AA 2FBC       02066 	DECFSZ counter_2,1,1
                  02067 			;    } while (1);
0005AC D7F0       02068 	BRA   m073
                  02069 			;    return arg1;
0005AE 51B8       02070 	MOVF  arg1,W,1
0005B0 0012       02071 	RETURN
                  02072 			;}
                  02073 			;
                  02074 			;
                  02075 			;uns16 operator/ _divU16_16( uns16 arg1, uns16 arg2)
                  02076 			;{
                  02077 _divU16_16
                  02078 			;    uns16 rm = 0;
0005B2 0100       02079 	MOVLB 0
0005B4 6BBC       02080 	CLRF  rm_2,1
0005B6 6BBD       02081 	CLRF  rm_2+1,1
                  02082 			;    char counter = sizeof(arg1)*8+1;
0005B8 0E11       02083 	MOVLW 17
0005BA 6FBE       02084 	MOVWF counter_3,1
                  02085 			;    goto ENTRY_ML;
0005BC D00E       02086 	BRA   m076
                  02087 			;    do  {
                  02088 			;        rm = rl( rm);
0005BE 0100       02089 m075	MOVLB 0
0005C0 37BC       02090 	RLCF  rm_2,1,1
0005C2 37BD       02091 	RLCF  rm_2+1,1,1
                  02092 			;        W = rm.low8 - arg2.low8;
0005C4 51BA       02093 	MOVF  arg2_2,W,1
0005C6 5DBC       02094 	SUBWF rm_2,W,1
                  02095 			;        genSubW( rm.high8, arg2.high8);
0005C8 51BB       02096 	MOVF  arg2_2+1,W,1
0005CA 59BD       02097 	SUBWFB rm_2+1,W,1
                  02098 			;        if (!Carry)
0005CC A0D8       02099 	BTFSS 0xFD8,Carry,0
                  02100 			;            goto ENTRY_ML;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 36

ADDR   CODE       LINE  SOURCE

0005CE D005       02101 	BRA   m076
                  02102 			;        rm.high8 = W;
0005D0 0100       02103 	MOVLB 0
0005D2 6FBD       02104 	MOVWF rm_2+1,1
                  02105 			;        rm.low8 -= arg2.low8;
0005D4 51BA       02106 	MOVF  arg2_2,W,1
0005D6 5FBC       02107 	SUBWF rm_2,1,1
                  02108 			;        Carry = 1;
0005D8 80D8       02109 	BSF   0xFD8,Carry,0
                  02110 			;       ENTRY_ML:
                  02111 			;        arg1 = rl( arg1);
0005DA 0100       02112 m076	MOVLB 0
0005DC 37B8       02113 	RLCF  arg1_2,1,1
0005DE 37B9       02114 	RLCF  arg1_2+1,1,1
                  02115 			;        counter = decsz(counter);
0005E0 2FBE       02116 	DECFSZ counter_3,1,1
                  02117 			;    } while (1);
0005E2 D7ED       02118 	BRA   m075
                  02119 			;    return arg1;
0005E4 51B8       02120 	MOVF  arg1_2,W,1
0005E6 0012       02121 	RETURN
                  02122 			;}
                  02123 			;
                  02124 			;
                  02125 			;int8  operator/ (int8 arg1, int8 arg2) @
                  02126 			;
                  02127 			;int16 operator/ _divS16_8( int16 arg1, int8 arg2)
                  02128 			;{
                  02129 _divS16_8
                  02130 			;    uns8 rm = 0;
                  02131 			;    char counter = 16+1;
                  02132 			;    char sign = arg1.high8 ^ arg2.high8;
                  02133 			;    if (arg1 < 0)  {
                  02134 			;       INVERT_ML:
                  02135 			;        arg1 = -arg1;
                  02136 			;        if (!counter)
                  02137 			;            return arg1;
                  02138 			;    }
                  02139 			;    if (arg2 < 0)
                  02140 			;        arg2 = -arg2;
                  02141 			;    goto ENTRY_ML;
                  02142 			;    do  {
                  02143 			;        rm = rl( rm);
                  02144 			;        W = rm - arg2;
                  02145 			;        if (Carry)
                  02146 			;            rm = W;
                  02147 			;       ENTRY_ML:
                  02148 			;        arg1 = rl( arg1);
                  02149 			;        counter = decsz(counter);
                  02150 			;    } while (1);
                  02151 			;    if (sign & 0x80)
                  02152 			;        goto INVERT_ML;
                  02153 			;    return arg1;
                  02154 			;}
                  02155 			;
                  02156 			;
                  02157 			;int16 operator/ _divS16_16( int16 arg1, int16 arg2)
                  02158 			;{
                  02159 _divS16_16
                  02160 			;    uns16 rm = 0;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 37

ADDR   CODE       LINE  SOURCE

                  02161 			;    char counter = sizeof(arg1)*8+1;
                  02162 			;    char sign = arg1.high8 ^ arg2.high8;
                  02163 			;    if (arg1 < 0)  {
                  02164 			;       INVERT_ML:
                  02165 			;        arg1 = -arg1;
                  02166 			;        if (!counter)
                  02167 			;            return arg1;
                  02168 			;    }
                  02169 			;    if (arg2 < 0)
                  02170 			;        arg2 = -arg2;
                  02171 			;    goto ENTRY_ML;
                  02172 			;    do  {
                  02173 			;        rm = rl( rm);
                  02174 			;        W = rm.low8 - arg2.low8;
                  02175 			;        genSubW( rm.high8, arg2.high8);
                  02176 			;        if (!Carry)
                  02177 			;            goto ENTRY_ML;
                  02178 			;        rm.high8 = W;
                  02179 			;        rm.low8 -= arg2.low8;
                  02180 			;        Carry = 1;
                  02181 			;       ENTRY_ML:
                  02182 			;        arg1 = rl( arg1);
                  02183 			;        counter = decsz(counter);
                  02184 			;    } while (1);
                  02185 			;    if (sign & 0x80)
                  02186 			;        goto INVERT_ML;
                  02187 			;    return arg1;
                  02188 			;}
                  02189 			;
                  02190 			;
                  02191 			;uns8 operator% _remU16_8( uns16 arg1, uns8 arg2)
                  02192 			;{
                  02193 _remU16_8
0005E8 0100       02194 	MOVLB 0
0005EA 6FBA       02195 	MOVWF arg2_5,1
                  02196 			;    uns8 rm = 0;
0005EC 6BBB       02197 	CLRF  rm_5,1
                  02198 			;    char counter = sizeof(arg1)*8;
0005EE 0E10       02199 	MOVLW 16
0005F0 6FBC       02200 	MOVWF counter_6,1
                  02201 			;    do  {
                  02202 			;        arg1 = rl( arg1);
0005F2 0100       02203 m077	MOVLB 0
0005F4 37B8       02204 	RLCF  arg1_5,1,1
0005F6 37B9       02205 	RLCF  arg1_5+1,1,1
                  02206 			;        rm = rl( rm);
0005F8 37BB       02207 	RLCF  rm_5,1,1
                  02208 			;        uns8 tmp = rl( tmp);
0005FA 37BD       02209 	RLCF  tmp_2,1,1
                  02210 			;        W = rm - arg2;
0005FC 51BA       02211 	MOVF  arg2_5,W,1
0005FE 5DBB       02212 	SUBWF rm_5,W,1
                  02213 			;        if (tmp&1)
000600 B1BD       02214 	BTFSC tmp_2,0,1
                  02215 			;            Carry = 1;
000602 80D8       02216 	BSF   0xFD8,Carry,0
                  02217 			;        if (Carry)
000604 A0D8       02218 	BTFSS 0xFD8,Carry,0
000606 D002       02219 	BRA   m078
                  02220 			;            rm = W;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 38

ADDR   CODE       LINE  SOURCE

000608 0100       02221 	MOVLB 0
00060A 6FBB       02222 	MOVWF rm_5,1
                  02223 			;        counter = decsz(counter);
00060C 0100       02224 m078	MOVLB 0
00060E 2FBC       02225 	DECFSZ counter_6,1,1
                  02226 			;    } while (1);
000610 D7F0       02227 	BRA   m077
                  02228 			;    return rm;
000612 51BB       02229 	MOVF  rm_5,W,1
000614 0012       02230 	RETURN
                  02231 			;}
                  02232 			;
                  02233 			;
                  02234 			;uns16 operator% _remU16_16( uns16 arg1, uns16 arg2)
                  02235 			;{
                  02236 _remU16_16
                  02237 			;    uns16 rm = 0;
000616 0100       02238 	MOVLB 0
000618 6BBC       02239 	CLRF  rm_6,1
00061A 6BBD       02240 	CLRF  rm_6+1,1
                  02241 			;    char counter = sizeof(arg1)*8;
00061C 0E10       02242 	MOVLW 16
00061E 6FBE       02243 	MOVWF counter_7,1
                  02244 			;    do  {
                  02245 			;        arg1 = rl( arg1);
000620 0100       02246 m079	MOVLB 0
000622 37B8       02247 	RLCF  arg1_6,1,1
000624 37B9       02248 	RLCF  arg1_6+1,1,1
                  02249 			;        rm = rl( rm);
000626 37BC       02250 	RLCF  rm_6,1,1
000628 37BD       02251 	RLCF  rm_6+1,1,1
                  02252 			;        W = rm.low8 - arg2.low8;
00062A 51BA       02253 	MOVF  arg2_6,W,1
00062C 5DBC       02254 	SUBWF rm_6,W,1
                  02255 			;        genSubW( rm.high8, arg2.high8);
00062E 51BB       02256 	MOVF  arg2_6+1,W,1
000630 59BD       02257 	SUBWFB rm_6+1,W,1
                  02258 			;        if (!Carry)
000632 A0D8       02259 	BTFSS 0xFD8,Carry,0
                  02260 			;            goto NOSUB;
000634 D004       02261 	BRA   m080
                  02262 			;        rm.high8 = W;
000636 0100       02263 	MOVLB 0
000638 6FBD       02264 	MOVWF rm_6+1,1
                  02265 			;        rm.low8 -= arg2.low8;
00063A 51BA       02266 	MOVF  arg2_6,W,1
00063C 5FBC       02267 	SUBWF rm_6,1,1
                  02268 			;      NOSUB:
                  02269 			;        counter = decsz(counter);
00063E 0100       02270 m080	MOVLB 0
000640 2FBE       02271 	DECFSZ counter_7,1,1
                  02272 			;    } while (1);
000642 D7EE       02273 	BRA   m079
                  02274 			;    return rm;
000644 51BC       02275 	MOVF  rm_6,W,1
000646 0012       02276 	RETURN
                  02277 			;}
                  02278 			;
                  02279 			;
                  02280 			;int8 operator% (int8 arg1, int8 arg2) @
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 39

ADDR   CODE       LINE  SOURCE

                  02281 			;
                  02282 			;int8 operator% _remS16_8( int16 arg1, int8 arg2)
                  02283 			;{
                  02284 _remS16_8
                  02285 			;    int8 rm = 0;
                  02286 			;    char counter = 16;
                  02287 			;    char sign = arg1.high8;
                  02288 			;    if (arg1 < 0)
                  02289 			;        arg1 = -arg1;
                  02290 			;    if (arg2 < 0)
                  02291 			;        arg2 = -arg2;
                  02292 			;    do  {
                  02293 			;        arg1 = rl( arg1);
                  02294 			;        rm = rl( rm);
                  02295 			;        W = rm - arg2;
                  02296 			;        if (Carry)
                  02297 			;            rm = W;
                  02298 			;        counter = decsz(counter);
                  02299 			;    } while (1);
                  02300 			;    if (sign & 0x80)
                  02301 			;        rm = -rm;
                  02302 			;    return rm;
                  02303 			;}
                  02304 			;
                  02305 			;
                  02306 			;int16 operator% _remS16_16( int16 arg1, int16 arg2)
                  02307 			;{
                  02308 _remS16_16
                  02309 			;    int16 rm = 0;
                  02310 			;    char counter = sizeof(arg1)*8;
                  02311 			;    char sign = arg1.high8;
                  02312 			;    if (arg1 < 0)
                  02313 			;        arg1 = -arg1;
                  02314 			;    if (arg2 < 0)
                  02315 			;        arg2 = -arg2;
                  02316 			;    do  {
                  02317 			;        arg1 = rl( arg1);
                  02318 			;        rm = rl( rm);
                  02319 			;        W = rm.low8 - arg2.low8;
                  02320 			;        genSubW( rm.high8, arg2.high8);
                  02321 			;        if (!Carry)
                  02322 			;            goto NOSUB;
                  02323 			;        rm.high8 = W;
                  02324 			;        rm.low8 -= arg2.low8;
                  02325 			;      NOSUB:
                  02326 			;        counter = decsz(counter);
                  02327 			;    } while (1);
                  02328 			;    if (sign & 0x80)
                  02329 			;        rm = -rm;
                  02330 			;    return rm;
                  02331 
                  02332   ; FILE C:\PIC\CC8E\MATH24LB.H
                  02333 			;// *************************************************
                  02334 			;// 24 bit floating point math functions
                  02335 			;// Copyright (c) B Knudsen Data, Norway, 2000 - 2006
                  02336 			;// *************************************************
                  02337 			;
                  02338 			;#pragma library 1
                  02339 			;/* PROTOTYPES for page definition in application header file:
                  02340 			;float24 log( float24 arg1f24);
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 40

ADDR   CODE       LINE  SOURCE

                  02341 			;float24 log10( float24 arg1f24);
                  02342 			;float24 exp10( float24 arg1f24);
                  02343 			;float24 exp( float24 arg1f24);
                  02344 			;float24 cos( float24 arg1f24);
                  02345 			;float24 sin( float24 arg1f24);
                  02346 			;float24 sqrt( float24 arg1f24);
                  02347 			;*/
                  02348 			;
                  02349 			;#ifndef FpFlags_defined
                  02350 			; #error The basic 24 bit floating point math library must be included first
                  02351 			;#endif
                  02352 			;
                  02353 			;#if __CoreSet__ / 100 == 12
                  02354 			; #error Math functions (exp,log,..) are not adapted to 12 bit core devices
                  02355 			;#endif
                  02356 			;
                  02357 			;#if __CoreSet__ < 1600
                  02358 			; #define genAdd(r,a) W=a; btsc(Carry); W=incsz(a); r+=W
                  02359 			; #define genSub(r,a) W=a; btss(Carry); W=incsz(a); r-=W
                  02360 			; #define genAddW(r,a) W=a; btsc(Carry); W=incsz(a); W=r+W
                  02361 			; #define genSubW(r,a) W=a; btss(Carry); W=incsz(a); W=r-W
                  02362 			;#else
                  02363 			; #define genAdd(r,a) W=a; r=addWFC(r)
                  02364 			; #define genSub(r,a) W=a; r=subWFB(r)
                  02365 			; #define genAddW(r,a) W=a; W=addWFC(r)
                  02366 			; #define genSubW(r,a) W=a; W=subWFB(r)
                  02367 			;#endif
                  02368 			;
                  02369 			;
                  02370 			;float24 log( sharedM float24 arg1f24)
                  02371 			;{
                  02372 log
                  02373 			;    sharedM float24 arg2f24;
                  02374 			;
                  02375 			;    if (arg1f24.mid8 & 0x80)  //  test for negative argument
                  02376 			;        goto _DOMERR32;
                  02377 			;    if (!arg1f24.high8)   //  test for zero argument
                  02378 			;        goto _DOMERR32;
                  02379 			;
                  02380 			;    char savedFlags = FpFlags;   //  save rounding flag
                  02381 			;    FpFlags |= 0x40;  //  enable rounding
                  02382 			;
                  02383 			;    char xexp = arg1f24.high8 - (FpBIAS-1);
                  02384 			;    arg1f24.high8 = FpBIAS-1;
                  02385 			;
                  02386 			;    arg2f24 = 1.0;
                  02387 			;
                  02388 			;    //  .70710678118655 = 7E3504F3
                  02389 			;    W = arg1f24.low8 - 0x05;
                  02390 			;    W = 0x35;
                  02391 			;    if (!Carry)
                  02392 			;        W = 0x35+1;
                  02393 			;    W = arg1f24.mid8 - W;
                  02394 			;
                  02395 			;    if (Carry)
                  02396 			;        arg1f24 -= arg2f24;
                  02397 			;    else  {
                  02398 			;        arg1f24.high8 += 1;  /* arg1f24 *= 2; */
                  02399 			;        arg1f24 -= arg2f24;
                  02400 			;        xexp -= 1;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 41

ADDR   CODE       LINE  SOURCE

                  02401 			;    }
                  02402 			;
                  02403 			;    float24 d = arg1f24;  //  save z
                  02404 			;
                  02405 			;    // POLL132  LOG32Q,2,0  ; Q(z)
                  02406 			;    arg1f24 += 0.33339502905E+1; /* LOG32Q1 */
                  02407 			;    arg1f24 *= d;
                  02408 			;    arg1f24 += 0.24993759223E1;  /* LOG32Q0 */
                  02409 			;    float24 c = arg1f24;
                  02410 			;
                  02411 			;     //   minimax rational approximation  z-.5*z*z+z*(z*z*P(z)/Q(z))
                  02412 			;    // POL32  LOG32P,1,0  ; P(z)
                  02413 			;    arg1f24 = d;
                  02414 			;    arg1f24 *= 0.48646956294; /* LOG32P1 */
                  02415 			;    arg1f24 += 0.83311400452; /* LOG32P0 */
                  02416 			;
                  02417 			;    c = arg1f24 / c;   //  P(z)/Q(z)
                  02418 			;
                  02419 			;    W = d.high8;  arg1f24.high8 = W;  arg2f24.high8 = W;
                  02420 			;    W = d.mid8;   arg1f24.mid8 = W;   arg2f24.mid8 = W;
                  02421 			;    W = d.low8;   arg1f24.low8 = W;   arg2f24.low8 = W;
                  02422 			;
                  02423 			;    arg1f24 *= arg2f24;       // z * z;
                  02424 			;
                  02425 			;    float24 e = arg1f24;
                  02426 			;    arg1f24 *= c;          //  z*z*P(z)/Q(z)
                  02427 			;    arg1f24 *= d;          //  z*(z*z*P(z)/Q(z))
                  02428 			;
                  02429 			;    arg2f24 = e;
                  02430 			;    if (arg2f24.high8)
                  02431 			;        arg2f24.high8 --;  // arg2f24 *= 0.5;
                  02432 			;    arg1f24 -= arg2f24;       //  -.5*z*z + z*(z*z*P(z)/Q(z))
                  02433 			;    arg1f24 += d;          //  z -.5*z*z + z*(z*z*P(z)/Q(z))
                  02434 			;
                  02435 			;    if (!xexp)
                  02436 			;        goto _RETURN_MF;
                  02437 			;
                  02438 			;    e = arg1f24;  //  save
                  02439 			;
                  02440 			;    // integer to floating point conversion
                  02441 			;    arg1f24 = (int8) xexp;
                  02442 			;
                  02443 			;    d = arg1f24;  //  save k
                  02444 			;
                  02445 			;    arg1f24 *= -0.000212194440055;
                  02446 			;
                  02447 			;    arg1f24 += e;   //  log(1+z) + k*log(2)
                  02448 			;
                  02449 			;    e = arg1f24;  //  save
                  02450 			;
                  02451 			;    arg1f24 = d * 0.693359375;
                  02452 			;
                  02453 			;    arg1f24 += e;      //  log(1+z) + k*log(2)
                  02454 			;
                  02455 			;    if (!(savedFlags & 0x40))
                  02456 			;        FpFlags &= ~0x40;   //  restore rounding flag
                  02457 			;    goto _RETURN_MF;
                  02458 			;
                  02459 			;  _DOMERR32:
                  02460 			;    FpDomainError = 1;   //  domain error
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 42

ADDR   CODE       LINE  SOURCE

                  02461 			;
                  02462 			;  _RETURN_MF:
                  02463 			;    return arg1f24;
                  02464 			;}
                  02465 			;
                  02466 			;
                  02467 			;
                  02468 			;float24 log10( sharedM float24 arg1f24)
                  02469 			;{
                  02470 log10
                  02471 			;    sharedM float24 arg2f24;      // allocation 'trick'
                  02472 			;
                  02473 			;    char flags = FpFlags;
                  02474 			;    FpFlags |= 0x40;
                  02475 			;
                  02476 			;    arg1f24 = log( arg1f24);
                  02477 			;
                  02478 			;    arg1f24 *= 0.43429448190325;  //  log10(e);
                  02479 			;
                  02480 			;    if (!(flags & 0x40))
                  02481 			;        FpFlags &= ~0x40;
                  02482 			;
                  02483 			;    return arg1f24;
                  02484 			;}
                  02485 			;
                  02486 			;
                  02487 			;
                  02488 			;char floorMaskTable24( char i)
                  02489 			;{
                  02490 floorMaskTable24
                  02491 			;    if (i & 4)  {
                  02492 			;        if (i & 2)  {
                  02493 			;            if (i & 1)
                  02494 			;                return 128;
                  02495 			;            return 192;
                  02496 			;        }
                  02497 			;        if (i & 1)
                  02498 			;            return 224;
                  02499 			;        return 240;
                  02500 			;    }
                  02501 			;    if (i & 2)  {
                  02502 			;        if (i & 1)
                  02503 			;            return 248;
                  02504 			;        return 252;
                  02505 			;    }
                  02506 			;    if (i & 1)
                  02507 			;        return 254;
                  02508 			;    return 255;
                  02509 			;}
                  02510 			;
                  02511 			;float24 floor24( sharedM float24 arg1f24)
                  02512 			;{
                  02513 floor24
                  02514 			;    if (!arg1f24.high8)
                  02515 			;        goto _RETURN_MF;
                  02516 			;
                  02517 			;    uns16 ma = arg1f24.low16;  //  save mantissa
                  02518 			;
                  02519 			;    W = arg1f24.high8 - 127;
                  02520 			;    char tmp = W;      // OPM
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 43

ADDR   CODE       LINE  SOURCE

                  02521 			;    if (tmp & 0x80)
                  02522 			;        goto FLOOR24ZERO;
                  02523 			;
                  02524 			;    //  save number of zero bits
                  02525 			;    W = 15 - W;
                  02526 			;
                  02527 			;    char tmpa = W;
                  02528 			;    tmp = W;
                  02529 			;
                  02530 			;    if (tmp & 0x8)  // LSB+3		; divide by eight
                  02531 			;        goto FLOOR24MASKH;
                  02532 			;
                  02533 			;
                  02534 			;    W = floorMaskTable24( tmpa);    //  get mask
                  02535 			;    arg1f24.low8 &= W;
                  02536 			;    if (!(arg1f24.mid8 & 0x80))  //  if negative, round down
                  02537 			;        goto _RETURN_MF;
                  02538 			;
                  02539 			;    char arg1B7 = W;
                  02540 			;    if (!(arg1f24.low8 - ma.low8))
                  02541 			;        goto _RETURN_MF;
                  02542 			;
                  02543 			;    tmp = ~arg1B7;
                  02544 			;    arg1f24.low8 += tmp + 1;
                  02545 			;    if (Zero_)
                  02546 			;        arg1f24.mid8 += 1;
                  02547 			;
                  02548 			;    //  has rounding caused carryout?
                  02549 			;    if (!Zero_)
                  02550 			;        goto _RETURN_MF;
                  02551 			;    arg1f24.mid8 = rr( arg1f24.mid8);
                  02552 			;    arg1f24.low8 = rr( arg1f24.low8);
                  02553 			;
                  02554 			;    //  check for overflow
                  02555 			;    arg1f24.high8 = incsz( arg1f24.high8);
                  02556 			;    goto _RETURN_MF;
                  02557 			;    goto OVERFLOW;
                  02558 			;
                  02559 			;
                  02560 			;  FLOOR24MASKH:
                  02561 			;    W = floorMaskTable24( tmpa);  //  get mask
                  02562 			;    arg1f24.mid8 &= W;
                  02563 			;    arg1f24.low8 = 0;
                  02564 			;
                  02565 			;    //  if negative, round down
                  02566 			;    if (!(arg1f24.mid8 & 0x80))
                  02567 			;        goto _RETURN_MF;
                  02568 			;
                  02569 			;    arg1B7 = W;
                  02570 			;    if (( arg1f24.low8 - ma.low8) != 0)
                  02571 			;        goto FLOOR24RNDH;
                  02572 			;    if (!(arg1f24.mid8 - ma.mid8))
                  02573 			;        goto _RETURN_MF;
                  02574 			;
                  02575 			;  FLOOR24RNDH:
                  02576 			;    tmp = ~arg1B7;
                  02577 			;    arg1f24.mid8 += tmp + 1;
                  02578 			;
                  02579 			;    //  has rounding caused carryout?
                  02580 			;    if (!Carry)
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 44

ADDR   CODE       LINE  SOURCE

                  02581 			;        goto _RETURN_MF;
                  02582 			;    arg1f24.mid8 = rr( arg1f24.mid8);
                  02583 			;    arg1f24.low8 = rr( arg1f24.low8);
                  02584 			;
                  02585 			;    //  check for overflow
                  02586 			;    arg1f24.high8 = incsz( arg1f24.high8);
                  02587 			;    goto _RETURN_MF;
                  02588 			;    goto OVERFLOW;
                  02589 			;
                  02590 			;
                  02591 			;  FLOOR24ZERO:
                  02592 			;    if (!(arg1f24.mid8 & 0x80))
                  02593 			;        goto RES0;
                  02594 			;    return -1.0;
                  02595 			;
                  02596 			;  RES0:
                  02597 			;    W = 0;
                  02598 			;    goto ASSIGNW;
                  02599 			;
                  02600 			;  OVERFLOW:
                  02601 			;    FpOverflow = 1;
                  02602 			;    W = 0xFF;
                  02603 			;  ASSIGNW:
                  02604 			;    arg1f24.low8 = W;
                  02605 			;    arg1f24.mid8 = W;
                  02606 			;    arg1f24.high8 = W;
                  02607 			;
                  02608 			;  _RETURN_MF:
                  02609 			;    return arg1f24;
                  02610 			;}
                  02611 			;
                  02612 			;
                  02613 			;
                  02614 			;float24 exp10( sharedM float24 arg1f24)
                  02615 			;{
                  02616 exp10
                  02617 			;    sharedM float24 arg2f24;      // allocation 'trick'
                  02618 			;    float24 c, d;
                  02619 			;    char xexp;
                  02620 			;
                  02621 			;    if (( arg1f24.high8 - 100) & 0x80)
                  02622 			;        goto EXP1;   //  return e**x = 1
                  02623 			;
                  02624 			;    W = 132 - arg1f24.high8;
                  02625 			;    if (!Carry)
                  02626 			;        goto _DOMERR;
                  02627 			;    if (!Zero_)
                  02628 			;        goto ARGOK;
                  02629 			;
                  02630 			;    if (!(arg1f24.mid8 & 0x80))  {
                  02631 			;        //  positive domain check
                  02632 			;        W = 26 - arg1f24.mid8;
                  02633 			;        if (!Carry)
                  02634 			;            goto _DOMERR;
                  02635 			;        if (!Zero_)
                  02636 			;            goto ARGOK;
                  02637 			;
                  02638 			;        W = 33 - arg1f24.low8;
                  02639 			;        if (!Carry)
                  02640 			;            goto _DOMERR;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 45

ADDR   CODE       LINE  SOURCE

                  02641 			;    }
                  02642 			;    else  {
                  02643 			;
                  02644 			;        W = 151 - arg1f24.mid8;
                  02645 			;        if (!Carry)
                  02646 			;            goto _DOMERR;
                  02647 			;        if (!Zero_)
                  02648 			;            goto ARGOK;
                  02649 			;
                  02650 			;        W = 184 - arg1f24.low8;
                  02651 			;        if (!Carry)
                  02652 			;            goto _DOMERR;
                  02653 			;    }
                  02654 			;
                  02655 			;  ARGOK:
                  02656 			;
                  02657 			;    char savedFlags = FpFlags;
                  02658 			;    FpFlags |= 0x40;  //  enable rounding
                  02659 			;
                  02660 			;    c = arg1f24;  //  save x
                  02661 			;    arg1f24 *= 3.32192809489;  //  1/log10(2) = 3.32192809489
                  02662 			;    arg1f24 += 0.5;  //  k = [ x / log10(2) + .5 ]
                  02663 			;    arg1f24 = floor24( arg1f24);
                  02664 			;
                  02665 			;    float24 e = arg1f24; //  save float k
                  02666 			;    FpFlags &= ~0x40;
                  02667 			;    //floating point to integer conversion
                  02668 			;    xexp = arg1f24; //  k = [ x / ln(2) + .5 ]
                  02669 			;    FpFlags |= 0x40;
                  02670 			;    arg1f24 = e * -0.30078125; //  c1
                  02671 			;    d = arg1f24 + c;
                  02672 			;    arg1f24 = e * -2.487456637421670e-04;  // c2
                  02673 			;    arg1f24 += d;
                  02674 			;    d = arg1f24;  //  save f
                  02675 			;
                  02676 			;    if (!(d.mid8 & 0x80))  {
                  02677 			;        // POL32  EXP1032H,5,4   ; minimax approximation on [0,log10(2)/2]
                  02678 			;        arg1f24 *= 6.388992868121E-1;/* EXP1032H5 */
                  02679 			;        arg1f24 += 1.154596329197E0; /* EXP1032H4 */
                  02680 			;        arg1f24 *= d;
                  02681 			;        arg1f24 += 2.035920309947E0; /* EXP1032H3 */
                  02682 			;        arg1f24 *= d;
                  02683 			;        arg1f24 += 2.650909138708E0; /* EXP1032H2 */
                  02684 			;        arg1f24 *= d;
                  02685 			;        arg1f24 += 2.302585504840E0; /* EXP1032H1 */
                  02686 			;    }
                  02687 			;    else  {
                  02688 			;        // POL32 EXP1032L,5,4  ; minimax approximation on [-log10(2)/2,0]
                  02689 			;        arg1f24 *= 4.544952589676E-1;/* EXP1032L5 */
                  02690 			;        arg1f24 += 1.157459289066E0; /* EXP1032L4 */
                  02691 			;        arg1f24 *= d;
                  02692 			;        arg1f24 += 2.033640565225E0; /* EXP1032L3 */
                  02693 			;        arg1f24 *= d;
                  02694 			;        arg1f24 += 2.650914554552E0; /* EXP1032L2 */
                  02695 			;        arg1f24 *= d;
                  02696 			;        arg1f24 += 2.302584716116E0; /* EXP1032L1 */
                  02697 			;    }
                  02698 			;    arg1f24 *= d;
                  02699 			;    if (!(savedFlags & 0x40))
                  02700 			;        FpFlags &= ~0x40;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 46

ADDR   CODE       LINE  SOURCE

                  02701 			;    arg1f24 += 1.0; /* EXP1032H0/EXP1032L0 */
                  02702 			;
                  02703 			;    arg1f24.high8 += xexp;
                  02704 			;    goto _RETURN_MF;
                  02705 			;
                  02706 			;  EXP1:
                  02707 			;    arg1f24 = 1.0;   //  return 10**x = 1.0
                  02708 			;    goto _RETURN_MF;
                  02709 			;
                  02710 			;  _DOMERR:
                  02711 			;    FpDomainError = 1;   //  domain error
                  02712 			;
                  02713 			;  _RETURN_MF:
                  02714 			;    return arg1f24;
                  02715 			;}
                  02716 			;
                  02717 			;
                  02718 			;
                  02719 			;float24 exp( sharedM float24 arg1f24)
                  02720 			;//     Maximum argument : 88.7228391117 = log(2**128)
                  02721 			;//     Minimum argument : -87.3365447506 = log(2**-126)
                  02722 			;{
                  02723 exp
                  02724 			;    sharedM float24 arg2f24;
                  02725 			;    float24 c, d;
                  02726 			;    char xexp;
                  02727 			;
                  02728 			;    if (( arg1f24.high8 - 94) & 0x80)
                  02729 			;        goto EXP1;   //  return e**x = 1
                  02730 			;
                  02731 			;    W = 133 - arg1f24.high8;
                  02732 			;    if (!Carry)
                  02733 			;        goto _DOMERR;
                  02734 			;    if (!Zero_)
                  02735 			;        goto ARGOK;
                  02736 			;
                  02737 			;    if (!(arg1f24.mid8 & 0x80))  {
                  02738 			;
                  02739 			;        W = 49 - arg1f24.mid8;
                  02740 			;        if (!Carry)
                  02741 			;            goto _DOMERR;
                  02742 			;        if (!Zero_)
                  02743 			;            goto ARGOK;
                  02744 			;
                  02745 			;        W = 114 - arg1f24.midL8;
                  02746 			;        if (!Carry)
                  02747 			;            goto _DOMERR;
                  02748 			;    }
                  02749 			;    else {
                  02750 			;
                  02751 			;        W = 174 - arg1f24.mid8;
                  02752 			;        if (!Carry)
                  02753 			;            goto _DOMERR;
                  02754 			;        if (!Zero_)
                  02755 			;            goto ARGOK;
                  02756 			;
                  02757 			;        W = 172 - arg1f24.midL8;
                  02758 			;        if (!Carry)
                  02759 			;            goto _DOMERR;
                  02760 			;    }
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 47

ADDR   CODE       LINE  SOURCE

                  02761 			;
                  02762 			;  ARGOK:
                  02763 			;
                  02764 			;    char savedFlags = FpFlags;
                  02765 			;    FpFlags |= 0x40;  //  enable rounding
                  02766 			;
                  02767 			;    c = arg1f24;  //  save x
                  02768 			;    arg1f24 *= 1.44269504089;
                  02769 			;    arg1f24 += 0.5; //  k = [ x / ln(2) + .5 ]
                  02770 			;    arg1f24 = floor24( arg1f24);
                  02771 			;
                  02772 			;    float24 e = arg1f24;
                  02773 			;    xexp = arg1f24;   //  k = [ x / ln(2) + .5 ]
                  02774 			;    arg1f24 = e * -0.69140625; // c1
                  02775 			;    d = arg1f24 + c;
                  02776 			;    arg1f24 = e * -1.740930559945286e-03;  // c2
                  02777 			;    arg1f24 += d;
                  02778 			;    d = arg1f24;  //  save f
                  02779 			;
                  02780 			;    if (!(d.mid8 & 0x80))  {
                  02781 			;        // POL32   EXP32H,5,0
                  02782 			;        arg1f24 *= 0.989943653774E-2; /* EXP32H5 */
                  02783 			;        arg1f24 += 0.410473706887E-1; /* EXP32H4 */
                  02784 			;        arg1f24 *= d;
                  02785 			;        arg1f24 += 0.166777360103;    /* EXP32H3 */
                  02786 			;        arg1f24 *= d;
                  02787 			;        arg1f24 += 0.499991163105;    /* EXP32H2 */
                  02788 			;        arg1f24 *= d;
                  02789 			;        arg1f24 += 1.00000025499;     /* EXP32H1 */
                  02790 			;    }
                  02791 			;    else  {
                  02792 			;        // POL32   EXP32L,5,0
                  02793 			;        arg1f24 *= 0.699995870637E-2; /* EXP32L5 */
                  02794 			;        arg1f24 += 0.411548782678E-1; /* EXP32L4 */
                  02795 			;        arg1f24 *= d;
                  02796 			;        arg1f24 += 0.166574299807;    /* EXP32L3 */
                  02797 			;        arg1f24 *= d;
                  02798 			;        arg1f24 += 0.499992371926;    /* EXP32L2 */
                  02799 			;        arg1f24 *= d;
                  02800 			;        arg1f24 += 0.999999766814;    /* EXP32L1 */
                  02801 			;    }
                  02802 			;    arg1f24 *= d;
                  02803 			;    arg1f24 += 1.0;   /* EXP32H0 or EXP32L0 */
                  02804 			;    arg1f24.high8 += xexp;
                  02805 			;
                  02806 			;    if (!(savedFlags & 0x40))
                  02807 			;        FpFlags &= ~0x40;   //  restore rounding flag
                  02808 			;    goto _RETURN_MF;
                  02809 			;
                  02810 			;  EXP1:
                  02811 			;    arg1f24 = 1.0;   //  return 10**x = 1.0
                  02812 			;    goto _RETURN_MF;
                  02813 			;
                  02814 			;  _DOMERR:
                  02815 			;    FpDomainError = 1;   //  domain error
                  02816 			;
                  02817 			;  _RETURN_MF:
                  02818 			;    return arg1f24;
                  02819 			;}
                  02820 			;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 48

ADDR   CODE       LINE  SOURCE

                  02821 			;
                  02822 			;
                  02823 			;
                  02824 			;
                  02825 			;
                  02826 			;float24 cosin24( sharedM float24 arg1f24, sharedM float24 arg2f24, char cosinus)
                  02827 			;{
                  02828 cosin24
                  02829 			;    float24 c, d;
                  02830 			;    char j;
                  02831 			;
                  02832 			;    char savedFlags = FpFlags;  //  save rounding flag
                  02833 			;    FpFlags |= 0x40;  //  enable rounding
                  02834 			;
                  02835 			;    char csign = 0;    //  initialize sign
                  02836 			;
                  02837 			;    if (!cosinus  &&  (arg1f24.mid8 & 0x80))
                  02838 			;        csign |= 0x80;
                  02839 			;
                  02840 			;    arg1f24.mid8 &= ~0x80;  //  use |x|
                  02841 			;
                  02842 			;    //  loss threshold check
                  02843 			;    // arg1f24 <= +512.0
                  02844 			;    // arg1f24 >= -512.0
                  02845 			;    if (arg1f24.high8 >= 0x88)
                  02846 			;        FpDomainError = 1;   //  domain error
                  02847 			;
                  02848 			;    c = arg1f24;  //  save |x|
                  02849 			;
                  02850 			;    // fixed point multiplication by 4/pi
                  02851 			;    arg1f24 *= 1.27323954474;   // 4/pi
                  02852 			;
                  02853 			;    FpFlags &= ~0x40;
                  02854 			;
                  02855 			;    //  y = [ |x| * (4/pi) ]
                  02856 			;    arg1f24.low16 = arg1f24;  // floating point to integer conversion
                  02857 			;
                  02858 			;    FpFlags |= 0x40;
                  02859 			;
                  02860 			;    if (arg1f24.low8 & 0x1)
                  02861 			;        arg1f24.low16 += 1;  // make arg1f24 even
                  02862 			;
                  02863 			;    //  j = y mod 8
                  02864 			;    j = arg1f24.low8 & 7;  // 0,2,4,6
                  02865 			;    if (j >= 4)  {
                  02866 			;        csign ^= 128;
                  02867 			;        j -= 4;
                  02868 			;    }
                  02869 			;
                  02870 			;    arg1f24 = arg1f24.low16;  // integer to floating point conversion
                  02871 			;
                  02872 			;    //  save y in DARG
                  02873 			;    W = arg1f24.high8;
                  02874 			;    d.high8 = W;
                  02875 			;   #if __CoreSet__ / 100 == 17
                  02876 			;    if (W == 0)  // NB17
                  02877 			;        goto ZEQX;
                  02878 			;   #else
                  02879 			;    if (Zero_)
                  02880 			;        goto ZEQX;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 49

ADDR   CODE       LINE  SOURCE

                  02881 			;   #endif
                  02882 			;    d.low16 = arg1f24.low16;
                  02883 			;
                  02884 			;    arg1f24 *= -7.851562500000000e-01;
                  02885 			;    c = arg1f24 + c;    //  z1 = |x| - y * (p1)
                  02886 			;    arg1f24 = d * -2.419133974475018e-04;
                  02887 			;    arg1f24 += c;
                  02888 			;
                  02889 			;    //  save z in c
                  02890 			;    W = arg1f24.high8;  c.high8 = W;  arg2f24.high8 = W;
                  02891 			;    W = arg1f24.mid8;   c.mid8 = W;   arg2f24.mid8 = W;
                  02892 			;    W = arg1f24.low8;   c.low8 = W;   arg2f24.low8 = W;
                  02893 			;
                  02894 			;    goto POLYNOM;
                  02895 			;
                  02896 			;   ZEQX:
                  02897 			;    W = c.high8;  arg1f24.high8 = W;  arg2f24.high8 = W;
                  02898 			;    W = c.mid8;   arg1f24.mid8 = W;   arg2f24.mid8 = W;
                  02899 			;    W = c.low8;   arg1f24.low8 = W;   arg2f24.low8 = W;
                  02900 			;
                  02901 			;   POLYNOM:
                  02902 			;
                  02903 			;    arg1f24 *= arg2f24;   // z * z
                  02904 			;    d = arg1f24;   //  save z * z
                  02905 			;
                  02906 			;    if ((( rr( j) ^ j) & 0x1) ^ cosinus)  {
                  02907 			;        // POL24  COS24,3,0
                  02908 			;
                  02909 			;        arg1f24 *= -1.35859090e-03;  // 117,178,18,191
                  02910 			;        arg1f24 += 4.16550264e-02;   // 122,42,158,118
                  02911 			;        arg1f24 *= d;
                  02912 			;        arg1f24 += -4.99998569e-01;  // 125,255,255,208
                  02913 			;        arg1f24 *= d;
                  02914 			;        arg1f24 += 1.0;
                  02915 			;    }
                  02916 			;    else  {
                  02917 			;        /// POL24  SIN24,2,0
                  02918 			;        arg1f24 *= 8.12155753e-03;   // 120,5,16,72
                  02919 			;        arg1f24 += -1.66601613e-01;  // 124,170,153,157
                  02920 			;        arg1f24 *= d;
                  02921 			;        arg1f24 += 9.99994993e-01;   // 126,127,255,172
                  02922 			;        arg1f24 *= c;
                  02923 			;    }
                  02924 			;
                  02925 			;    W = 128;  // LSB+1
                  02926 			;    if (cosinus  &&  (j & 0x2))   // NB17
                  02927 			;        csign ^= W;
                  02928 			;    if (csign & 0x80)
                  02929 			;        arg1f24.mid8 ^= W;
                  02930 			;
                  02931 			;    if (savedFlags & 0x40)
                  02932 			;        FpFlags |= 0x40;  //  restore rounding flag
                  02933 			;    return arg1f24;
                  02934 			;}
                  02935 			;
                  02936 			;
                  02937 			;float24 cos( sharedM float24 arg1f24)
                  02938 			;{
                  02939 cos
                  02940 			;    sharedM float24 arg2f24;      // allocation 'trick'
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 50

ADDR   CODE       LINE  SOURCE

                  02941 			;    arg1f24 = cosin24( arg1f24, arg2f24, 1);
                  02942 			;    return arg1f24;
                  02943 			;}
                  02944 			;
                  02945 			;
                  02946 			;float24 sin( sharedM float24 arg1f24)
                  02947 			;{
                  02948 sin
                  02949 			;    sharedM float24 arg2f24;      // allocation 'trick'
                  02950 			;    arg1f24 = cosin24( arg1f24, arg2f24, 0);
                  02951 			;    return arg1f24;
                  02952 			;}
                  02953 			;
                  02954 			;
                  02955 			;
                  02956 			;#if !defined __CC8EFREE__
                  02957 			;
                  02958 			;float24 sqrt( float24 arg)
                  02959 			;// Copyright (c) Jim van Zee, Seattle, WA., 2004
                  02960 			;{
                  02961 			;    uns8 arg_exp @ arg.high8;    // arg exponent (offset by FpBIAS)
                  02962 			;    uns24 root = 0;              // result (treated as an integer)
                  02963 			;    float24 sqrtf @ root;        // result (treated as a float)
                  02964 			;    uns24 remain;
                  02965 			;    uns8 nr_bits;
                  02966 			;
                  02967 			;    if (arg.mid8 & 0x80) {  // test for negative argument
                  02968 			;        FpDomainError=1;
                  02969 			;        goto END;           // negative #s return '0'
                  02970 			;    }
                  02971 			;    if (!arg_exp)
                  02972 			;        goto END;           // 0->0 (all bytes are 0)
                  02973 			;
                  02974 			;    arg.15 = 1;             // restore hidden bit
                  02975 			;    remain = 0;             // clear remainder
                  02976 			;    nr_bits = 16;           // initialize bit count
                  02977 			;
                  02978 			;    // Here's a 'tricky bit': 'even' exponents work out OK, but 'odd'
                  02979 			;    // exponents need one less shift initially in order to align the
                  02980 			;    // bits in a 'powers-of-four' pattern (two-bits-at-a-time).
                  02981 			;
                  02982 			;    btss(arg_exp.0);          // skip if exponent is odd
                  02983 			;    do {
                  02984 			;        remain.23=1;          // set 2x shift flag
                  02985 			;        root = rl(root);        // exponent= 'spill byte'
                  02986 			;        root.0=1;               // add '1' to form '2N+1'
                  02987 			;        root.1=0;               // clear next root bit
                  02988 			;        do {
                  02989 			;            arg.low16 = rl(arg.low16); // shift mantissa into 'remain'
                  02990 			;            remain = rl(remain);       // two-bits-at-a-time (add 0's)
                  02991 			;        } while(Carry);         // Carry=1 the first time
                  02992 			;        arg.0=0;                // clear the carry-in bit
                  02993 			;
                  02994 			;        // now compare root and remainder; if remain >= root, subtract
                  02995 			;        // to get the new remainder & set bit=1; otherwise leave bit=0.
                  02996 			;
                  02997 			;        //        if (remain >= root) // 3-byte compare
                  02998 			;        //        {   remain -= root; // update remainder
                  02999 			;        //            root.1 = 1;   } // set this bit = 1
                  03000 			;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 51

ADDR   CODE       LINE  SOURCE

                  03001 			;        W = remain.low8 - root.low8;  // compare remain w/root
                  03002 			;        genSubW( remain.mid8, root.mid8);
                  03003 			;        genSubW( remain.high8, root.high8);
                  03004 			;
                  03005 			;        // If remain >= root, the next bit is '1', otherwise '0'
                  03006 			;        if (Carry) {          // remain -= root;
                  03007 			;            remain.high8 = W;   // save 'spill byte'
                  03008 			;            remain.low8 -= root.low8;   // do subtraction
                  03009 			;            genSub( remain.mid8, root.mid8);
                  03010 			;            root.1 = 1; // note: lsb is bit1, not bit0!
                  03011 			;        }
                  03012 			;
                  03013 			;    } while (--nr_bits); // 16 bit mantissa
                  03014 			;
                  03015 			;    // Finally unshift root (only need to do 16 bits, since msb->0!)
                  03016 			;    root.low16 = rr(root.low16);       // '2N+1' -> 'N'
                  03017 			;    root.15 = 0;            // clear hidden bit
                  03018 			;
                  03019 			;    // and set exponent = arg_exp/2 (we used this as the spill byte)
                  03020 			;    arg_exp += FpBIAS;      // double the bias
                  03021 			;    root.high8=rr(arg_exp); // root exp = arg_exp/2+FpBIAS
                  03022 			;  END:
                  03023 			;    return sqrtf;           // neg & zero args return 0
                  03024 			;}
                  03025 			;
                  03026 			;#else
                  03027 			;
                  03028 			;float24 sqrt( sharedM float24 arg1f24)
                  03029 			;{
                  03030 sqrt
                  03031 			;    sharedM float24 arg2f24;      // allocation 'trick'
                  03032 			;
                  03033 			;    if (arg1f24.mid8 & 0x80)     // test for negative argument
000648 0100       03034 	MOVLB 0
00064A BFA5       03035 	BTFSC arg1f24+1,7,1
                  03036 			;        goto _DOMERR;
00064C D0A1       03037 	BRA   m084
                  03038 			;    if (!arg1f24.high8)          // return if argument zero
00064E 0100       03039 	MOVLB 0
000650 53A6       03040 	MOVF  arg1f24+2,1,1
000652 B4D8       03041 	BTFSC 0xFD8,Zero_,0
                  03042 			;        goto _RETURN_MF;
000654 D09F       03043 	BRA   m085
                  03044 			;
                  03045 			;    char cexp = arg1f24.high8;    // save exponent
000656 C0A6 F0AA  03046 	MOVFF arg1f24+2,cexp
                  03047 			;    char savedFLAGS = FpFlags;
00065A C0CC F0AB  03048 	MOVFF FpFlags,savedFLAGS
                  03049 			;    FpFlags |= 0x40;           // enable rounding
00065E 0100       03050 	MOVLB 0
000660 8DCC       03051 	BSF   FpFlags,6,1
                  03052 			;
                  03053 			;    arg1f24.high8 = FpBIAS;   // compute z
000662 0E7F       03054 	MOVLW 127
000664 6FA6       03055 	MOVWF arg1f24+2,1
                  03056 			;    float24 d = arg1f24;
000666 C0A4 F0AC  03057 	MOVFF arg1f24,d_5
00066A C0A5 F0AD  03058 	MOVFF arg1f24+1,d_5+1
00066E C0A6 F0AE  03059 	MOVFF arg1f24+2,d_5+2
                  03060 			;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 52

ADDR   CODE       LINE  SOURCE

                  03061 			;    if (arg1f24.mid8 & 0x40)  {
000672 ADA5       03062 	BTFSS arg1f24+1,6,1
000674 D03D       03063 	BRA   m081
                  03064 			;        // POL24  SQRT24H,4,0
                  03065 			;        arg1f24 *= -5.6351436252E-3;  // SQRT24H4
000676 0EA7       03066 	MOVLW 167
000678 6FA7       03067 	MOVWF arg2f24,1
00067A 0EB8       03068 	MOVLW 184
00067C 6FA8       03069 	MOVWF arg2f24+1,1
00067E 0E77       03070 	MOVLW 119
000680 6FA9       03071 	MOVWF arg2f24+2,1
000682 DD59       03072 	RCALL _fmul24
                  03073 			;        arg1f24 += 5.5047377031E-2; // SQRT24H3
000684 0E79       03074 	MOVLW 121
000686 0100       03075 	MOVLB 0
000688 6FA7       03076 	MOVWF arg2f24,1
00068A 0E61       03077 	MOVLW 97
00068C 6FA8       03078 	MOVWF arg2f24+1,1
00068E 0E7A       03079 	MOVLW 122
000690 6FA9       03080 	MOVWF arg2f24+2,1
000692 DE2F       03081 	RCALL _fadd24
                  03082 			;        arg1f24 *= d;
000694 C0AC F0A7  03083 	MOVFF d_5,arg2f24
000698 C0AD F0A8  03084 	MOVFF d_5+1,arg2f24+1
00069C C0AE F0A9  03085 	MOVFF d_5+2,arg2f24+2
0006A0 DD4A       03086 	RCALL _fmul24
                  03087 			;        arg1f24 += -2.3944355047E-1;  // SQRT24H2
0006A2 0E31       03088 	MOVLW 49
0006A4 0100       03089 	MOVLB 0
0006A6 6FA7       03090 	MOVWF arg2f24,1
0006A8 0EF5       03091 	MOVLW 245
0006AA 6FA8       03092 	MOVWF arg2f24+1,1
0006AC 0E7C       03093 	MOVLW 124
0006AE 6FA9       03094 	MOVWF arg2f24+2,1
0006B0 DE20       03095 	RCALL _fadd24
                  03096 			;        arg1f24 *= d;
0006B2 C0AC F0A7  03097 	MOVFF d_5,arg2f24
0006B6 C0AD F0A8  03098 	MOVFF d_5+1,arg2f24+1
0006BA C0AE F0A9  03099 	MOVFF d_5+2,arg2f24+2
0006BE DD3B       03100 	RCALL _fmul24
                  03101 			;        arg1f24 += 8.3106978456E-1; // SQRT24H1
0006C0 0EC1       03102 	MOVLW 193
0006C2 0100       03103 	MOVLB 0
0006C4 6FA7       03104 	MOVWF arg2f24,1
0006C6 0E54       03105 	MOVLW 84
0006C8 6FA8       03106 	MOVWF arg2f24+1,1
0006CA 0E7E       03107 	MOVLW 126
0006CC 6FA9       03108 	MOVWF arg2f24+2,1
0006CE DE11       03109 	RCALL _fadd24
                  03110 			;        arg1f24 *= d;
0006D0 C0AC F0A7  03111 	MOVFF d_5,arg2f24
0006D4 C0AD F0A8  03112 	MOVFF d_5+1,arg2f24+1
0006D8 C0AE F0A9  03113 	MOVFF d_5+2,arg2f24+2
0006DC DD2C       03114 	RCALL _fmul24
                  03115 			;        arg1f24 += 3.5963132863E-1;  // SQRT24H0
0006DE 0E22       03116 	MOVLW 34
0006E0 0100       03117 	MOVLB 0
0006E2 6FA7       03118 	MOVWF arg2f24,1
0006E4 0E38       03119 	MOVLW 56
0006E6 6FA8       03120 	MOVWF arg2f24+1,1
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 53

ADDR   CODE       LINE  SOURCE

0006E8 0E7D       03121 	MOVLW 125
0006EA 6FA9       03122 	MOVWF arg2f24+2,1
0006EC DE02       03123 	RCALL _fadd24
                  03124 			;    }
                  03125 			;    else  {
0006EE D03D       03126 	BRA   m082
                  03127 			;        // POL24  SQRT24L,4,0
                  03128 			;        arg1f24 *= -1.8702682470E-2;  // SQRT24L4
0006F0 0E36       03129 m081	MOVLW 54
0006F2 0100       03130 	MOVLB 0
0006F4 6FA7       03131 	MOVWF arg2f24,1
0006F6 0E99       03132 	MOVLW 153
0006F8 6FA8       03133 	MOVWF arg2f24+1,1
0006FA 0E79       03134 	MOVLW 121
0006FC 6FA9       03135 	MOVWF arg2f24+2,1
0006FE DD1B       03136 	RCALL _fmul24
                  03137 			;        arg1f24 += 1.3009144111E-1; // SQRT24L3
000700 0E37       03138 	MOVLW 55
000702 0100       03139 	MOVLB 0
000704 6FA7       03140 	MOVWF arg2f24,1
000706 0E05       03141 	MOVLW 5
000708 6FA8       03142 	MOVWF arg2f24+1,1
00070A 0E7C       03143 	MOVLW 124
00070C 6FA9       03144 	MOVWF arg2f24+2,1
00070E DDF1       03145 	RCALL _fadd24
                  03146 			;        arg1f24 *= d;
000710 C0AC F0A7  03147 	MOVFF d_5,arg2f24
000714 C0AD F0A8  03148 	MOVFF d_5+1,arg2f24+1
000718 C0AE F0A9  03149 	MOVFF d_5+2,arg2f24+2
00071C DD0C       03150 	RCALL _fmul24
                  03151 			;        arg1f24 += -4.0192034196E-1;  // SQRT24L2
00071E 0EC9       03152 	MOVLW 201
000720 0100       03153 	MOVLB 0
000722 6FA7       03154 	MOVWF arg2f24,1
000724 0ECD       03155 	MOVLW 205
000726 6FA8       03156 	MOVWF arg2f24+1,1
000728 0E7D       03157 	MOVLW 125
00072A 6FA9       03158 	MOVWF arg2f24+2,1
00072C DDE2       03159 	RCALL _fadd24
                  03160 			;        arg1f24 *= d;
00072E C0AC F0A7  03161 	MOVFF d_5,arg2f24
000732 C0AD F0A8  03162 	MOVFF d_5+1,arg2f24+1
000736 C0AE F0A9  03163 	MOVFF d_5+2,arg2f24+2
00073A DCFD       03164 	RCALL _fmul24
                  03165 			;        arg1f24 += 9.8831235597E-1;  // SQRT24L1
00073C 0E02       03166 	MOVLW 2
00073E 0100       03167 	MOVLB 0
000740 6FA7       03168 	MOVWF arg2f24,1
000742 0E7D       03169 	MOVLW 125
000744 6FA8       03170 	MOVWF arg2f24+1,1
000746 0E7E       03171 	MOVLW 126
000748 6FA9       03172 	MOVWF arg2f24+2,1
00074A DDD3       03173 	RCALL _fadd24
                  03174 			;        arg1f24 *= d;
00074C C0AC F0A7  03175 	MOVFF d_5,arg2f24
000750 C0AD F0A8  03176 	MOVFF d_5+1,arg2f24+1
000754 C0AE F0A9  03177 	MOVFF d_5+2,arg2f24+2
000758 DCEE       03178 	RCALL _fmul24
                  03179 			;        arg1f24 += 3.0221977303E-1;  // SQRT24L0
00075A 0EBD       03180 	MOVLW 189
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 54

ADDR   CODE       LINE  SOURCE

00075C 0100       03181 	MOVLB 0
00075E 6FA7       03182 	MOVWF arg2f24,1
000760 0E1A       03183 	MOVLW 26
000762 6FA8       03184 	MOVWF arg2f24+1,1
000764 0E7D       03185 	MOVLW 125
000766 6FA9       03186 	MOVWF arg2f24+2,1
000768 DDC4       03187 	RCALL _fadd24
                  03188 			;    }
                  03189 			;
                  03190 			;    if (!(cexp & 0x1))      // is cexp even or odd?
00076A 0100       03191 m082	MOVLB 0
00076C B1AA       03192 	BTFSC cexp,0,1
00076E D007       03193 	BRA   m083
                  03194 			;        arg1f24 *= 1.41421356237;  // sqrt(2)
000770 0E05       03195 	MOVLW 5
000772 6FA7       03196 	MOVWF arg2f24,1
000774 0E35       03197 	MOVLW 53
000776 6FA8       03198 	MOVWF arg2f24+1,1
000778 0E7F       03199 	MOVLW 127
00077A 6FA9       03200 	MOVWF arg2f24+2,1
00077C DCDC       03201 	RCALL _fmul24
                  03202 			;
                  03203 			;    // divide exponent by two
                  03204 			;    cexp += 127;
00077E 0E7F       03205 m083	MOVLW 127
000780 0100       03206 	MOVLB 0
000782 27AA       03207 	ADDWF cexp,1,1
                  03208 			;    arg1f24.high8 = rr( cexp);
000784 31AA       03209 	RRCF  cexp,W,1
000786 6FA6       03210 	MOVWF arg1f24+2,1
                  03211 			;
                  03212 			;    if (!(savedFLAGS & 0x40))
000788 BDAB       03213 	BTFSC savedFLAGS,6,1
00078A D004       03214 	BRA   m085
                  03215 			;        FpFlags &= ~0x40;
00078C 9DCC       03216 	BCF   FpFlags,6,1
                  03217 			;
                  03218 			;    goto _RETURN_MF;
00078E D002       03219 	BRA   m085
                  03220 			;
                  03221 			;  _DOMERR:
                  03222 			;    FpDomainError = 1;   //  domain error
000790 0100       03223 m084	MOVLB 0
000792 8BCC       03224 	BSF   0xCC,FpDomainError,1
                  03225 			;
                  03226 			;  _RETURN_MF:
                  03227 			;    return arg1f24;
000794 0100       03228 m085	MOVLB 0
000796 51A4       03229 	MOVF  arg1f24,W,1
000798 0012       03230 	RETURN
                  03231 
                  03232   ; FILE Temporiz_64Mhz.h
                  03233 			;void retardo_20u(void){
                  03234 retardo_20u
                  03235 			;	
                  03236 			;		char PDel0;
                  03237 			;		#asm
                  03238 			;		;-------------------------------------------------------------
                  03239 			;		DEMORA  movlw     .78       ; 1 set numero de repeticion 
00079A 0E4E       03240 	MOVLW 78
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 55

ADDR   CODE       LINE  SOURCE

                  03241 			;		        movwf     PDel0     ; 1 |
00079C 6FB9       03242 	MOVWF PDel0,1
                  03243 			;		PLoop0  clrwdt              ; 1 clear watchdog
00079E 0004       03244 m086	CLRWDT
                  03245 			;		        decfsz    PDel0, 1  ; 1 + (1) es el tiempo 0  ?
0007A0 2FB9       03246 	DECFSZ PDel0,1,1
                  03247 			;		        goto      PLoop0    ; 2 no, loop
0007A2 EFCF F003  03248 	GOTO  m086
                  03249 			;		PDelL1  goto PDelL2         ; 2 ciclos delay
0007A6 EFD5 F003  03250 	GOTO  m087
                  03251 			;		PDelL2  clrwdt              ; 1 ciclo delay
0007AA 0004       03252 m087	CLRWDT
                  03253 			;		        return              ; 2+2 Fin.
0007AC 0012       03254 	RETURN
                  03255 			;		;-------------------------------------------------------------
                  03256 			;		#endasm
                  03257 			;	
                  03258 			;}
                  03259 			;void retardo_1m(void){
                  03260 retardo_1m
                  03261 			;	char PDel0,PDel1;
                  03262 			;	#asm
                  03263 			;	;-------------------------------------------------------------
                  03264 			;	DEMORA  movlw     .15       ; 1 set numero de repeticion  (B)
0007AE 0E0F       03265 	MOVLW 15
                  03266 			;	        movwf     PDel0     ; 1 |
0007B0 6FB9       03267 	MOVWF PDel0_2,1
                  03268 			;	PLoop1  movlw     .177      ; 1 set numero de repeticion  (A)
0007B2 0EB1       03269 m088	MOVLW 177
                  03270 			;	        movwf     PDel1     ; 1 |
0007B4 6FBA       03271 	MOVWF PDel1,1
                  03272 			;	PLoop2  clrwdt              ; 1 clear watchdog
0007B6 0004       03273 m089	CLRWDT
                  03274 			;	PDelL1  goto PDelL2         ; 2 ciclos delay
0007B8 EFDE F003  03275 	GOTO  m090
                  03276 			;	PDelL2  
                  03277 			;	        decfsz    PDel1, 1  ; 1 + (1) es el tiempo 0  ? (A)
0007BC 2FBA       03278 m090	DECFSZ PDel1,1,1
                  03279 			;	        goto      PLoop2    ; 2 no, loop
0007BE EFDB F003  03280 	GOTO  m089
                  03281 			;	        decfsz    PDel0,  1 ; 1 + (1) es el tiempo 0  ? (B)
0007C2 2FB9       03282 	DECFSZ PDel0_2,1,1
                  03283 			;	        goto      PLoop1    ; 2 no, loop
0007C4 EFD9 F003  03284 	GOTO  m088
                  03285 			;	PDelL3  goto PDelL4         ; 2 ciclos delay
0007C8 EFE6 F003  03286 	GOTO  m091
                  03287 			;	PDelL4  goto PDelL5         ; 2 ciclos delay
0007CC EFE8 F003  03288 m091	GOTO  m092
                  03289 			;	PDelL5  clrwdt              ; 1 ciclo delay
0007D0 0004       03290 m092	CLRWDT
                  03291 			;	        return              ; 2+2 Fin.
0007D2 0012       03292 	RETURN
                  03293 			;	;-------------------------------------------------------------
                  03294 			;	#endasm
                  03295 			;}
                  03296 			;void retardo_50m(void){
                  03297 retardo_50m
                  03298 			;	char PDel0,PDel1,PDel2;
                  03299 			;	#asm
                  03300 			;	;-------------------------------------------------------------
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 56

ADDR   CODE       LINE  SOURCE

                  03301 			;	DEMORA  movlw     .18       ; 1 set numero de repeticion  (C)
0007D4 0E12       03302 	MOVLW 18
                  03303 			;	        movwf     PDel0     ; 1 |
0007D6 6E7F       03304 	MOVWF PDel0_3,0
                  03305 			;	PLoop0  movlw     .55       ; 1 set numero de repeticion  (B)
0007D8 0E37       03306 m093	MOVLW 55
                  03307 			;	        movwf     PDel1     ; 1 |
0007DA 6E7F       03308 	MOVWF PDel1_2,0
                  03309 			;	PLoop1  movlw     .201      ; 1 set numero de repeticion  (A)
0007DC 0EC9       03310 m094	MOVLW 201
                  03311 			;	        movwf     PDel2     ; 1 |
0007DE 6E7F       03312 	MOVWF PDel2,0
                  03313 			;	PLoop2  clrwdt              ; 1 clear watchdog
0007E0 0004       03314 m095	CLRWDT
                  03315 			;	        decfsz    PDel2, 1  ; 1 + (1) es el tiempo 0  ? (A)
0007E2 2E7F       03316 	DECFSZ PDel2,1,0
                  03317 			;	        goto      PLoop2    ; 2 no, loop
0007E4 EFF0 F003  03318 	GOTO  m095
                  03319 			;	        decfsz    PDel1,  1 ; 1 + (1) es el tiempo 0  ? (B)
0007E8 2E7F       03320 	DECFSZ PDel1_2,1,0
                  03321 			;	        goto      PLoop1    ; 2 no, loop
0007EA EFEE F003  03322 	GOTO  m094
                  03323 			;	        decfsz    PDel0,  1 ; 1 + (1) es el tiempo 0  ? (C)
0007EE 2E7F       03324 	DECFSZ PDel0_3,1,0
                  03325 			;	        goto      PLoop0    ; 2 no, loop
0007F0 EFEC F003  03326 	GOTO  m093
                  03327 			;	PDelL1  goto PDelL2         ; 2 ciclos delay
0007F4 EFFC F003  03328 	GOTO  m096
                  03329 			;	PDelL2  clrwdt              ; 1 ciclo delay
0007F8 0004       03330 m096	CLRWDT
                  03331 			;	        return              ; 2+2 Fin.
0007FA 0012       03332 	RETURN
                  03333 			;	;-------------------------------------------------------------
                  03334 			;	#endasm
                  03335 			;}
                  03336 			;void retardo_100m(void){
                  03337 retardo_100m
                  03338 			;	char PDel0,PDel1,PDel2;
                  03339 			;	#asm
                  03340 			;	;-------------------------------------------------------------
                  03341 			;	DEMORA  movlw     .23       ; 1 set numero de repeticion  (C)
0007FC 0E17       03342 	MOVLW 23
                  03343 			;	        movwf     PDel0     ; 1 |
0007FE 6E7F       03344 	MOVWF PDel0_4,0
                  03345 			;	PLoop0  movlw     .59       ; 1 set numero de repeticion  (B)
000800 0E3B       03346 m097	MOVLW 59
                  03347 			;	        movwf     PDel1     ; 1 |
000802 6E7F       03348 	MOVWF PDel1_3,0
                  03349 			;	PLoop1  movlw     .235      ; 1 set numero de repeticion  (A)
000804 0EEB       03350 m098	MOVLW 235
                  03351 			;	        movwf     PDel2     ; 1 |
000806 6E7F       03352 	MOVWF PDel2_2,0
                  03353 			;	PLoop2  clrwdt              ; 1 clear watchdog
000808 0004       03354 m099	CLRWDT
                  03355 			;	        clrwdt              ; 1 ciclo delay
00080A 0004       03356 	CLRWDT
                  03357 			;	        decfsz    PDel2, 1  ; 1 + (1) es el tiempo 0  ? (A)
00080C 2E7F       03358 	DECFSZ PDel2_2,1,0
                  03359 			;	        goto      PLoop2    ; 2 no, loop
00080E EF04 F004  03360 	GOTO  m099
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 57

ADDR   CODE       LINE  SOURCE

                  03361 			;	        decfsz    PDel1,  1 ; 1 + (1) es el tiempo 0  ? (B)
000812 2E7F       03362 	DECFSZ PDel1_3,1,0
                  03363 			;	        goto      PLoop1    ; 2 no, loop
000814 EF02 F004  03364 	GOTO  m098
                  03365 			;	        decfsz    PDel0,  1 ; 1 + (1) es el tiempo 0  ? (C)
000818 2E7F       03366 	DECFSZ PDel0_4,1,0
                  03367 			;	        goto      PLoop0    ; 2 no, loop
00081A EF00 F004  03368 	GOTO  m097
                  03369 			;	        return              ; 2+2 Fin.
00081E 0012       03370 	RETURN
                  03371 			;	;-------------------------------------------------------------
                  03372 			;	#endasm
                  03373 			;}
                  03374 			;void retardo_500m(void){
                  03375 retardo_500m
                  03376 			;	char PDel0,PDel1,PDel2;
                  03377 			;	#asm
                  03378 			;	;-------------------------------------------------------------
                  03379 			;	DEMORA  movlw     .54       ; 1 set numero de repeticion  (C)
000820 0E36       03380 	MOVLW 54
                  03381 			;	        movwf     PDel0     ; 1 |
000822 6E7F       03382 	MOVWF PDel0_5,0
                  03383 			;	PLoop0  movlw     .188      ; 1 set numero de repeticion  (B)
000824 0EBC       03384 m100	MOVLW 188
                  03385 			;	        movwf     PDel1     ; 1 |
000826 6E7F       03386 	MOVWF PDel1_4,0
                  03387 			;	PLoop1  movlw     .196      ; 1 set numero de repeticion  (A)
000828 0EC4       03388 m101	MOVLW 196
                  03389 			;	        movwf     PDel2     ; 1 |
00082A 6E7F       03390 	MOVWF PDel2_3,0
                  03391 			;	PLoop2  clrwdt              ; 1 clear watchdog
00082C 0004       03392 m102	CLRWDT
                  03393 			;	        decfsz    PDel2, 1  ; 1 + (1) es el tiempo 0  ? (A)
00082E 2E7F       03394 	DECFSZ PDel2_3,1,0
                  03395 			;	        goto      PLoop2    ; 2 no, loop
000830 EF16 F004  03396 	GOTO  m102
                  03397 			;	        decfsz    PDel1,  1 ; 1 + (1) es el tiempo 0  ? (B)
000834 2E7F       03398 	DECFSZ PDel1_4,1,0
                  03399 			;	        goto      PLoop1    ; 2 no, loop
000836 EF14 F004  03400 	GOTO  m101
                  03401 			;	        decfsz    PDel0,  1 ; 1 + (1) es el tiempo 0  ? (C)
00083A 2E7F       03402 	DECFSZ PDel0_5,1,0
                  03403 			;	        goto      PLoop0    ; 2 no, loop
00083C EF12 F004  03404 	GOTO  m100
                  03405 			;	PDelL1  goto PDelL2         ; 2 ciclos delay
000840 EF22 F004  03406 	GOTO  m103
                  03407 			;	PDelL2  clrwdt              ; 1 ciclo delay
000844 0004       03408 m103	CLRWDT
                  03409 			;	        return              ; 2+2 Fin.
000846 0012       03410 	RETURN
                  03411 			;	;-------------------------------------------------------------
                  03412 			;	#endasm
                  03413 
                  03414   ; FILE LCD_4bit.h
                  03415 			;
                  03416 			;/*
                  03417 			;	ESTA LIBRERIA NO SIRVE PARA LA PLACA DE PROTOTIPOS 
                  03418 			;	ES SOLO PARA LA PLACA DEL ONDULADOR!!!!!
                  03419 			;*/
                  03420 			;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 58

ADDR   CODE       LINE  SOURCE

                  03421 			;void envia_codigo_inicial (char codigo)
                  03422 			;{
                  03423 envia_codigo_inicial
000848 0100       03424 	MOVLB 0
00084A 6F9E       03425 	MOVWF codigo,1
                  03426 			;	PORTB.5=0;nop();
00084C 9A81       03427 	BCF   PORTB,5,0
00084E 0000       03428 	NOP  
                  03429 			;	PORTB.3 = codigo.4;
000850 A99E       03430 	BTFSS codigo,4,1
000852 9681       03431 	BCF   PORTB,3,0
000854 B99E       03432 	BTFSC codigo,4,1
000856 8681       03433 	BSF   PORTB,3,0
                  03434 			;	nop();
000858 0000       03435 	NOP  
                  03436 			;	PORTB.2 = codigo.5;
00085A AB9E       03437 	BTFSS codigo,5,1
00085C 9481       03438 	BCF   PORTB,2,0
00085E BB9E       03439 	BTFSC codigo,5,1
000860 8481       03440 	BSF   PORTB,2,0
                  03441 			;	nop();
000862 0000       03442 	NOP  
                  03443 			;	PORTB.1 = codigo.6;
000864 AD9E       03444 	BTFSS codigo,6,1
000866 9281       03445 	BCF   PORTB,1,0
000868 BD9E       03446 	BTFSC codigo,6,1
00086A 8281       03447 	BSF   PORTB,1,0
                  03448 			;	nop();
00086C 0000       03449 	NOP  
                  03450 			;	PORTB.0 = codigo.7;
00086E AF9E       03451 	BTFSS codigo,7,1
000870 9081       03452 	BCF   PORTB,0,0
000872 BF9E       03453 	BTFSC codigo,7,1
000874 8081       03454 	BSF   PORTB,0,0
                  03455 			;	nop();
000876 0000       03456 	NOP  
                  03457 			;	PORTB.4 = 1; 
000878 8881       03458 	BSF   PORTB,4,0
                  03459 			;	retardo_20u();
00087A DF8F       03460 	RCALL retardo_20u
                  03461 			;	PORTB.4 = 0; 
00087C 9881       03462 	BCF   PORTB,4,0
                  03463 			;
                  03464 			;	return;
00087E 0012       03465 	RETURN
                  03466 			;}
                  03467 			; 
                  03468 			;void enviar_comando (char comando) 
                  03469 			;{
                  03470 enviar_comando
000880 0100       03471 	MOVLB 0
000882 6FB8       03472 	MOVWF comando,1
                  03473 			;	
                  03474 			;	PORTB.3 =  comando.4;nop();
000884 A9B8       03475 	BTFSS comando,4,1
000886 9681       03476 	BCF   PORTB,3,0
000888 B9B8       03477 	BTFSC comando,4,1
00088A 8681       03478 	BSF   PORTB,3,0
00088C 0000       03479 	NOP  
                  03480 			;	PORTB.2 =  comando.5;nop();
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 59

ADDR   CODE       LINE  SOURCE

00088E ABB8       03481 	BTFSS comando,5,1
000890 9481       03482 	BCF   PORTB,2,0
000892 BBB8       03483 	BTFSC comando,5,1
000894 8481       03484 	BSF   PORTB,2,0
000896 0000       03485 	NOP  
                  03486 			;	PORTB.1 =  comando.6;nop();
000898 ADB8       03487 	BTFSS comando,6,1
00089A 9281       03488 	BCF   PORTB,1,0
00089C BDB8       03489 	BTFSC comando,6,1
00089E 8281       03490 	BSF   PORTB,1,0
0008A0 0000       03491 	NOP  
                  03492 			;	PORTB.0 =  comando.7;
0008A2 AFB8       03493 	BTFSS comando,7,1
0008A4 9081       03494 	BCF   PORTB,0,0
0008A6 BFB8       03495 	BTFSC comando,7,1
0008A8 8081       03496 	BSF   PORTB,0,0
                  03497 			;	retardo_1m ();
0008AA DF81       03498 	RCALL retardo_1m
                  03499 			;	PORTB.5 = 0;  									// Modo comando.
0008AC 9A81       03500 	BCF   PORTB,5,0
                  03501 			;	retardo_20u (); //
0008AE DF75       03502 	RCALL retardo_20u
                  03503 			;	PORTB.4 = 1;  									// Breve pulso.
0008B0 8881       03504 	BSF   PORTB,4,0
                  03505 			;	retardo_20u ();
0008B2 DF73       03506 	RCALL retardo_20u
                  03507 			;	PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
0008B4 9881       03508 	BCF   PORTB,4,0
                  03509 			;	retardo_1m ();
0008B6 DF7B       03510 	RCALL retardo_1m
                  03511 			;	retardo_1m ();
0008B8 DF7A       03512 	RCALL retardo_1m
                  03513 			;	comando = swap (comando);
0008BA 0100       03514 	MOVLB 0
0008BC 3BB8       03515 	SWAPF comando,1,1
                  03516 			;	PORTB.3 =  comando.4;nop();
0008BE A9B8       03517 	BTFSS comando,4,1
0008C0 9681       03518 	BCF   PORTB,3,0
0008C2 B9B8       03519 	BTFSC comando,4,1
0008C4 8681       03520 	BSF   PORTB,3,0
0008C6 0000       03521 	NOP  
                  03522 			;	PORTB.2 =  comando.5;nop();
0008C8 ABB8       03523 	BTFSS comando,5,1
0008CA 9481       03524 	BCF   PORTB,2,0
0008CC BBB8       03525 	BTFSC comando,5,1
0008CE 8481       03526 	BSF   PORTB,2,0
0008D0 0000       03527 	NOP  
                  03528 			;	PORTB.1 =  comando.6;nop();
0008D2 ADB8       03529 	BTFSS comando,6,1
0008D4 9281       03530 	BCF   PORTB,1,0
0008D6 BDB8       03531 	BTFSC comando,6,1
0008D8 8281       03532 	BSF   PORTB,1,0
0008DA 0000       03533 	NOP  
                  03534 			;	PORTB.0 =  comando.7;nop();
0008DC AFB8       03535 	BTFSS comando,7,1
0008DE 9081       03536 	BCF   PORTB,0,0
0008E0 BFB8       03537 	BTFSC comando,7,1
0008E2 8081       03538 	BSF   PORTB,0,0
0008E4 0000       03539 	NOP  
                  03540 			;	retardo_1m ();
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 60

ADDR   CODE       LINE  SOURCE

0008E6 DF63       03541 	RCALL retardo_1m
                  03542 			;	PORTB.5 = 0;  									// Modo comando.
0008E8 9A81       03543 	BCF   PORTB,5,0
                  03544 			;	retardo_20u ();
0008EA DF57       03545 	RCALL retardo_20u
                  03546 			;	PORTB.4 = 1;  									// Breve pulso.
0008EC 8881       03547 	BSF   PORTB,4,0
                  03548 			;	retardo_20u ();
0008EE DF55       03549 	RCALL retardo_20u
                  03550 			;	PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
0008F0 9881       03551 	BCF   PORTB,4,0
                  03552 			;	retardo_1m ();
0008F2 DF5D       03553 	RCALL retardo_1m
                  03554 			;	retardo_1m ();
0008F4 D75C       03555 	BRA   retardo_1m
                  03556 			;	//leds_OFF (10);
                  03557 			;	
                  03558 			;	
                  03559 			;	return;
                  03560 			;}    
                  03561 			;
                  03562 			;void enviar_literal (char dato) 
                  03563 			;{
                  03564 enviar_literal
0008F6 0100       03565 	MOVLB 0
0008F8 6F9E       03566 	MOVWF dato,1
                  03567 			;    char i;
                  03568 			;
                  03569 			;	
                  03570 			;	PORTB.3 = dato.4;
0008FA A99E       03571 	BTFSS dato,4,1
0008FC 9681       03572 	BCF   PORTB,3,0
0008FE B99E       03573 	BTFSC dato,4,1
000900 8681       03574 	BSF   PORTB,3,0
                  03575 			;	nop();
000902 0000       03576 	NOP  
                  03577 			;	PORTB.2 = dato.5;
000904 AB9E       03578 	BTFSS dato,5,1
000906 9481       03579 	BCF   PORTB,2,0
000908 BB9E       03580 	BTFSC dato,5,1
00090A 8481       03581 	BSF   PORTB,2,0
                  03582 			;	nop();
00090C 0000       03583 	NOP  
                  03584 			;	PORTB.1 = dato.6;
00090E AD9E       03585 	BTFSS dato,6,1
000910 9281       03586 	BCF   PORTB,1,0
000912 BD9E       03587 	BTFSC dato,6,1
000914 8281       03588 	BSF   PORTB,1,0
                  03589 			;	nop();
000916 0000       03590 	NOP  
                  03591 			;	PORTB.0 = dato.7;
000918 AF9E       03592 	BTFSS dato,7,1
00091A 9081       03593 	BCF   PORTB,0,0
00091C BF9E       03594 	BTFSC dato,7,1
00091E 8081       03595 	BSF   PORTB,0,0
                  03596 			;	nop();
000920 0000       03597 	NOP  
                  03598 			;	PORTB.5 = 1;  									// Modo dato.
000922 8A81       03599 	BSF   PORTB,5,0
                  03600 			;	retardo_20u ();
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 61

ADDR   CODE       LINE  SOURCE

000924 DF3A       03601 	RCALL retardo_20u
                  03602 			;	PORTB.4 = 1;  									// Breve pulso.
000926 8881       03603 	BSF   PORTB,4,0
                  03604 			;	retardo_20u ();
000928 DF38       03605 	RCALL retardo_20u
                  03606 			;	PORTB.4 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
00092A 9881       03607 	BCF   PORTB,4,0
                  03608 			;	for (i = 1; i <= 6; i++) retardo_20u ();
00092C 0E01       03609 	MOVLW 1
00092E 0100       03610 	MOVLB 0
000930 6F9F       03611 	MOVWF i_3,1
000932 0E07       03612 m104	MOVLW 7
000934 0100       03613 	MOVLB 0
000936 619F       03614 	CPFSLT i_3,1
000938 D004       03615 	BRA   m105
00093A DF2F       03616 	RCALL retardo_20u
00093C 0100       03617 	MOVLB 0
00093E 2B9F       03618 	INCF  i_3,1,1
000940 D7F8       03619 	BRA   m104
                  03620 			;	dato = swap (dato);
000942 0100       03621 m105	MOVLB 0
000944 3B9E       03622 	SWAPF dato,1,1
                  03623 			;	PORTB.3 = dato.4;nop();
000946 A99E       03624 	BTFSS dato,4,1
000948 9681       03625 	BCF   PORTB,3,0
00094A B99E       03626 	BTFSC dato,4,1
00094C 8681       03627 	BSF   PORTB,3,0
00094E 0000       03628 	NOP  
                  03629 			;	PORTB.2 = dato.5;nop();
000950 AB9E       03630 	BTFSS dato,5,1
000952 9481       03631 	BCF   PORTB,2,0
000954 BB9E       03632 	BTFSC dato,5,1
000956 8481       03633 	BSF   PORTB,2,0
000958 0000       03634 	NOP  
                  03635 			;	PORTB.1 = dato.6;nop();
00095A AD9E       03636 	BTFSS dato,6,1
00095C 9281       03637 	BCF   PORTB,1,0
00095E BD9E       03638 	BTFSC dato,6,1
000960 8281       03639 	BSF   PORTB,1,0
000962 0000       03640 	NOP  
                  03641 			;	PORTB.0 = dato.7;nop();
000964 AF9E       03642 	BTFSS dato,7,1
000966 9081       03643 	BCF   PORTB,0,0
000968 BF9E       03644 	BTFSC dato,7,1
00096A 8081       03645 	BSF   PORTB,0,0
00096C 0000       03646 	NOP  
                  03647 			;	retardo_1m ();
00096E DF1F       03648 	RCALL retardo_1m
                  03649 			;	PORTB.5 = 1;  									// Modo dato.
000970 8A81       03650 	BSF   PORTB,5,0
                  03651 			;	retardo_1m ();
000972 DF1D       03652 	RCALL retardo_1m
                  03653 			;	PORTB.4 = 1;  									// Breve pulso.
000974 8881       03654 	BSF   PORTB,4,0
                  03655 			;	retardo_20u ();
000976 DF11       03656 	RCALL retardo_20u
                  03657 			;	PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
000978 9881       03658 	BCF   PORTB,4,0
                  03659 			;	for (i = 1; i<= 6; i++) retardo_20u ();
00097A 0E01       03660 	MOVLW 1
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 62

ADDR   CODE       LINE  SOURCE

00097C 0100       03661 	MOVLB 0
00097E 6F9F       03662 	MOVWF i_3,1
000980 0E07       03663 m106	MOVLW 7
000982 0100       03664 	MOVLB 0
000984 619F       03665 	CPFSLT i_3,1
000986 D004       03666 	BRA   m107
000988 DF08       03667 	RCALL retardo_20u
00098A 0100       03668 	MOVLB 0
00098C 2B9F       03669 	INCF  i_3,1,1
00098E D7F8       03670 	BRA   m106
                  03671 			;	enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.	
000990 0E0C       03672 m107	MOVLW 12
000992 D776       03673 	BRA   enviar_comando
                  03674 			;	return;
                  03675 			;}   
                  03676 			;
                  03677 			;void enviar_cifra (char dato) 
                  03678 			;{
                  03679 enviar_cifra
000994 6E7F       03680 	MOVWF dato_2,0
                  03681 			;    char i;
                  03682 			;	dato = dato + 0x30; 							// Convierto el nmero en su equivalente ASCII literal. 
000996 0E30       03683 	MOVLW 48
000998 267F       03684 	ADDWF dato_2,1,0
                  03685 			;	PORTB.3 = dato.4;
00099A A87F       03686 	BTFSS dato_2,4,0
00099C 9681       03687 	BCF   PORTB,3,0
00099E B87F       03688 	BTFSC dato_2,4,0
0009A0 8681       03689 	BSF   PORTB,3,0
                  03690 			;	nop();
0009A2 0000       03691 	NOP  
                  03692 			;	PORTB.2 = dato.5;
0009A4 AA7F       03693 	BTFSS dato_2,5,0
0009A6 9481       03694 	BCF   PORTB,2,0
0009A8 BA7F       03695 	BTFSC dato_2,5,0
0009AA 8481       03696 	BSF   PORTB,2,0
                  03697 			;	nop();
0009AC 0000       03698 	NOP  
                  03699 			;	PORTB.1 = dato.6;
0009AE AC7F       03700 	BTFSS dato_2,6,0
0009B0 9281       03701 	BCF   PORTB,1,0
0009B2 BC7F       03702 	BTFSC dato_2,6,0
0009B4 8281       03703 	BSF   PORTB,1,0
                  03704 			;	nop();
0009B6 0000       03705 	NOP  
                  03706 			;	PORTB.0 = dato.7;
0009B8 AE7F       03707 	BTFSS dato_2,7,0
0009BA 9081       03708 	BCF   PORTB,0,0
0009BC BE7F       03709 	BTFSC dato_2,7,0
0009BE 8081       03710 	BSF   PORTB,0,0
                  03711 			;	nop();
0009C0 0000       03712 	NOP  
                  03713 			;	PORTB.5 = 1;  									// Modo dato.
0009C2 8A81       03714 	BSF   PORTB,5,0
                  03715 			;	retardo_20u ();
0009C4 DEEA       03716 	RCALL retardo_20u
                  03717 			;	PORTB.4 = 1;  									// Breve pulso.
0009C6 8881       03718 	BSF   PORTB,4,0
                  03719 			;	retardo_20u ();
0009C8 DEE8       03720 	RCALL retardo_20u
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 63

ADDR   CODE       LINE  SOURCE

                  03721 			;	PORTB.4 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
0009CA 9881       03722 	BCF   PORTB,4,0
                  03723 			;	for (i = 1; i <= 6; i++) retardo_20u ();
0009CC 0E01       03724 	MOVLW 1
0009CE 6E7F       03725 	MOVWF i_4,0
0009D0 0E07       03726 m108	MOVLW 7
0009D2 607F       03727 	CPFSLT i_4,0
0009D4 D003       03728 	BRA   m109
0009D6 DEE1       03729 	RCALL retardo_20u
0009D8 2A7F       03730 	INCF  i_4,1,0
0009DA D7FA       03731 	BRA   m108
                  03732 			;	dato = swap (dato);
0009DC 3A7F       03733 m109	SWAPF dato_2,1,0
                  03734 			;	PORTB.3 = dato.4;
0009DE A87F       03735 	BTFSS dato_2,4,0
0009E0 9681       03736 	BCF   PORTB,3,0
0009E2 B87F       03737 	BTFSC dato_2,4,0
0009E4 8681       03738 	BSF   PORTB,3,0
                  03739 			;	nop();
0009E6 0000       03740 	NOP  
                  03741 			;	PORTB.2 = dato.5;
0009E8 AA7F       03742 	BTFSS dato_2,5,0
0009EA 9481       03743 	BCF   PORTB,2,0
0009EC BA7F       03744 	BTFSC dato_2,5,0
0009EE 8481       03745 	BSF   PORTB,2,0
                  03746 			;	nop();
0009F0 0000       03747 	NOP  
                  03748 			;	PORTB.1 = dato.6;
0009F2 AC7F       03749 	BTFSS dato_2,6,0
0009F4 9281       03750 	BCF   PORTB,1,0
0009F6 BC7F       03751 	BTFSC dato_2,6,0
0009F8 8281       03752 	BSF   PORTB,1,0
                  03753 			;	nop();
0009FA 0000       03754 	NOP  
                  03755 			;	PORTB.0 = dato.7;
0009FC AE7F       03756 	BTFSS dato_2,7,0
0009FE 9081       03757 	BCF   PORTB,0,0
000A00 BE7F       03758 	BTFSC dato_2,7,0
000A02 8081       03759 	BSF   PORTB,0,0
                  03760 			;	retardo_1m ();
000A04 DED4       03761 	RCALL retardo_1m
                  03762 			;	PORTB.5 = 1;  									// Modo dato.
000A06 8A81       03763 	BSF   PORTB,5,0
                  03764 			;	retardo_1m ();
000A08 DED2       03765 	RCALL retardo_1m
                  03766 			;	PORTB.4 = 1;  									// Breve pulso.
000A0A 8881       03767 	BSF   PORTB,4,0
                  03768 			;	retardo_20u ();
000A0C DEC6       03769 	RCALL retardo_20u
                  03770 			;	PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
000A0E 9881       03771 	BCF   PORTB,4,0
                  03772 			;	for (i = 1; i<= 6; i++) retardo_20u ();
000A10 0E01       03773 	MOVLW 1
000A12 6E7F       03774 	MOVWF i_4,0
000A14 0E07       03775 m110	MOVLW 7
000A16 607F       03776 	CPFSLT i_4,0
000A18 D003       03777 	BRA   m111
000A1A DEBF       03778 	RCALL retardo_20u
000A1C 2A7F       03779 	INCF  i_4,1,0
000A1E D7FA       03780 	BRA   m110
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 64

ADDR   CODE       LINE  SOURCE

                  03781 			;	enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.
000A20 0E0C       03782 m111	MOVLW 12
000A22 D72E       03783 	BRA   enviar_comando
                  03784 			;	return;
                  03785 			;} 
                  03786 			;
                  03787 			;void inicializar_lcd (void) 
                  03788 			;{
                  03789 inicializar_lcd
                  03790 			;	char i;
                  03791 			;	clrwdt () ;	
000A24 0004       03792 	CLRWDT
                  03793 			;	for (i = 1; i < 21; i++) retardo_1m ();    
000A26 0E01       03794 	MOVLW 1
000A28 0100       03795 	MOVLB 0
000A2A 6F9D       03796 	MOVWF i_5,1
000A2C 0E15       03797 m112	MOVLW 21
000A2E 0100       03798 	MOVLB 0
000A30 619D       03799 	CPFSLT i_5,1
000A32 D004       03800 	BRA   m113
000A34 DEBC       03801 	RCALL retardo_1m
000A36 0100       03802 	MOVLB 0
000A38 2B9D       03803 	INCF  i_5,1,1
000A3A D7F8       03804 	BRA   m112
                  03805 			;	envia_codigo_inicial (0b.00.11.0000);
000A3C 0E30       03806 m113	MOVLW 48
000A3E DF04       03807 	RCALL envia_codigo_inicial
                  03808 			;	for (i = 1; i < 6; i++) retardo_1m ();
000A40 0E01       03809 	MOVLW 1
000A42 0100       03810 	MOVLB 0
000A44 6F9D       03811 	MOVWF i_5,1
000A46 0E06       03812 m114	MOVLW 6
000A48 0100       03813 	MOVLB 0
000A4A 619D       03814 	CPFSLT i_5,1
000A4C D004       03815 	BRA   m115
000A4E DEAF       03816 	RCALL retardo_1m
000A50 0100       03817 	MOVLB 0
000A52 2B9D       03818 	INCF  i_5,1,1
000A54 D7F8       03819 	BRA   m114
                  03820 			;    envia_codigo_inicial (0b.00.11.0000);	
000A56 0E30       03821 m115	MOVLW 48
000A58 DEF7       03822 	RCALL envia_codigo_inicial
                  03823 			;	for (i = 1; i< 11; i++) retardo_20u ();
000A5A 0E01       03824 	MOVLW 1
000A5C 0100       03825 	MOVLB 0
000A5E 6F9D       03826 	MOVWF i_5,1
000A60 0E0B       03827 m116	MOVLW 11
000A62 0100       03828 	MOVLB 0
000A64 619D       03829 	CPFSLT i_5,1
000A66 D004       03830 	BRA   m117
000A68 DE98       03831 	RCALL retardo_20u
000A6A 0100       03832 	MOVLB 0
000A6C 2B9D       03833 	INCF  i_5,1,1
000A6E D7F8       03834 	BRA   m116
                  03835 			;    envia_codigo_inicial (0b.00.11.0000);
000A70 0E30       03836 m117	MOVLW 48
000A72 DEEA       03837 	RCALL envia_codigo_inicial
                  03838 			;	for (i = 1; i < 11; i++) retardo_20u ();
000A74 0E01       03839 	MOVLW 1
000A76 0100       03840 	MOVLB 0
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 65

ADDR   CODE       LINE  SOURCE

000A78 6F9D       03841 	MOVWF i_5,1
000A7A 0E0B       03842 m118	MOVLW 11
000A7C 0100       03843 	MOVLB 0
000A7E 619D       03844 	CPFSLT i_5,1
000A80 D004       03845 	BRA   m119
000A82 DE8B       03846 	RCALL retardo_20u
000A84 0100       03847 	MOVLB 0
000A86 2B9D       03848 	INCF  i_5,1,1
000A88 D7F8       03849 	BRA   m118
                  03850 			;	envia_codigo_inicial (0b.00.10.0000);			// A 4 bits.
000A8A 0E20       03851 m119	MOVLW 32
000A8C DEDD       03852 	RCALL envia_codigo_inicial
                  03853 			;	enviar_comando (0b.0010.1000);					// A 4 bits, doble lnea, caracteres 5x7.
000A8E 0E28       03854 	MOVLW 40
000A90 DEF7       03855 	RCALL enviar_comando
                  03856 			;	enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.
000A92 0E0C       03857 	MOVLW 12
000A94 DEF5       03858 	RCALL enviar_comando
                  03859 			;	enviar_comando (0b.0000.0010);  				// Cursor en home, inicio de primera linea.
000A96 0E02       03860 	MOVLW 2
000A98 D6F3       03861 	BRA   enviar_comando
                  03862 			;	return;
                  03863 			;}
                  03864 			;
                  03865 			;void escribir_posicion (char linea, char columna)
                  03866 			;{
                  03867 escribir_posicion
000A9A 0100       03868 	MOVLB 0
000A9C 6F9E       03869 	MOVWF columna,1
                  03870 			;	
                  03871 			;	switch (linea) 									// (se resta una unidad a la coordenada lnea para que la posicin colum
                           na inicial sea 1 y no 0).
000A9E 519D       03872 	MOVF  linea,W,1
000AA0 0A01       03873 	XORLW 1
000AA2 B4D8       03874 	BTFSC 0xFD8,Zero_,0
000AA4 D00A       03875 	BRA   m120
000AA6 0A03       03876 	XORLW 3
000AA8 B4D8       03877 	BTFSC 0xFD8,Zero_,0
000AAA D00C       03878 	BRA   m121
000AAC 0A01       03879 	XORLW 1
000AAE B4D8       03880 	BTFSC 0xFD8,Zero_,0
000AB0 D00E       03881 	BRA   m122
000AB2 0A07       03882 	XORLW 7
000AB4 B4D8       03883 	BTFSC 0xFD8,Zero_,0
000AB6 D010       03884 	BRA   m123
000AB8 D016       03885 	BRA   m124
                  03886 			;		{
                  03887 			;			case 1:
                  03888 			;				enviar_comando (127 + columna); 	// Inicio primera linea.
000ABA 0E7F       03889 m120	MOVLW 127
000ABC 0100       03890 	MOVLB 0
000ABE 259E       03891 	ADDWF columna,W,1
000AC0 DEDF       03892 	RCALL enviar_comando
                  03893 			;			break;
000AC2 D011       03894 	BRA   m124
                  03895 			;						
                  03896 			;			case 2:
                  03897 			;				enviar_comando (191 + columna); 	// Inicio segunda lnea.
000AC4 0EBF       03898 m121	MOVLW 191
000AC6 0100       03899 	MOVLB 0
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 66

ADDR   CODE       LINE  SOURCE

000AC8 259E       03900 	ADDWF columna,W,1
000ACA DEDA       03901 	RCALL enviar_comando
                  03902 			;			break;			
000ACC D00C       03903 	BRA   m124
                  03904 			;
                  03905 			;			case 3:
                  03906 			;				enviar_comando (147 + columna);		// Inicio tercera lnea (cursor en posicin 20 de la primera lnea).
000ACE 0E93       03907 m122	MOVLW 147
000AD0 0100       03908 	MOVLB 0
000AD2 259E       03909 	ADDWF columna,W,1
000AD4 DED5       03910 	RCALL enviar_comando
                  03911 			;			break;				
000AD6 D007       03912 	BRA   m124
                  03913 			;			
                  03914 			;			case 4:
                  03915 			;				enviar_comando (211 + columna); 	// Inicio cuarta lnea (cursor en posicin 20 de la segunda lnea).
000AD8 0ED3       03916 m123	MOVLW 211
000ADA 0100       03917 	MOVLB 0
000ADC 259E       03918 	ADDWF columna,W,1
000ADE DED0       03919 	RCALL enviar_comando
                  03920 			;			break;
000AE0 D002       03921 	BRA   m124
                  03922 			;			enviar_comando (0b.0000.1100);			// Pantalla encendida, sin cursor.
000AE2 0E0C       03923 	MOVLW 12
000AE4 D6CD       03924 	BRA   enviar_comando
                  03925 			;		}
                  03926 			;	
                  03927 			;	
                  03928 			;}
000AE6 0012       03929 m124	RETURN
                  03930 			;
                  03931 			;void borrar_linea (char linea)
                  03932 			;{
                  03933 borrar_linea
000AE8 6E7F       03934 	MOVWF linea_2,0
                  03935 			;	char i;
                  03936 			;		
                  03937 			;	switch (linea) 									// (se resta una unidad a la coordenada lnea para que la posicin colum
                           na inicial sea 1 y no 0).
000AEA 507F       03938 	MOVF  linea_2,W,0
000AEC 0A01       03939 	XORLW 1
000AEE B4D8       03940 	BTFSC 0xFD8,Zero_,0
000AF0 D00A       03941 	BRA   m125
000AF2 0A03       03942 	XORLW 3
000AF4 B4D8       03943 	BTFSC 0xFD8,Zero_,0
000AF6 D00A       03944 	BRA   m126
000AF8 0A01       03945 	XORLW 1
000AFA B4D8       03946 	BTFSC 0xFD8,Zero_,0
000AFC D00A       03947 	BRA   m127
000AFE 0A07       03948 	XORLW 7
000B00 B4D8       03949 	BTFSC 0xFD8,Zero_,0
000B02 D00A       03950 	BRA   m128
000B04 D00B       03951 	BRA   m129
                  03952 			;		{
                  03953 			;			case 1:
                  03954 			;				enviar_comando (128); 				// Inicio primera linea.
000B06 0E80       03955 m125	MOVLW 128
000B08 DEBB       03956 	RCALL enviar_comando
                  03957 			;			break;
000B0A D008       03958 	BRA   m129
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 67

ADDR   CODE       LINE  SOURCE

                  03959 			;						
                  03960 			;			case 2:
                  03961 			;				enviar_comando (192); 				// Inicio segunda lnea.
000B0C 0EC0       03962 m126	MOVLW 192
000B0E DEB8       03963 	RCALL enviar_comando
                  03964 			;			break;			
000B10 D005       03965 	BRA   m129
                  03966 			;
                  03967 			;			case 3:
                  03968 			;				enviar_comando (148); 				// Inicio tercera lnea (cursor en posicin 20 de la primera lnea).
000B12 0E94       03969 m127	MOVLW 148
000B14 DEB5       03970 	RCALL enviar_comando
                  03971 			;			break;				
000B16 D002       03972 	BRA   m129
                  03973 			;			
                  03974 			;			case 4:
                  03975 			;				enviar_comando (212); 				// Inicio cuarta lnea (cursor en posicin 20 de la segunda lnea).
000B18 0ED4       03976 m128	MOVLW 212
000B1A DEB2       03977 	RCALL enviar_comando
                  03978 			;			break;
                  03979 			;		}
                  03980 			;	for (i = 1; i < 21; i++) enviar_literal (' '); 	// Envio 20 carcteres en blanco y posiciono en la siguiente lnea.
000B1C 0E01       03981 m129	MOVLW 1
000B1E 6E7F       03982 	MOVWF i_6,0
000B20 0E15       03983 m130	MOVLW 21
000B22 607F       03984 	CPFSLT i_6,0
000B24 D004       03985 	BRA   m131
000B26 0E20       03986 	MOVLW 32
000B28 DEE6       03987 	RCALL enviar_literal
000B2A 2A7F       03988 	INCF  i_6,1,0
000B2C D7F9       03989 	BRA   m130
                  03990 			;	enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.	
000B2E 0E0C       03991 m131	MOVLW 12
000B30 D6A7       03992 	BRA   enviar_comando
                  03993 			;}
                  03994 			;
                  03995 			;void borrar_lcd (void)
                  03996 			;{
                  03997 borrar_lcd
                  03998 			;	enviar_comando (0b.0000.0001);  				// Borrado del display y cursor en la posicin inicial.	
000B32 0E01       03999 	MOVLW 1
000B34 D6A5       04000 	BRA   enviar_comando
                  04001 			;}
                  04002 			;
                  04003 			;void Enviar_lcd (char linea, char columna, uns16 dato, bit bd, bit dp, bit xi,bit ndp)
                  04004 			;            //fila , col , uns16 , bd -> si 0 posa espai si "0" a l'esquerra ,, dp -> si "0"--> posa punt decimal
                  04005 			;{
                  04006 Enviar_lcd
                  04007 			;// Aquesta funcio, posiciona Fila i Columna d'un LCD 4x20 i envia una xifra uns16 descomposant-la i posant 
                  04008 			;//  decimal o no, segons sigui dp, si "0"--> posa punt decimal , si dp "1" -> no posa dp
                  04009 			;//  si bd = "0" -> posa espai, si bd = "1"  --> No  posa espai i posa el 0.
                  04010 			;// si xi = 0 -> 3 xifres,, si xi = 1  -> 4 xifres
                  04011 			;// Atencio, amb dp S'UTILIZA un ESPAI MES
                  04012 			;// amb 4 xifres, tambe es representen 3, pero es gasta un espai de mes.
                  04013 			;// ESPI utilitzat...3 per 3 xifres,, 4 per 3xifres + dp   O 4xifres s/dp ,, 5 per 4 xifres + dp
                  04014 			;// ndp ..si "0"...1decimal... si "1"   2 decimals
                  04015 			;	uns16 num, u_milers, cent;
                  04016 			;	char dec, unid, resto1;
                  04017 			;	char i, xx, yy, dat,xy;
                  04018 			;	
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 68

ADDR   CODE       LINE  SOURCE

                  04019 			;	//CON_LCD ();
                  04020 			;	//posiciono
                  04021 			;	switch (linea) 									// (se resta una unidad a la coordenada lnea para que la posicin colum
                           na inicial sea 1 y no 0).
000B36 507F       04022 	MOVF  linea_3,W,0
000B38 0A01       04023 	XORLW 1
000B3A B4D8       04024 	BTFSC 0xFD8,Zero_,0
000B3C D00A       04025 	BRA   m132
000B3E 0A03       04026 	XORLW 3
000B40 B4D8       04027 	BTFSC 0xFD8,Zero_,0
000B42 D00B       04028 	BRA   m133
000B44 0A01       04029 	XORLW 1
000B46 B4D8       04030 	BTFSC 0xFD8,Zero_,0
000B48 D00C       04031 	BRA   m134
000B4A 0A07       04032 	XORLW 7
000B4C B4D8       04033 	BTFSC 0xFD8,Zero_,0
000B4E D00D       04034 	BRA   m135
000B50 D012       04035 	BRA   m136
                  04036 			;		{
                  04037 			;			case 1:	enviar_comando (127 + columna); 	// inicio primera linea.
000B52 0E7F       04038 m132	MOVLW 127
000B54 247F       04039 	ADDWF columna_2,W,0
000B56 DE94       04040 	RCALL enviar_comando
                  04041 			;			break;	
000B58 D00E       04042 	BRA   m136
                  04043 			;			case 2:	enviar_comando (191 + columna); 	// inicio segunda lnea.
000B5A 0EBF       04044 m133	MOVLW 191
000B5C 247F       04045 	ADDWF columna_2,W,0
000B5E DE90       04046 	RCALL enviar_comando
                  04047 			;			break;			
000B60 D00A       04048 	BRA   m136
                  04049 			;			case 3:	enviar_comando (147 + columna); 	// inicio tercera lnea (cursor en posicin 20 de la primera lnea).
000B62 0E93       04050 m134	MOVLW 147
000B64 247F       04051 	ADDWF columna_2,W,0
000B66 DE8C       04052 	RCALL enviar_comando
                  04053 			;			break;				
000B68 D006       04054 	BRA   m136
                  04055 			;			case 4:	enviar_comando (211 + columna); 	// inicio cuarta lnea (cursor en posicin 20 de la segunda lnea).
000B6A 0ED3       04056 m135	MOVLW 211
000B6C 247F       04057 	ADDWF columna_2,W,0
000B6E DE88       04058 	RCALL enviar_comando
                  04059 			;			break;	
000B70 D002       04060 	BRA   m136
                  04061 			;			enviar_comando (0b.0000.1100);			// pantalla encendida, sin cursor
000B72 0E0C       04062 	MOVLW 12
000B74 DE85       04063 	RCALL enviar_comando
                  04064 			;		}				
                  04065 			;		if (!xi)
000B76 B07F       04066 m136	BTFSC 0xF7F,xi,0
000B78 D011       04067 	BRA   m137
                  04068 			;		{
                  04069 			;			xy = 2;
000B7A 0E02       04070 	MOVLW 2
000B7C 6E7F       04071 	MOVWF xy,0
                  04072 			;			u_milers = 0;
000B7E 6A7F       04073 	CLRF  u_milers,0
000B80 6A7F       04074 	CLRF  u_milers+1,0
                  04075 			;			if (dato > 999) { enviar_literal ('>');enviar_literal ('E');enviar_literal ('r'); goto so; }
000B82 0EE8       04076 	MOVLW 232
000B84 5C7F       04077 	SUBWF dato_3,W,0
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 69

ADDR   CODE       LINE  SOURCE

000B86 0E03       04078 	MOVLW 3
000B88 587F       04079 	SUBWFB dato_3+1,W,0
000B8A A0D8       04080 	BTFSS 0xFD8,Carry,0
000B8C D036       04081 	BRA   m139
000B8E 0E3E       04082 	MOVLW 62
000B90 DEB2       04083 	RCALL enviar_literal
000B92 0E45       04084 	MOVLW 69
000B94 DEB0       04085 	RCALL enviar_literal
000B96 0E72       04086 	MOVLW 114
000B98 DEAE       04087 	RCALL enviar_literal
000B9A D0F9       04088 	BRA   m159
                  04089 			;		    else goto sa;
                  04090 			;		}
                  04091 			;		else
                  04092 			;		{
                  04093 			;			xy = 1;
000B9C 0E01       04094 m137	MOVLW 1
000B9E 6E7F       04095 	MOVWF xy,0
                  04096 			;			if (dato > 9999) { enviar_literal ('>');enviar_literal ('E');enviar_literal ('r'); goto so; }
000BA0 0E10       04097 	MOVLW 16
000BA2 5C7F       04098 	SUBWF dato_3,W,0
000BA4 0E27       04099 	MOVLW 39
000BA6 587F       04100 	SUBWFB dato_3+1,W,0
000BA8 A0D8       04101 	BTFSS 0xFD8,Carry,0
000BAA D007       04102 	BRA   m138
000BAC 0E3E       04103 	MOVLW 62
000BAE DEA3       04104 	RCALL enviar_literal
000BB0 0E45       04105 	MOVLW 69
000BB2 DEA1       04106 	RCALL enviar_literal
000BB4 0E72       04107 	MOVLW 114
000BB6 DE9F       04108 	RCALL enviar_literal
000BB8 D0EA       04109 	BRA   m159
                  04110 			;		}
                  04111 			;			// Separo per 4 xifres
                  04112 			;			num = dato; // per 4 xifres
000BBA CF7F FF7F  04113 m138	MOVFF dato_3,num
000BBE CF7F FF7F  04114 	MOVFF dato_3+1,num+1
                  04115 			;			u_milers = num / 1000;
000BC2 CF7F F0B8  04116 	MOVFF num,arg1_2
000BC6 CF7F F0B9  04117 	MOVFF num+1,arg1_2+1
000BCA 0EE8       04118 	MOVLW 232
000BCC 0100       04119 	MOVLB 0
000BCE 6FBA       04120 	MOVWF arg2_2,1
000BD0 0E03       04121 	MOVLW 3
000BD2 6FBB       04122 	MOVWF arg2_2+1,1
000BD4 DCEE       04123 	RCALL _divU16_16
000BD6 C0B8 FF7F  04124 	MOVFF arg1_2,u_milers
000BDA C0B9 FF7F  04125 	MOVFF arg1_2+1,u_milers+1
                  04126 			;			dato = num % 1000;
000BDE CF7F F0B8  04127 	MOVFF num,arg1_6
000BE2 CF7F F0B9  04128 	MOVFF num+1,arg1_6+1
000BE6 0EE8       04129 	MOVLW 232
000BE8 0100       04130 	MOVLB 0
000BEA 6FBA       04131 	MOVWF arg2_6,1
000BEC 0E03       04132 	MOVLW 3
000BEE 6FBB       04133 	MOVWF arg2_6+1,1
000BF0 DD12       04134 	RCALL _remU16_16
000BF2 C0BC FF7F  04135 	MOVFF rm_6,dato_3
000BF6 C0BD FF7F  04136 	MOVFF rm_6+1,dato_3+1
                  04137 			;			// Separo per 3 xifres
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 70

ADDR   CODE       LINE  SOURCE

                  04138 			;sa:			cent   = dato   / 100;   	
000BFA CF7F F0B8  04139 m139	MOVFF dato_3,arg1
000BFE CF7F F0B9  04140 	MOVFF dato_3+1,arg1+1
000C02 0E64       04141 	MOVLW 100
000C04 DCBE       04142 	RCALL _divU16_8
000C06 C0B8 FF7F  04143 	MOVFF arg1,cent
000C0A C0B9 FF7F  04144 	MOVFF arg1+1,cent+1
                  04145 			;			resto1 = dato   % 100;
000C0E CF7F F0B8  04146 	MOVFF dato_3,arg1_5
000C12 CF7F F0B9  04147 	MOVFF dato_3+1,arg1_5+1
000C16 0E64       04148 	MOVLW 100
000C18 DCE7       04149 	RCALL _remU16_8
000C1A 6E7F       04150 	MOVWF resto1,0
                  04151 			;			dec    = resto1 /  10;  
000C1C CF7F F0B8  04152 	MOVFF resto1,arg1
000C20 0100       04153 	MOVLB 0
000C22 6BB9       04154 	CLRF  arg1+1,1
000C24 0E0A       04155 	MOVLW 10
000C26 DCAD       04156 	RCALL _divU16_8
000C28 C0B8 FF7F  04157 	MOVFF arg1,dec
                  04158 			;			unid   = resto1 %  10; 		
000C2C CF7F F0B8  04159 	MOVFF resto1,arg1_5
000C30 0100       04160 	MOVLB 0
000C32 6BB9       04161 	CLRF  arg1_5+1,1
000C34 0E0A       04162 	MOVLW 10
000C36 DCD8       04163 	RCALL _remU16_8
000C38 6E7F       04164 	MOVWF unid,0
                  04165 			;		// Envio
                  04166 			;		for (xx = xy; xx < 7; xx++)
000C3A CF7F FF7F  04167 	MOVFF xy,xx
000C3E 0E07       04168 m140	MOVLW 7
000C40 607F       04169 	CPFSLT xx,0
000C42 D0A5       04170 	BRA   m159
                  04171 			;		{
                  04172 			;			clrwdt () ;
000C44 0004       04173 	CLRWDT
                  04174 			;			if (xx == 1) 
000C46 2C7F       04175 	DECFSZ xx,W,0
000C48 D00B       04176 	BRA   m142
                  04177 			;			{
                  04178 			;				if ((u_milers==0)&&(!bd)) dat = ' '; // bd =0 --> espai
000C4A 507F       04179 	MOVF  u_milers,W,0
000C4C 107F       04180 	IORWF u_milers+1,W,0
000C4E A4D8       04181 	BTFSS 0xFD8,Zero_,0
000C50 D005       04182 	BRA   m141
000C52 B07F       04183 	BTFSC 0xF7F,bd,0
000C54 D003       04184 	BRA   m141
000C56 0E20       04185 	MOVLW 32
000C58 6E7F       04186 	MOVWF dat,0
                  04187 			;				else dat = u_milers;
000C5A D002       04188 	BRA   m142
000C5C CF7F FF7F  04189 m141	MOVFF u_milers,dat
                  04190 			;			}
                  04191 			;			if (xx == 2) 
000C60 0E02       04192 m142	MOVLW 2
000C62 627F       04193 	CPFSEQ xx,0
000C64 D00F       04194 	BRA   m144
                  04195 			;			{
                  04196 			;				if ((u_milers==0)&&(cent==0)&&(!bd)) dat = ' '; // bd =0 --> espai
000C66 507F       04197 	MOVF  u_milers,W,0
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 71

ADDR   CODE       LINE  SOURCE

000C68 107F       04198 	IORWF u_milers+1,W,0
000C6A A4D8       04199 	BTFSS 0xFD8,Zero_,0
000C6C D009       04200 	BRA   m143
000C6E 507F       04201 	MOVF  cent,W,0
000C70 107F       04202 	IORWF cent+1,W,0
000C72 A4D8       04203 	BTFSS 0xFD8,Zero_,0
000C74 D005       04204 	BRA   m143
000C76 B07F       04205 	BTFSC 0xF7F,bd,0
000C78 D003       04206 	BRA   m143
000C7A 0E20       04207 	MOVLW 32
000C7C 6E7F       04208 	MOVWF dat,0
                  04209 			;				else dat = cent;
000C7E D002       04210 	BRA   m144
000C80 CF7F FF7F  04211 m143	MOVFF cent,dat
                  04212 			;			}
                  04213 			;			if (xx == 3) 
000C84 0E03       04214 m144	MOVLW 3
000C86 627F       04215 	CPFSEQ xx,0
000C88 D00A       04216 	BRA   m147
                  04217 			;			{
                  04218 			;				if(ndp) { if (dp==0) dat = '.';
000C8A A07F       04219 	BTFSS 0xF7F,ndp,0
000C8C D007       04220 	BRA   m146
000C8E B07F       04221 	BTFSC 0xF7F,dp,0
000C90 D003       04222 	BRA   m145
000C92 0E2E       04223 	MOVLW 46
000C94 6E7F       04224 	MOVWF dat,0
                  04225 			;				          else xx++;  
000C96 D003       04226 	BRA   m147
000C98 2A7F       04227 m145	INCF  xx,1,0
                  04228 			;				        }
                  04229 			;				else xx++;		
000C9A D001       04230 	BRA   m147
000C9C 2A7F       04231 m146	INCF  xx,1,0
                  04232 			;			}
                  04233 			;			if (xx == 4)
000C9E 0E04       04234 m147	MOVLW 4
000CA0 627F       04235 	CPFSEQ xx,0
000CA2 D012       04236 	BRA   m149
                  04237 			;			{
                  04238 			;				if ((u_milers==0)&&(cent==0)&&(dec==0)&&(!bd)) dat = ' ';
000CA4 507F       04239 	MOVF  u_milers,W,0
000CA6 107F       04240 	IORWF u_milers+1,W,0
000CA8 A4D8       04241 	BTFSS 0xFD8,Zero_,0
000CAA D00C       04242 	BRA   m148
000CAC 507F       04243 	MOVF  cent,W,0
000CAE 107F       04244 	IORWF cent+1,W,0
000CB0 A4D8       04245 	BTFSS 0xFD8,Zero_,0
000CB2 D008       04246 	BRA   m148
000CB4 507F       04247 	MOVF  dec,W,0
000CB6 A4D8       04248 	BTFSS 0xFD8,Zero_,0
000CB8 D005       04249 	BRA   m148
000CBA B07F       04250 	BTFSC 0xF7F,bd,0
000CBC D003       04251 	BRA   m148
000CBE 0E20       04252 	MOVLW 32
000CC0 6E7F       04253 	MOVWF dat,0
                  04254 			;				else dat = dec ;
000CC2 D002       04255 	BRA   m149
000CC4 CF7F FF7F  04256 m148	MOVFF dec,dat
                  04257 			;			}
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 72

ADDR   CODE       LINE  SOURCE

                  04258 			;			if (xx == 5)
000CC8 0E05       04259 m149	MOVLW 5
000CCA 627F       04260 	CPFSEQ xx,0
000CCC D00A       04261 	BRA   m152
                  04262 			;			{
                  04263 			;				if(!ndp) { if (dp==0) dat = '.';	
000CCE B07F       04264 	BTFSC 0xF7F,ndp,0
000CD0 D007       04265 	BRA   m151
000CD2 B07F       04266 	BTFSC 0xF7F,dp,0
000CD4 D003       04267 	BRA   m150
000CD6 0E2E       04268 	MOVLW 46
000CD8 6E7F       04269 	MOVWF dat,0
                  04270 			;				           else xx++;
000CDA D003       04271 	BRA   m152
000CDC 2A7F       04272 m150	INCF  xx,1,0
                  04273 			;						 }
                  04274 			;				else xx++;		 
000CDE D001       04275 	BRA   m152
000CE0 2A7F       04276 m151	INCF  xx,1,0
                  04277 			;			}
                  04278 			;			if (xx == 6) dat = unid;
000CE2 0E06       04279 m152	MOVLW 6
000CE4 627F       04280 	CPFSEQ xx,0
000CE6 D002       04281 	BRA   m153
000CE8 CF7F FF7F  04282 	MOVFF unid,dat
                  04283 			;						
                  04284 			;			if ((dat!='.')&&(dat!=' ')) dat = dat + 0x30;
000CEC 507F       04285 m153	MOVF  dat,W,0
000CEE 0A2E       04286 	XORLW 46
000CF0 B4D8       04287 	BTFSC 0xFD8,Zero_,0
000CF2 D006       04288 	BRA   m154
000CF4 507F       04289 	MOVF  dat,W,0
000CF6 0A20       04290 	XORLW 32
000CF8 B4D8       04291 	BTFSC 0xFD8,Zero_,0
000CFA D002       04292 	BRA   m154
000CFC 0E30       04293 	MOVLW 48
000CFE 267F       04294 	ADDWF dat,1,0
                  04295 			;
                  04296 			;			PORTB.3 = dat.4;nop();
000D00 A87F       04297 m154	BTFSS dat,4,0
000D02 9681       04298 	BCF   PORTB,3,0
000D04 B87F       04299 	BTFSC dat,4,0
000D06 8681       04300 	BSF   PORTB,3,0
000D08 0000       04301 	NOP  
                  04302 			;			PORTB.2 = dat.5;nop();
000D0A AA7F       04303 	BTFSS dat,5,0
000D0C 9481       04304 	BCF   PORTB,2,0
000D0E BA7F       04305 	BTFSC dat,5,0
000D10 8481       04306 	BSF   PORTB,2,0
000D12 0000       04307 	NOP  
                  04308 			;			PORTB.1 = dat.6;nop();
000D14 AC7F       04309 	BTFSS dat,6,0
000D16 9281       04310 	BCF   PORTB,1,0
000D18 BC7F       04311 	BTFSC dat,6,0
000D1A 8281       04312 	BSF   PORTB,1,0
000D1C 0000       04313 	NOP  
                  04314 			;			PORTB.0 = dat.7;nop();
000D1E AE7F       04315 	BTFSS dat,7,0
000D20 9081       04316 	BCF   PORTB,0,0
000D22 BE7F       04317 	BTFSC dat,7,0
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 73

ADDR   CODE       LINE  SOURCE

000D24 8081       04318 	BSF   PORTB,0,0
000D26 0000       04319 	NOP  
                  04320 			;			PORTB.5 = 1;  									// Modo dato.
000D28 8A81       04321 	BSF   PORTB,5,0
                  04322 			;			retardo_20u ();
000D2A DD37       04323 	RCALL retardo_20u
                  04324 			;			PORTB.4 = 1;  									// Breve pulso.
000D2C 8881       04325 	BSF   PORTB,4,0
                  04326 			;			retardo_20u ();
000D2E DD35       04327 	RCALL retardo_20u
                  04328 			;			PORTB.4 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
000D30 9881       04329 	BCF   PORTB,4,0
                  04330 			;			for (i = 1; i <= 6; i++) retardo_20u ();
000D32 0E01       04331 	MOVLW 1
000D34 6E7F       04332 	MOVWF i_7,0
000D36 0E07       04333 m155	MOVLW 7
000D38 607F       04334 	CPFSLT i_7,0
000D3A D003       04335 	BRA   m156
000D3C DD2E       04336 	RCALL retardo_20u
000D3E 2A7F       04337 	INCF  i_7,1,0
000D40 D7FA       04338 	BRA   m155
                  04339 			;			dat = swap (dat);
000D42 3A7F       04340 m156	SWAPF dat,1,0
                  04341 			;			PORTB.3 = dat.4;nop();
000D44 A87F       04342 	BTFSS dat,4,0
000D46 9681       04343 	BCF   PORTB,3,0
000D48 B87F       04344 	BTFSC dat,4,0
000D4A 8681       04345 	BSF   PORTB,3,0
000D4C 0000       04346 	NOP  
                  04347 			;			PORTB.2 = dat.5;nop();
000D4E AA7F       04348 	BTFSS dat,5,0
000D50 9481       04349 	BCF   PORTB,2,0
000D52 BA7F       04350 	BTFSC dat,5,0
000D54 8481       04351 	BSF   PORTB,2,0
000D56 0000       04352 	NOP  
                  04353 			;			PORTB.1 = dat.6;nop();
000D58 AC7F       04354 	BTFSS dat,6,0
000D5A 9281       04355 	BCF   PORTB,1,0
000D5C BC7F       04356 	BTFSC dat,6,0
000D5E 8281       04357 	BSF   PORTB,1,0
000D60 0000       04358 	NOP  
                  04359 			;			PORTB.0 = dat.7;
000D62 AE7F       04360 	BTFSS dat,7,0
000D64 9081       04361 	BCF   PORTB,0,0
000D66 BE7F       04362 	BTFSC dat,7,0
000D68 8081       04363 	BSF   PORTB,0,0
                  04364 			;			retardo_1m ();
000D6A DD21       04365 	RCALL retardo_1m
                  04366 			;			PORTB.5 = 1;  									// Modo dato.
000D6C 8A81       04367 	BSF   PORTB,5,0
                  04368 			;			retardo_1m ();
000D6E DD1F       04369 	RCALL retardo_1m
                  04370 			;			PORTB.4 = 1;  									// Breve pulso.
000D70 8881       04371 	BSF   PORTB,4,0
                  04372 			;			retardo_20u ();
000D72 DD13       04373 	RCALL retardo_20u
                  04374 			;			PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
000D74 9881       04375 	BCF   PORTB,4,0
                  04376 			;			for (i = 1; i<= 6; i++) retardo_20u ();
000D76 0E01       04377 	MOVLW 1
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 74

ADDR   CODE       LINE  SOURCE

000D78 6E7F       04378 	MOVWF i_7,0
000D7A 0E07       04379 m157	MOVLW 7
000D7C 607F       04380 	CPFSLT i_7,0
000D7E D003       04381 	BRA   m158
000D80 DD0C       04382 	RCALL retardo_20u
000D82 2A7F       04383 	INCF  i_7,1,0
000D84 D7FA       04384 	BRA   m157
                  04385 			;			enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.			
000D86 0E0C       04386 m158	MOVLW 12
000D88 DD7B       04387 	RCALL enviar_comando
                  04388 			;		}
000D8A 2A7F       04389 	INCF  xx,1,0
000D8C D758       04390 	BRA   m140
                  04391 			;so:	//DESCON_LCD ();
                  04392 			;	return;
000D8E 0012       04393 m159	RETURN
                  04394 			;}
                  04395 			;
                  04396 			;void Enviar_uns16(char linea,char columna,uns16 dato){
                  04397 Enviar_uns16
                  04398 			;	//utilizaremos esta funcion en caso de necesitar un numero entero hasta 65536(16bits)
                  04399 			;	uns16 num, u_milers, cent, d_milers;
                  04400 			;	char dec, unid, resto1;
                  04401 			;	char i, xx, yy, dat,xy;
                  04402 			;
                  04403 			;	switch (linea) 									// (se resta una unidad a la coordenada lnea para que la posicin colum
                           na inicial sea 1 y no 0).
000D90 0100       04404 	MOVLB 0
000D92 51A4       04405 	MOVF  linea_4,W,1
000D94 0A01       04406 	XORLW 1
000D96 B4D8       04407 	BTFSC 0xFD8,Zero_,0
000D98 D00A       04408 	BRA   m160
000D9A 0A03       04409 	XORLW 3
000D9C B4D8       04410 	BTFSC 0xFD8,Zero_,0
000D9E D00C       04411 	BRA   m161
000DA0 0A01       04412 	XORLW 1
000DA2 B4D8       04413 	BTFSC 0xFD8,Zero_,0
000DA4 D00E       04414 	BRA   m162
000DA6 0A07       04415 	XORLW 7
000DA8 B4D8       04416 	BTFSC 0xFD8,Zero_,0
000DAA D010       04417 	BRA   m163
000DAC D016       04418 	BRA   m164
                  04419 			;		{
                  04420 			;			case 1:	enviar_comando (127 + columna); 	// inicio primera linea.
000DAE 0E7F       04421 m160	MOVLW 127
000DB0 0100       04422 	MOVLB 0
000DB2 25A5       04423 	ADDWF columna_3,W,1
000DB4 DD65       04424 	RCALL enviar_comando
                  04425 			;			break;	
000DB6 D011       04426 	BRA   m164
                  04427 			;			case 2:	enviar_comando (191 + columna); 	// inicio segunda lnea.
000DB8 0EBF       04428 m161	MOVLW 191
000DBA 0100       04429 	MOVLB 0
000DBC 25A5       04430 	ADDWF columna_3,W,1
000DBE DD60       04431 	RCALL enviar_comando
                  04432 			;			break;			
000DC0 D00C       04433 	BRA   m164
                  04434 			;			case 3:	enviar_comando (147 + columna); 	// inicio tercera lnea (cursor en posicin 20 de la primera lnea).
000DC2 0E93       04435 m162	MOVLW 147
000DC4 0100       04436 	MOVLB 0
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 75

ADDR   CODE       LINE  SOURCE

000DC6 25A5       04437 	ADDWF columna_3,W,1
000DC8 DD5B       04438 	RCALL enviar_comando
                  04439 			;			break;				
000DCA D007       04440 	BRA   m164
                  04441 			;			case 4:	enviar_comando (211 + columna); 	// inicio cuarta lnea (cursor en posicin 20 de la segunda lnea).
000DCC 0ED3       04442 m163	MOVLW 211
000DCE 0100       04443 	MOVLB 0
000DD0 25A5       04444 	ADDWF columna_3,W,1
000DD2 DD56       04445 	RCALL enviar_comando
                  04446 			;			break;	
000DD4 D002       04447 	BRA   m164
                  04448 			;			enviar_comando (0b.0000.1100);			// pantalla encendida, sin cursor
000DD6 0E0C       04449 	MOVLW 12
000DD8 DD53       04450 	RCALL enviar_comando
                  04451 			;		}				
                  04452 			;	
                  04453 			;			
                  04454 			;			num = dato; 
000DDA C0A6 F0A8  04455 m164	MOVFF dato_4,num_2
000DDE C0A7 F0A9  04456 	MOVFF dato_4+1,num_2+1
                  04457 			;			d_milers =num/10000;
000DE2 C0A8 F0B8  04458 	MOVFF num_2,arg1_2
000DE6 C0A9 F0B9  04459 	MOVFF num_2+1,arg1_2+1
000DEA 0E10       04460 	MOVLW 16
000DEC 0100       04461 	MOVLB 0
000DEE 6FBA       04462 	MOVWF arg2_2,1
000DF0 0E27       04463 	MOVLW 39
000DF2 6FBB       04464 	MOVWF arg2_2+1,1
000DF4 ECD9 F002  04465 	CALL  _divU16_16
000DF8 C0B8 F0AE  04466 	MOVFF arg1_2,d_milers
000DFC C0B9 F0AF  04467 	MOVFF arg1_2+1,d_milers+1
                  04468 			;			num= num%10000;
000E00 C0A8 F0B8  04469 	MOVFF num_2,arg1_6
000E04 C0A9 F0B9  04470 	MOVFF num_2+1,arg1_6+1
000E08 0E10       04471 	MOVLW 16
000E0A 0100       04472 	MOVLB 0
000E0C 6FBA       04473 	MOVWF arg2_6,1
000E0E 0E27       04474 	MOVLW 39
000E10 6FBB       04475 	MOVWF arg2_6+1,1
000E12 DC01       04476 	RCALL _remU16_16
000E14 C0BC F0A8  04477 	MOVFF rm_6,num_2
000E18 C0BD F0A9  04478 	MOVFF rm_6+1,num_2+1
                  04479 			;			u_milers = num / 1000;
000E1C C0A8 F0B8  04480 	MOVFF num_2,arg1_2
000E20 C0A9 F0B9  04481 	MOVFF num_2+1,arg1_2+1
000E24 0EE8       04482 	MOVLW 232
000E26 0100       04483 	MOVLB 0
000E28 6FBA       04484 	MOVWF arg2_2,1
000E2A 0E03       04485 	MOVLW 3
000E2C 6FBB       04486 	MOVWF arg2_2+1,1
000E2E ECD9 F002  04487 	CALL  _divU16_16
000E32 C0B8 F0AA  04488 	MOVFF arg1_2,u_milers_2
000E36 C0B9 F0AB  04489 	MOVFF arg1_2+1,u_milers_2+1
                  04490 			;			dato = num % 1000;
000E3A C0A8 F0B8  04491 	MOVFF num_2,arg1_6
000E3E C0A9 F0B9  04492 	MOVFF num_2+1,arg1_6+1
000E42 0EE8       04493 	MOVLW 232
000E44 0100       04494 	MOVLB 0
000E46 6FBA       04495 	MOVWF arg2_6,1
000E48 0E03       04496 	MOVLW 3
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 76

ADDR   CODE       LINE  SOURCE

000E4A 6FBB       04497 	MOVWF arg2_6+1,1
000E4C EC0B F003  04498 	CALL  _remU16_16
000E50 C0BC F0A6  04499 	MOVFF rm_6,dato_4
000E54 C0BD F0A7  04500 	MOVFF rm_6+1,dato_4+1
                  04501 			;
                  04502 			;			cent   = dato   / 100;   	
000E58 C0A6 F0B8  04503 	MOVFF dato_4,arg1
000E5C C0A7 F0B9  04504 	MOVFF dato_4+1,arg1+1
000E60 0E64       04505 	MOVLW 100
000E62 ECC1 F002  04506 	CALL  _divU16_8
000E66 C0B8 F0AC  04507 	MOVFF arg1,cent_2
000E6A C0B9 F0AD  04508 	MOVFF arg1+1,cent_2+1
                  04509 			;			resto1 = dato   % 100;
000E6E C0A6 F0B8  04510 	MOVFF dato_4,arg1_5
000E72 C0A7 F0B9  04511 	MOVFF dato_4+1,arg1_5+1
000E76 0E64       04512 	MOVLW 100
000E78 ECF4 F002  04513 	CALL  _remU16_8
000E7C 0100       04514 	MOVLB 0
000E7E 6FB2       04515 	MOVWF resto1_2,1
                  04516 			;			dec    = resto1 /  10;  
000E80 C0B2 F0B8  04517 	MOVFF resto1_2,arg1
000E84 6BB9       04518 	CLRF  arg1+1,1
000E86 0E0A       04519 	MOVLW 10
000E88 ECC1 F002  04520 	CALL  _divU16_8
000E8C C0B8 F0B0  04521 	MOVFF arg1,dec_2
                  04522 			;			unid   = resto1 %  10; 		
000E90 C0B2 F0B8  04523 	MOVFF resto1_2,arg1_5
000E94 0100       04524 	MOVLB 0
000E96 6BB9       04525 	CLRF  arg1_5+1,1
000E98 0E0A       04526 	MOVLW 10
000E9A ECF4 F002  04527 	CALL  _remU16_8
000E9E 0100       04528 	MOVLB 0
000EA0 6FB1       04529 	MOVWF unid_2,1
                  04530 			;		// Envio
                  04531 			;		for (xx=0 ; xx < 5; xx++)
000EA2 6BB4       04532 	CLRF  xx_2,1
000EA4 0E05       04533 m165	MOVLW 5
000EA6 0100       04534 	MOVLB 0
000EA8 61B4       04535 	CPFSLT xx_2,1
000EAA D0B1       04536 	BRA   m181
                  04537 			;		{
                  04538 			;			switch(xx){
000EAC 51B4       04539 	MOVF  xx_2,W,1
000EAE B4D8       04540 	BTFSC 0xFD8,Zero_,0
000EB0 D00D       04541 	BRA   m166
000EB2 0A01       04542 	XORLW 1
000EB4 B4D8       04543 	BTFSC 0xFD8,Zero_,0
000EB6 D015       04544 	BRA   m168
000EB8 0A03       04545 	XORLW 3
000EBA B4D8       04546 	BTFSC 0xFD8,Zero_,0
000EBC D021       04547 	BRA   m170
000EBE 0A01       04548 	XORLW 1
000EC0 B4D8       04549 	BTFSC 0xFD8,Zero_,0
000EC2 D031       04550 	BRA   m172
000EC4 0A07       04551 	XORLW 7
000EC6 B4D8       04552 	BTFSC 0xFD8,Zero_,0
000EC8 D044       04553 	BRA   m174
000ECA D045       04554 	BRA   m175
                  04555 			;				case 0:
                  04556 			;					if (d_milers==0) dat = ' '; 
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 77

ADDR   CODE       LINE  SOURCE

000ECC 0100       04557 m166	MOVLB 0
000ECE 51AE       04558 	MOVF  d_milers,W,1
000ED0 11AF       04559 	IORWF d_milers+1,W,1
000ED2 A4D8       04560 	BTFSS 0xFD8,Zero_,0
000ED4 D003       04561 	BRA   m167
000ED6 0E20       04562 	MOVLW 32
000ED8 6FB6       04563 	MOVWF dat_2,1
                  04564 			;					else dat = d_milers;
000EDA D03D       04565 	BRA   m175
000EDC C0AE F0B6  04566 m167	MOVFF d_milers,dat_2
                  04567 			;					break;
000EE0 D03A       04568 	BRA   m175
                  04569 			;				case 1:
                  04570 			;					if ((u_milers==0)&&(d_milers==0)) dat = ' ';
000EE2 0100       04571 m168	MOVLB 0
000EE4 51AA       04572 	MOVF  u_milers_2,W,1
000EE6 11AB       04573 	IORWF u_milers_2+1,W,1
000EE8 A4D8       04574 	BTFSS 0xFD8,Zero_,0
000EEA D007       04575 	BRA   m169
000EEC 51AE       04576 	MOVF  d_milers,W,1
000EEE 11AF       04577 	IORWF d_milers+1,W,1
000EF0 A4D8       04578 	BTFSS 0xFD8,Zero_,0
000EF2 D003       04579 	BRA   m169
000EF4 0E20       04580 	MOVLW 32
000EF6 6FB6       04581 	MOVWF dat_2,1
                  04582 			;					else dat = u_milers;
000EF8 D02E       04583 	BRA   m175
000EFA C0AA F0B6  04584 m169	MOVFF u_milers_2,dat_2
                  04585 			;					break;
000EFE D02B       04586 	BRA   m175
                  04587 			;				case 2:
                  04588 			;					if ((d_milers==0)&&(u_milers==0)&&(cent==0)) dat = ' '; 
000F00 0100       04589 m170	MOVLB 0
000F02 51AE       04590 	MOVF  d_milers,W,1
000F04 11AF       04591 	IORWF d_milers+1,W,1
000F06 A4D8       04592 	BTFSS 0xFD8,Zero_,0
000F08 D00B       04593 	BRA   m171
000F0A 51AA       04594 	MOVF  u_milers_2,W,1
000F0C 11AB       04595 	IORWF u_milers_2+1,W,1
000F0E A4D8       04596 	BTFSS 0xFD8,Zero_,0
000F10 D007       04597 	BRA   m171
000F12 51AC       04598 	MOVF  cent_2,W,1
000F14 11AD       04599 	IORWF cent_2+1,W,1
000F16 A4D8       04600 	BTFSS 0xFD8,Zero_,0
000F18 D003       04601 	BRA   m171
000F1A 0E20       04602 	MOVLW 32
000F1C 6FB6       04603 	MOVWF dat_2,1
                  04604 			;					else dat = cent;
000F1E D01B       04605 	BRA   m175
000F20 C0AC F0B6  04606 m171	MOVFF cent_2,dat_2
                  04607 			;					break;
000F24 D018       04608 	BRA   m175
                  04609 			;				case 3:
                  04610 			;					if ((u_milers==0)&&(cent==0)&&(dec==0)&&(d_milers==0)) dat = ' ';
000F26 0100       04611 m172	MOVLB 0
000F28 51AA       04612 	MOVF  u_milers_2,W,1
000F2A 11AB       04613 	IORWF u_milers_2+1,W,1
000F2C A4D8       04614 	BTFSS 0xFD8,Zero_,0
000F2E D00E       04615 	BRA   m173
000F30 51AC       04616 	MOVF  cent_2,W,1
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 78

ADDR   CODE       LINE  SOURCE

000F32 11AD       04617 	IORWF cent_2+1,W,1
000F34 A4D8       04618 	BTFSS 0xFD8,Zero_,0
000F36 D00A       04619 	BRA   m173
000F38 53B0       04620 	MOVF  dec_2,1,1
000F3A A4D8       04621 	BTFSS 0xFD8,Zero_,0
000F3C D007       04622 	BRA   m173
000F3E 51AE       04623 	MOVF  d_milers,W,1
000F40 11AF       04624 	IORWF d_milers+1,W,1
000F42 A4D8       04625 	BTFSS 0xFD8,Zero_,0
000F44 D003       04626 	BRA   m173
000F46 0E20       04627 	MOVLW 32
000F48 6FB6       04628 	MOVWF dat_2,1
                  04629 			;					else dat = dec ;
000F4A D005       04630 	BRA   m175
000F4C C0B0 F0B6  04631 m173	MOVFF dec_2,dat_2
                  04632 			;					break;
000F50 D002       04633 	BRA   m175
                  04634 			;				case 4:
                  04635 			;					dat = unid;
000F52 C0B1 F0B6  04636 m174	MOVFF unid_2,dat_2
                  04637 			;					break;
                  04638 			;			}		
                  04639 			;			if (dat!=' ') dat = dat + 0x30;
000F56 0100       04640 m175	MOVLB 0
000F58 51B6       04641 	MOVF  dat_2,W,1
000F5A 0A20       04642 	XORLW 32
000F5C B4D8       04643 	BTFSC 0xFD8,Zero_,0
000F5E D002       04644 	BRA   m176
000F60 0E30       04645 	MOVLW 48
000F62 27B6       04646 	ADDWF dat_2,1,1
                  04647 			;			PORTB.3 = dat.4;nop();
000F64 0100       04648 m176	MOVLB 0
000F66 A9B6       04649 	BTFSS dat_2,4,1
000F68 9681       04650 	BCF   PORTB,3,0
000F6A B9B6       04651 	BTFSC dat_2,4,1
000F6C 8681       04652 	BSF   PORTB,3,0
000F6E 0000       04653 	NOP  
                  04654 			;			PORTB.2 = dat.5;nop();
000F70 ABB6       04655 	BTFSS dat_2,5,1
000F72 9481       04656 	BCF   PORTB,2,0
000F74 BBB6       04657 	BTFSC dat_2,5,1
000F76 8481       04658 	BSF   PORTB,2,0
000F78 0000       04659 	NOP  
                  04660 			;			PORTB.1 = dat.6;nop();
000F7A ADB6       04661 	BTFSS dat_2,6,1
000F7C 9281       04662 	BCF   PORTB,1,0
000F7E BDB6       04663 	BTFSC dat_2,6,1
000F80 8281       04664 	BSF   PORTB,1,0
000F82 0000       04665 	NOP  
                  04666 			;			PORTB.0 = dat.7;nop();
000F84 AFB6       04667 	BTFSS dat_2,7,1
000F86 9081       04668 	BCF   PORTB,0,0
000F88 BFB6       04669 	BTFSC dat_2,7,1
000F8A 8081       04670 	BSF   PORTB,0,0
000F8C 0000       04671 	NOP  
                  04672 			;			PORTB.5 = 1;  									// Modo dato.
000F8E 8A81       04673 	BSF   PORTB,5,0
                  04674 			;			retardo_20u ();
000F90 DC04       04675 	RCALL retardo_20u
                  04676 			;			PORTB.4 = 1;  									// Breve pulso.
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 79

ADDR   CODE       LINE  SOURCE

000F92 8881       04677 	BSF   PORTB,4,0
                  04678 			;			retardo_20u ();
000F94 DC02       04679 	RCALL retardo_20u
                  04680 			;			PORTB.4 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
000F96 9881       04681 	BCF   PORTB,4,0
                  04682 			;			for (i = 1; i <= 6; i++) retardo_20u ();
000F98 0E01       04683 	MOVLW 1
000F9A 0100       04684 	MOVLB 0
000F9C 6FB3       04685 	MOVWF i_8,1
000F9E 0E07       04686 m177	MOVLW 7
000FA0 0100       04687 	MOVLB 0
000FA2 61B3       04688 	CPFSLT i_8,1
000FA4 D005       04689 	BRA   m178
000FA6 ECCD F003  04690 	CALL  retardo_20u
000FAA 0100       04691 	MOVLB 0
000FAC 2BB3       04692 	INCF  i_8,1,1
000FAE D7F7       04693 	BRA   m177
                  04694 			;			dat = swap (dat);
000FB0 0100       04695 m178	MOVLB 0
000FB2 3BB6       04696 	SWAPF dat_2,1,1
                  04697 			;			PORTB.3 = dat.4;nop();
000FB4 A9B6       04698 	BTFSS dat_2,4,1
000FB6 9681       04699 	BCF   PORTB,3,0
000FB8 B9B6       04700 	BTFSC dat_2,4,1
000FBA 8681       04701 	BSF   PORTB,3,0
000FBC 0000       04702 	NOP  
                  04703 			;			PORTB.2 = dat.5;nop();
000FBE ABB6       04704 	BTFSS dat_2,5,1
000FC0 9481       04705 	BCF   PORTB,2,0
000FC2 BBB6       04706 	BTFSC dat_2,5,1
000FC4 8481       04707 	BSF   PORTB,2,0
000FC6 0000       04708 	NOP  
                  04709 			;			PORTB.1 = dat.6;nop();
000FC8 ADB6       04710 	BTFSS dat_2,6,1
000FCA 9281       04711 	BCF   PORTB,1,0
000FCC BDB6       04712 	BTFSC dat_2,6,1
000FCE 8281       04713 	BSF   PORTB,1,0
000FD0 0000       04714 	NOP  
                  04715 			;			PORTB.0 = dat.7;
000FD2 AFB6       04716 	BTFSS dat_2,7,1
000FD4 9081       04717 	BCF   PORTB,0,0
000FD6 BFB6       04718 	BTFSC dat_2,7,1
000FD8 8081       04719 	BSF   PORTB,0,0
                  04720 			;			retardo_1m ();
000FDA ECD7 F003  04721 	CALL  retardo_1m
                  04722 			;			PORTB.5 = 1;  									// Modo dato.
000FDE 8A81       04723 	BSF   PORTB,5,0
                  04724 			;			retardo_1m ();
000FE0 ECD7 F003  04725 	CALL  retardo_1m
                  04726 			;			PORTB.4 = 1;  									// Breve pulso.
000FE4 8881       04727 	BSF   PORTB,4,0
                  04728 			;			retardo_20u ();
000FE6 ECCD F003  04729 	CALL  retardo_20u
                  04730 			;			PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
000FEA 9881       04731 	BCF   PORTB,4,0
                  04732 			;			for (i = 1; i<= 6; i++) retardo_20u ();
000FEC 0E01       04733 	MOVLW 1
000FEE 0100       04734 	MOVLB 0
000FF0 6FB3       04735 	MOVWF i_8,1
000FF2 0E07       04736 m179	MOVLW 7
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 80

ADDR   CODE       LINE  SOURCE

000FF4 0100       04737 	MOVLB 0
000FF6 61B3       04738 	CPFSLT i_8,1
000FF8 D005       04739 	BRA   m180
000FFA ECCD F003  04740 	CALL  retardo_20u
000FFE 0100       04741 	MOVLB 0
001000 2BB3       04742 	INCF  i_8,1,1
001002 D7F7       04743 	BRA   m179
                  04744 			;			enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.			
001004 0E0C       04745 m180	MOVLW 12
001006 DC3C       04746 	RCALL enviar_comando
                  04747 			;		}
001008 0100       04748 	MOVLB 0
00100A 2BB4       04749 	INCF  xx_2,1,1
00100C D74B       04750 	BRA   m165
                  04751 			;
                  04752 			;	return;
00100E 0012       04753 m181	RETURN
                  04754 			;
                  04755 			;}
                  04756 			;
                  04757 			;
                  04758 			;
                  04759 			;void Enviar_char(char linea,char columna,char dato){
                  04760 Enviar_char
001010 0100       04761 	MOVLB 0
001012 6FA6       04762 	MOVWF dato_5,1
                  04763 			;	//utilizaremos esta funcion en caso de necesitar un numero entero hasta 65536(16bits)
                  04764 			;	char num, cent;
                  04765 			;	char dec, unid, resto1;
                  04766 			;	char i, xx, yy, dat,xy;
                  04767 			;
                  04768 			;	switch (linea) 									// (se resta una unidad a la coordenada lnea para que la posicin colum
                           na inicial sea 1 y no 0).
001014 51A4       04769 	MOVF  linea_5,W,1
001016 0A01       04770 	XORLW 1
001018 B4D8       04771 	BTFSC 0xFD8,Zero_,0
00101A D00A       04772 	BRA   m182
00101C 0A03       04773 	XORLW 3
00101E B4D8       04774 	BTFSC 0xFD8,Zero_,0
001020 D00C       04775 	BRA   m183
001022 0A01       04776 	XORLW 1
001024 B4D8       04777 	BTFSC 0xFD8,Zero_,0
001026 D00E       04778 	BRA   m184
001028 0A07       04779 	XORLW 7
00102A B4D8       04780 	BTFSC 0xFD8,Zero_,0
00102C D010       04781 	BRA   m185
00102E D016       04782 	BRA   m186
                  04783 			;		{
                  04784 			;			case 1:	enviar_comando (127 + columna); 	// inicio primera linea.
001030 0E7F       04785 m182	MOVLW 127
001032 0100       04786 	MOVLB 0
001034 25A5       04787 	ADDWF columna_4,W,1
001036 DC24       04788 	RCALL enviar_comando
                  04789 			;			break;	
001038 D011       04790 	BRA   m186
                  04791 			;			case 2:	enviar_comando (191 + columna); 	// inicio segunda lnea.
00103A 0EBF       04792 m183	MOVLW 191
00103C 0100       04793 	MOVLB 0
00103E 25A5       04794 	ADDWF columna_4,W,1
001040 DC1F       04795 	RCALL enviar_comando
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 81

ADDR   CODE       LINE  SOURCE

                  04796 			;			break;			
001042 D00C       04797 	BRA   m186
                  04798 			;			case 3:	enviar_comando (147 + columna); 	// inicio tercera lnea (cursor en posicin 20 de la primera lnea).
001044 0E93       04799 m184	MOVLW 147
001046 0100       04800 	MOVLB 0
001048 25A5       04801 	ADDWF columna_4,W,1
00104A DC1A       04802 	RCALL enviar_comando
                  04803 			;			break;				
00104C D007       04804 	BRA   m186
                  04805 			;			case 4:	enviar_comando (211 + columna); 	// inicio cuarta lnea (cursor en posicin 20 de la segunda lnea).
00104E 0ED3       04806 m185	MOVLW 211
001050 0100       04807 	MOVLB 0
001052 25A5       04808 	ADDWF columna_4,W,1
001054 DC15       04809 	RCALL enviar_comando
                  04810 			;			break;	
001056 D002       04811 	BRA   m186
                  04812 			;			enviar_comando (0b.0000.1100);			// pantalla encendida, sin cursor
001058 0E0C       04813 	MOVLW 12
00105A DC12       04814 	RCALL enviar_comando
                  04815 			;		}				
                  04816 			;
                  04817 			;			cent   = dato   / 100;   	
00105C C0A6 F0B8  04818 m186	MOVFF dato_5,arg1
001060 0100       04819 	MOVLB 0
001062 6BB9       04820 	CLRF  arg1+1,1
001064 0E64       04821 	MOVLW 100
001066 ECC1 F002  04822 	CALL  _divU16_8
00106A C0B8 F0A8  04823 	MOVFF arg1,cent_3
                  04824 			;			resto1 = dato   % 100;
00106E C0A6 F0B8  04825 	MOVFF dato_5,arg1_5
001072 0100       04826 	MOVLB 0
001074 6BB9       04827 	CLRF  arg1_5+1,1
001076 0E64       04828 	MOVLW 100
001078 ECF4 F002  04829 	CALL  _remU16_8
00107C 0100       04830 	MOVLB 0
00107E 6FAB       04831 	MOVWF resto1_3,1
                  04832 			;			dec    = resto1 /  10;  
001080 C0AB F0B8  04833 	MOVFF resto1_3,arg1
001084 6BB9       04834 	CLRF  arg1+1,1
001086 0E0A       04835 	MOVLW 10
001088 ECC1 F002  04836 	CALL  _divU16_8
00108C C0B8 F0A9  04837 	MOVFF arg1,dec_3
                  04838 			;			unid   = resto1 %  10; 		
001090 C0AB F0B8  04839 	MOVFF resto1_3,arg1_5
001094 0100       04840 	MOVLB 0
001096 6BB9       04841 	CLRF  arg1_5+1,1
001098 0E0A       04842 	MOVLW 10
00109A ECF4 F002  04843 	CALL  _remU16_8
00109E 0100       04844 	MOVLB 0
0010A0 6FAA       04845 	MOVWF unid_3,1
                  04846 			;		// Envio
                  04847 			;		for (xx=0 ; xx < 3; xx++)
0010A2 6BAD       04848 	CLRF  xx_3,1
0010A4 0E03       04849 m187	MOVLW 3
0010A6 0100       04850 	MOVLB 0
0010A8 61AD       04851 	CPFSLT xx_3,1
0010AA D082       04852 	BRA   m199
                  04853 			;		{
                  04854 			;			switch(xx){
0010AC 51AD       04855 	MOVF  xx_3,W,1
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 82

ADDR   CODE       LINE  SOURCE

0010AE B4D8       04856 	BTFSC 0xFD8,Zero_,0
0010B0 D007       04857 	BRA   m188
0010B2 0A01       04858 	XORLW 1
0010B4 B4D8       04859 	BTFSC 0xFD8,Zero_,0
0010B6 D00E       04860 	BRA   m190
0010B8 0A03       04861 	XORLW 3
0010BA B4D8       04862 	BTFSC 0xFD8,Zero_,0
0010BC D018       04863 	BRA   m192
0010BE D019       04864 	BRA   m193
                  04865 			;				case 0:
                  04866 			;					if (cent==0) dat = ' '; 
0010C0 0100       04867 m188	MOVLB 0
0010C2 53A8       04868 	MOVF  cent_3,1,1
0010C4 A4D8       04869 	BTFSS 0xFD8,Zero_,0
0010C6 D003       04870 	BRA   m189
0010C8 0E20       04871 	MOVLW 32
0010CA 6FAF       04872 	MOVWF dat_3,1
                  04873 			;					else dat = cent;
0010CC D012       04874 	BRA   m193
0010CE C0A8 F0AF  04875 m189	MOVFF cent_3,dat_3
                  04876 			;					break;
0010D2 D00F       04877 	BRA   m193
                  04878 			;				case 1:
                  04879 			;					if ((cent==0)&&(dec==0)) dat = ' ';
0010D4 0100       04880 m190	MOVLB 0
0010D6 53A8       04881 	MOVF  cent_3,1,1
0010D8 A4D8       04882 	BTFSS 0xFD8,Zero_,0
0010DA D006       04883 	BRA   m191
0010DC 53A9       04884 	MOVF  dec_3,1,1
0010DE A4D8       04885 	BTFSS 0xFD8,Zero_,0
0010E0 D003       04886 	BRA   m191
0010E2 0E20       04887 	MOVLW 32
0010E4 6FAF       04888 	MOVWF dat_3,1
                  04889 			;					else dat = dec ;
0010E6 D005       04890 	BRA   m193
0010E8 C0A9 F0AF  04891 m191	MOVFF dec_3,dat_3
                  04892 			;					break;
0010EC D002       04893 	BRA   m193
                  04894 			;				case 2 :
                  04895 			;					dat = unid;
0010EE C0AA F0AF  04896 m192	MOVFF unid_3,dat_3
                  04897 			;					break;
                  04898 			;			}		
                  04899 			;			if (dat!=' ') dat = dat + 0x30;
0010F2 0100       04900 m193	MOVLB 0
0010F4 51AF       04901 	MOVF  dat_3,W,1
0010F6 0A20       04902 	XORLW 32
0010F8 B4D8       04903 	BTFSC 0xFD8,Zero_,0
0010FA D002       04904 	BRA   m194
0010FC 0E30       04905 	MOVLW 48
0010FE 27AF       04906 	ADDWF dat_3,1,1
                  04907 			;			PORTB.3 = dat.4;nop();
001100 0100       04908 m194	MOVLB 0
001102 A9AF       04909 	BTFSS dat_3,4,1
001104 9681       04910 	BCF   PORTB,3,0
001106 B9AF       04911 	BTFSC dat_3,4,1
001108 8681       04912 	BSF   PORTB,3,0
00110A 0000       04913 	NOP  
                  04914 			;			PORTB.2 = dat.5;nop();
00110C ABAF       04915 	BTFSS dat_3,5,1
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 83

ADDR   CODE       LINE  SOURCE

00110E 9481       04916 	BCF   PORTB,2,0
001110 BBAF       04917 	BTFSC dat_3,5,1
001112 8481       04918 	BSF   PORTB,2,0
001114 0000       04919 	NOP  
                  04920 			;			PORTB.1 = dat.6;nop();
001116 ADAF       04921 	BTFSS dat_3,6,1
001118 9281       04922 	BCF   PORTB,1,0
00111A BDAF       04923 	BTFSC dat_3,6,1
00111C 8281       04924 	BSF   PORTB,1,0
00111E 0000       04925 	NOP  
                  04926 			;			PORTB.0 = dat.7;nop();
001120 AFAF       04927 	BTFSS dat_3,7,1
001122 9081       04928 	BCF   PORTB,0,0
001124 BFAF       04929 	BTFSC dat_3,7,1
001126 8081       04930 	BSF   PORTB,0,0
001128 0000       04931 	NOP  
                  04932 			;			PORTB.5 = 1;  									// Modo dato.
00112A 8A81       04933 	BSF   PORTB,5,0
                  04934 			;			retardo_20u ();
00112C ECCD F003  04935 	CALL  retardo_20u
                  04936 			;			PORTB.4 = 1;  									// Breve pulso.
001130 8881       04937 	BSF   PORTB,4,0
                  04938 			;			retardo_20u ();
001132 ECCD F003  04939 	CALL  retardo_20u
                  04940 			;			PORTB.4 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
001136 9881       04941 	BCF   PORTB,4,0
                  04942 			;			for (i = 1; i <= 6; i++) retardo_20u ();
001138 0E01       04943 	MOVLW 1
00113A 0100       04944 	MOVLB 0
00113C 6FAC       04945 	MOVWF i_9,1
00113E 0E07       04946 m195	MOVLW 7
001140 0100       04947 	MOVLB 0
001142 61AC       04948 	CPFSLT i_9,1
001144 D005       04949 	BRA   m196
001146 ECCD F003  04950 	CALL  retardo_20u
00114A 0100       04951 	MOVLB 0
00114C 2BAC       04952 	INCF  i_9,1,1
00114E D7F7       04953 	BRA   m195
                  04954 			;			dat = swap (dat);
001150 0100       04955 m196	MOVLB 0
001152 3BAF       04956 	SWAPF dat_3,1,1
                  04957 			;			PORTB.3 = dat.4;nop();
001154 A9AF       04958 	BTFSS dat_3,4,1
001156 9681       04959 	BCF   PORTB,3,0
001158 B9AF       04960 	BTFSC dat_3,4,1
00115A 8681       04961 	BSF   PORTB,3,0
00115C 0000       04962 	NOP  
                  04963 			;			PORTB.2 = dat.5;nop();
00115E ABAF       04964 	BTFSS dat_3,5,1
001160 9481       04965 	BCF   PORTB,2,0
001162 BBAF       04966 	BTFSC dat_3,5,1
001164 8481       04967 	BSF   PORTB,2,0
001166 0000       04968 	NOP  
                  04969 			;			PORTB.1 = dat.6;nop();
001168 ADAF       04970 	BTFSS dat_3,6,1
00116A 9281       04971 	BCF   PORTB,1,0
00116C BDAF       04972 	BTFSC dat_3,6,1
00116E 8281       04973 	BSF   PORTB,1,0
001170 0000       04974 	NOP  
                  04975 			;			PORTB.0 = dat.7;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 84

ADDR   CODE       LINE  SOURCE

001172 AFAF       04976 	BTFSS dat_3,7,1
001174 9081       04977 	BCF   PORTB,0,0
001176 BFAF       04978 	BTFSC dat_3,7,1
001178 8081       04979 	BSF   PORTB,0,0
                  04980 			;			retardo_1m ();
00117A ECD7 F003  04981 	CALL  retardo_1m
                  04982 			;			PORTB.5 = 1;  									// Modo dato.
00117E 8A81       04983 	BSF   PORTB,5,0
                  04984 			;			retardo_1m ();
001180 ECD7 F003  04985 	CALL  retardo_1m
                  04986 			;			PORTB.4 = 1;  									// Breve pulso.
001184 8881       04987 	BSF   PORTB,4,0
                  04988 			;			retardo_20u ();
001186 ECCD F003  04989 	CALL  retardo_20u
                  04990 			;			PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
00118A 9881       04991 	BCF   PORTB,4,0
                  04992 			;			for (i = 1; i<= 6; i++) retardo_20u ();
00118C 0E01       04993 	MOVLW 1
00118E 0100       04994 	MOVLB 0
001190 6FAC       04995 	MOVWF i_9,1
001192 0E07       04996 m197	MOVLW 7
001194 0100       04997 	MOVLB 0
001196 61AC       04998 	CPFSLT i_9,1
001198 D005       04999 	BRA   m198
00119A ECCD F003  05000 	CALL  retardo_20u
00119E 0100       05001 	MOVLB 0
0011A0 2BAC       05002 	INCF  i_9,1,1
0011A2 D7F7       05003 	BRA   m197
                  05004 			;			enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.			
0011A4 0E0C       05005 m198	MOVLW 12
0011A6 EC40 F004  05006 	CALL  enviar_comando
                  05007 			;		}
0011AA 0100       05008 	MOVLB 0
0011AC 2BAD       05009 	INCF  xx_3,1,1
0011AE D77A       05010 	BRA   m187
                  05011 			;
                  05012 			;	return;
0011B0 0012       05013 m199	RETURN
                  05014 			;
                  05015 			;}
                  05016 			;
                  05017 			;//***********************************************************************************************
                  05018 			;//***********************************************************************************************
                  05019 			;// Definicio caracter especial : PROCES  -> posar x, on volguem el pixel ,pes 16 8 4 2 1  Rtat Hexa
                  05020 			;//                         -  contar pesos ( veure exple, per Ah)              xx   0x0C
                  05021 			;//                             -  de dalt a baix, es el codi a posar          x  x  0x12
                  05022 			;//                                                en el vector.               xxxx  0x1E
                  05023 			;//                   - Al inici cridar funcio per ecriure CGRAM               x  x  0x12
                  05024 			;//                    - Hi caben 8 carac especials de 64 a 120                  x   0x00
                  05025 			;//                       de 8 e 8,  64 , 72, 80, 88, 96,104.112,120             xxx 0x04
                  05026 			;//                   - Despres d'escriure la CGRAM, cal fer un                  x x 0x07
                  05027 			;//                     comando, per no apuntar a la CGRAM                       x x 0x05
                  05028 			;// Per escriure simbol .... fer :   enviar_literal(3);enviar_literal(4);
                  05029 			;//************IMPORTANTE****************************************
                  05030 			;//******Poner despues de inicializar_lcd();*********************
                  05031 			;void RAM_LCD (void)
                  05032 			;{
                  05033 RAM_LCD
                  05034 			;	static const char Carac_1[] = {0x0C,0x10,0x08,0x04,0x1B,0x04,0x04,0x03};//caracter micro 	//escribir_literal(0);
                  05035 			;	static const char Carac_2[] = {0xEE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};	//escribir_literal(1); BAT_FULL
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 85

ADDR   CODE       LINE  SOURCE

                  05036 			;	static const char Carac_3[] = {0xEE,0xFF,0xF1,0xFF,0xFF,0xFF,0xFF,0xFF};	// ""...               BAT_75
                  05037 			;	static const char Carac_4[] = {0xEE,0xFF,0xF1,0xF1,0xFF,0xFF,0xFF,0xFF};					    // BAT_50
                  05038 			;	static const char Carac_5[] = {0xEE,0xFF,0xF1,0xF1,0xF1,0xFF,0xFF,0xFF};					    // BAT_25
                  05039 			;	static const char Carac_6[] = {0xEE,0xFF,0xF1,0xF1,0xF1,0xF1,0xFF,0xFF};					    // BAT_10
                  05040 			;	static const char Carac_7[] = {0xEE,0xFF,0xF1,0xF1,0xF1,0xF1,0xF1,0xFF};					    // BAT_LW
                  05041 			;	static const char Carac_8[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
                  05042 			;	// 1era posicio CGRAM es la 64 , 72, 80, 88, 96,104.112,120
                  05043 			;	char i;
                  05044 			;	
                  05045 			;	enviar_comando (64);// primera posicio del Carac_1, els altres seran consecutius
0011B2 0E40       05046 	MOVLW 64
0011B4 EC40 F004  05047 	CALL  enviar_comando
                  05048 			;	retardo_20u ();
0011B8 ECCD F003  05049 	CALL  retardo_20u
                  05050 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_1[i]); retardo_20u (); retardo_20u ();}
0011BC 0100       05051 	MOVLB 0
0011BE 6B9D       05052 	CLRF  i_10,1
0011C0 0E08       05053 m200	MOVLW 8
0011C2 0100       05054 	MOVLB 0
0011C4 619D       05055 	CPFSLT i_10,1
0011C6 D00D       05056 	BRA   m201
0011C8 0E1A       05057 	MOVLW 26
0011CA 259D       05058 	ADDWF i_10,W,1
0011CC EC70 F00D  05059 	CALL  _const1
0011D0 EC7B F004  05060 	CALL  enviar_literal
0011D4 ECCD F003  05061 	CALL  retardo_20u
0011D8 ECCD F003  05062 	CALL  retardo_20u
0011DC 0100       05063 	MOVLB 0
0011DE 2B9D       05064 	INCF  i_10,1,1
0011E0 D7EF       05065 	BRA   m200
                  05066 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_2[i]); retardo_20u (); retardo_20u ();}
0011E2 0100       05067 m201	MOVLB 0
0011E4 6B9D       05068 	CLRF  i_10,1
0011E6 0E08       05069 m202	MOVLW 8
0011E8 0100       05070 	MOVLB 0
0011EA 619D       05071 	CPFSLT i_10,1
0011EC D00D       05072 	BRA   m203
0011EE 0E22       05073 	MOVLW 34
0011F0 259D       05074 	ADDWF i_10,W,1
0011F2 EC70 F00D  05075 	CALL  _const1
0011F6 EC7B F004  05076 	CALL  enviar_literal
0011FA ECCD F003  05077 	CALL  retardo_20u
0011FE ECCD F003  05078 	CALL  retardo_20u
001202 0100       05079 	MOVLB 0
001204 2B9D       05080 	INCF  i_10,1,1
001206 D7EF       05081 	BRA   m202
                  05082 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_3[i]); retardo_20u (); retardo_20u ();}
001208 0100       05083 m203	MOVLB 0
00120A 6B9D       05084 	CLRF  i_10,1
00120C 0E08       05085 m204	MOVLW 8
00120E 0100       05086 	MOVLB 0
001210 619D       05087 	CPFSLT i_10,1
001212 D00D       05088 	BRA   m205
001214 0E2A       05089 	MOVLW 42
001216 259D       05090 	ADDWF i_10,W,1
001218 EC70 F00D  05091 	CALL  _const1
00121C EC7B F004  05092 	CALL  enviar_literal
001220 ECCD F003  05093 	CALL  retardo_20u
001224 ECCD F003  05094 	CALL  retardo_20u
001228 0100       05095 	MOVLB 0
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 86

ADDR   CODE       LINE  SOURCE

00122A 2B9D       05096 	INCF  i_10,1,1
00122C D7EF       05097 	BRA   m204
                  05098 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_4[i]); retardo_20u (); retardo_20u ();}
00122E 0100       05099 m205	MOVLB 0
001230 6B9D       05100 	CLRF  i_10,1
001232 0E08       05101 m206	MOVLW 8
001234 0100       05102 	MOVLB 0
001236 619D       05103 	CPFSLT i_10,1
001238 D00D       05104 	BRA   m207
00123A 0E32       05105 	MOVLW 50
00123C 259D       05106 	ADDWF i_10,W,1
00123E EC70 F00D  05107 	CALL  _const1
001242 EC7B F004  05108 	CALL  enviar_literal
001246 ECCD F003  05109 	CALL  retardo_20u
00124A ECCD F003  05110 	CALL  retardo_20u
00124E 0100       05111 	MOVLB 0
001250 2B9D       05112 	INCF  i_10,1,1
001252 D7EF       05113 	BRA   m206
                  05114 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_5[i]); retardo_20u (); retardo_20u ();}
001254 0100       05115 m207	MOVLB 0
001256 6B9D       05116 	CLRF  i_10,1
001258 0E08       05117 m208	MOVLW 8
00125A 0100       05118 	MOVLB 0
00125C 619D       05119 	CPFSLT i_10,1
00125E D00D       05120 	BRA   m209
001260 0E3A       05121 	MOVLW 58
001262 259D       05122 	ADDWF i_10,W,1
001264 EC70 F00D  05123 	CALL  _const1
001268 EC7B F004  05124 	CALL  enviar_literal
00126C ECCD F003  05125 	CALL  retardo_20u
001270 ECCD F003  05126 	CALL  retardo_20u
001274 0100       05127 	MOVLB 0
001276 2B9D       05128 	INCF  i_10,1,1
001278 D7EF       05129 	BRA   m208
                  05130 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_6[i]); retardo_20u (); retardo_20u ();}
00127A 0100       05131 m209	MOVLB 0
00127C 6B9D       05132 	CLRF  i_10,1
00127E 0E08       05133 m210	MOVLW 8
001280 0100       05134 	MOVLB 0
001282 619D       05135 	CPFSLT i_10,1
001284 D00D       05136 	BRA   m211
001286 0E42       05137 	MOVLW 66
001288 259D       05138 	ADDWF i_10,W,1
00128A EC70 F00D  05139 	CALL  _const1
00128E EC7B F004  05140 	CALL  enviar_literal
001292 ECCD F003  05141 	CALL  retardo_20u
001296 ECCD F003  05142 	CALL  retardo_20u
00129A 0100       05143 	MOVLB 0
00129C 2B9D       05144 	INCF  i_10,1,1
00129E D7EF       05145 	BRA   m210
                  05146 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_7[i]); retardo_20u (); retardo_20u ();}
0012A0 0100       05147 m211	MOVLB 0
0012A2 6B9D       05148 	CLRF  i_10,1
0012A4 0E08       05149 m212	MOVLW 8
0012A6 0100       05150 	MOVLB 0
0012A8 619D       05151 	CPFSLT i_10,1
0012AA D00D       05152 	BRA   m213
0012AC 0E4A       05153 	MOVLW 74
0012AE 259D       05154 	ADDWF i_10,W,1
0012B0 EC70 F00D  05155 	CALL  _const1
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 87

ADDR   CODE       LINE  SOURCE

0012B4 EC7B F004  05156 	CALL  enviar_literal
0012B8 ECCD F003  05157 	CALL  retardo_20u
0012BC ECCD F003  05158 	CALL  retardo_20u
0012C0 0100       05159 	MOVLB 0
0012C2 2B9D       05160 	INCF  i_10,1,1
0012C4 D7EF       05161 	BRA   m212
                  05162 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_8[i]); retardo_20u (); retardo_20u ();}	
0012C6 0100       05163 m213	MOVLB 0
0012C8 6B9D       05164 	CLRF  i_10,1
0012CA 0E08       05165 m214	MOVLW 8
0012CC 0100       05166 	MOVLB 0
0012CE 619D       05167 	CPFSLT i_10,1
0012D0 D00D       05168 	BRA   m215
0012D2 0E52       05169 	MOVLW 82
0012D4 259D       05170 	ADDWF i_10,W,1
0012D6 EC70 F00D  05171 	CALL  _const1
0012DA EC7B F004  05172 	CALL  enviar_literal
0012DE ECCD F003  05173 	CALL  retardo_20u
0012E2 ECCD F003  05174 	CALL  retardo_20u
0012E6 0100       05175 	MOVLB 0
0012E8 2B9D       05176 	INCF  i_10,1,1
0012EA D7EF       05177 	BRA   m214
                  05178 			;	enviar_comando (0b.0000.0010);
0012EC 0E02       05179 m215	MOVLW 2
0012EE EF40 F004  05180 	GOTO  enviar_comando
                  05181 			;	
                  05182 			;	return;
                  05183 
                  05184   ; FILE medir_18F4XK20.h
                  05185 			;/*función void medir (char, char)
                  05186 			;recibe como parámetros:
                  05187 			;Primer parámetro: el canal A/D a convertir  (0...4,8...13) . Si está fuera del rango, toma 0 por defecto
                  05188 			;Segundo parámetro: solo admite 8 o 10 (bits del resultado). si el parámetro no es 8 o 10,
                  05189 			;interpreta automáticamente a 10.
                  05190 			;Siempre. se configura automáticamente la entrada analógica solicitada. Fosc/32
                  05191 			;Requiere la función retardo_20u()  (en retardos.h)
                  05192 			;resultado: en ADRESH:ADRESL
                  05193 			;*/
                  05194 			;uns16 medir (char canal, char bits)
                  05195 			;{
                  05196 medir
0012F2 0100       05197 	MOVLB 0
0012F4 6FA3       05198 	MOVWF bits,1
                  05199 			;	uns16 resultado;
                  05200 			;	switch (canal)
0012F6 51A2       05201 	MOVF  canal,W,1
0012F8 B4D8       05202 	BTFSC 0xFD8,Zero_,0
0012FA D028       05203 	BRA   m216
0012FC 0A01       05204 	XORLW 1
0012FE B4D8       05205 	BTFSC 0xFD8,Zero_,0
001300 D028       05206 	BRA   m217
001302 0A03       05207 	XORLW 3
001304 B4D8       05208 	BTFSC 0xFD8,Zero_,0
001306 D028       05209 	BRA   m218
001308 0A01       05210 	XORLW 1
00130A B4D8       05211 	BTFSC 0xFD8,Zero_,0
00130C D028       05212 	BRA   m219
00130E 0A07       05213 	XORLW 7
001310 B4D8       05214 	BTFSC 0xFD8,Zero_,0
001312 D028       05215 	BRA   m220
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 88

ADDR   CODE       LINE  SOURCE

001314 0A01       05216 	XORLW 1
001316 B4D8       05217 	BTFSC 0xFD8,Zero_,0
001318 D028       05218 	BRA   m221
00131A 0A03       05219 	XORLW 3
00131C B4D8       05220 	BTFSC 0xFD8,Zero_,0
00131E D028       05221 	BRA   m222
001320 0A01       05222 	XORLW 1
001322 B4D8       05223 	BTFSC 0xFD8,Zero_,0
001324 D028       05224 	BRA   m223
001326 0A0F       05225 	XORLW 15
001328 B4D8       05226 	BTFSC 0xFD8,Zero_,0
00132A D028       05227 	BRA   m224
00132C 0A01       05228 	XORLW 1
00132E B4D8       05229 	BTFSC 0xFD8,Zero_,0
001330 D028       05230 	BRA   m225
001332 0A03       05231 	XORLW 3
001334 B4D8       05232 	BTFSC 0xFD8,Zero_,0
001336 D028       05233 	BRA   m226
001338 0A01       05234 	XORLW 1
00133A B4D8       05235 	BTFSC 0xFD8,Zero_,0
00133C D028       05236 	BRA   m227
00133E 0A07       05237 	XORLW 7
001340 B4D8       05238 	BTFSC 0xFD8,Zero_,0
001342 D028       05239 	BRA   m228
001344 0A01       05240 	XORLW 1
001346 B4D8       05241 	BTFSC 0xFD8,Zero_,0
001348 D028       05242 	BRA   m229
00134A D02A       05243 	BRA   m230
                  05244 			;	{
                  05245 			;		//del 0 al 4, están en el PORTA
                  05246 			;		case 0: 	ADCON0 = 0b.00.0000.01;		break;
00134C 0E01       05247 m216	MOVLW 1
00134E 6EC2       05248 	MOVWF ADCON0,0
001350 D029       05249 	BRA   m231
                  05250 			;		case 1:		ADCON0 = 0b.00.0001.01;		break;
001352 0E05       05251 m217	MOVLW 5
001354 6EC2       05252 	MOVWF ADCON0,0
001356 D026       05253 	BRA   m231
                  05254 			;		case 2:		ADCON0 = 0b.00.0010.01;		break;
001358 0E09       05255 m218	MOVLW 9
00135A 6EC2       05256 	MOVWF ADCON0,0
00135C D023       05257 	BRA   m231
                  05258 			;		case 3:		ADCON0 = 0b.00.0011.01;		break;
00135E 0E0D       05259 m219	MOVLW 13
001360 6EC2       05260 	MOVWF ADCON0,0
001362 D020       05261 	BRA   m231
                  05262 			;		case 4:		ADCON0 = 0b.00.0100.01;		break;
001364 0E11       05263 m220	MOVLW 17
001366 6EC2       05264 	MOVWF ADCON0,0
001368 D01D       05265 	BRA   m231
                  05266 			;		case 5:		ADCON0 = 0b.00.0101.01;		break;
00136A 0E15       05267 m221	MOVLW 21
00136C 6EC2       05268 	MOVWF ADCON0,0
00136E D01A       05269 	BRA   m231
                  05270 			;		case 6:		ADCON0 = 0b.00.0110.01;		break;
001370 0E19       05271 m222	MOVLW 25
001372 6EC2       05272 	MOVWF ADCON0,0
001374 D017       05273 	BRA   m231
                  05274 			;		case 7:		ADCON0 = 0b.00.0111.01;		break;
001376 0E1D       05275 m223	MOVLW 29
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 89

ADDR   CODE       LINE  SOURCE

001378 6EC2       05276 	MOVWF ADCON0,0
00137A D014       05277 	BRA   m231
                  05278 			;		case 8:		ADCON0 = 0b.00.1000.01;		break;
00137C 0E21       05279 m224	MOVLW 33
00137E 6EC2       05280 	MOVWF ADCON0,0
001380 D011       05281 	BRA   m231
                  05282 			;		case 9:		ADCON0 = 0b.00.1001.01;		break;
001382 0E25       05283 m225	MOVLW 37
001384 6EC2       05284 	MOVWF ADCON0,0
001386 D00E       05285 	BRA   m231
                  05286 			;		case 10:	ADCON0 = 0b.00.1010.01;		break;
001388 0E29       05287 m226	MOVLW 41
00138A 6EC2       05288 	MOVWF ADCON0,0
00138C D00B       05289 	BRA   m231
                  05290 			;		case 11:	ADCON0 = 0b.00.1011.01;		break;
00138E 0E2D       05291 m227	MOVLW 45
001390 6EC2       05292 	MOVWF ADCON0,0
001392 D008       05293 	BRA   m231
                  05294 			;		case 12:	ADCON0 = 0b.00.1100.01;		break;
001394 0E31       05295 m228	MOVLW 49
001396 6EC2       05296 	MOVWF ADCON0,0
001398 D005       05297 	BRA   m231
                  05298 			;		case 13:	ADCON0 = 0b.00.1101.01;		break;
00139A 0E35       05299 m229	MOVLW 53
00139C 6EC2       05300 	MOVWF ADCON0,0
00139E D002       05301 	BRA   m231
                  05302 			;		default:	ADCON0 = 0b.00.0000.01;
0013A0 0E01       05303 m230	MOVLW 1
0013A2 6EC2       05304 	MOVWF ADCON0,0
                  05305 			;	}
                  05306 			;	if (bits == 8){ADFM=0;GO = 1;  while(GO);resultado = ADRESH;}
0013A4 0E08       05307 m231	MOVLW 8
0013A6 0100       05308 	MOVLB 0
0013A8 63A3       05309 	CPFSEQ bits,1
0013AA D009       05310 	BRA   m233
0013AC 9EC0       05311 	BCF   0xFC0,ADFM,0
0013AE 82C2       05312 	BSF   0xFC2,GO,0
0013B0 B2C2       05313 m232	BTFSC 0xFC2,GO,0
0013B2 D7FE       05314 	BRA   m232
0013B4 CFC4 F0A4  05315 	MOVFF ADRESH,resultado
0013B8 0100       05316 	MOVLB 0
0013BA 6BA5       05317 	CLRF  resultado+1,1
                  05318 			;	else 		  {ADFM=1;GO = 1;  while(GO);resultado.low8 = ADRESL;resultado.high8 = ADRESH;}
0013BC D008       05319 	BRA   m235
0013BE 8EC0       05320 m233	BSF   0xFC0,ADFM,0
0013C0 82C2       05321 	BSF   0xFC2,GO,0
0013C2 B2C2       05322 m234	BTFSC 0xFC2,GO,0
0013C4 D7FE       05323 	BRA   m234
0013C6 CFC3 F0A4  05324 	MOVFF ADRESL,resultado
0013CA CFC4 F0A5  05325 	MOVFF ADRESH,resultado+1
                  05326 			;   	
                  05327 			;   	return resultado;
0013CE 0100       05328 m235	MOVLB 0
0013D0 51A4       05329 	MOVF  resultado,W,1
0013D2 0012       05330 	RETURN
                  05331 
                  05332   ; FILE ondulador_float.c
                  05333 			;
                  05334 			;
                  05335 			; //**************************************************************************************//
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 90

ADDR   CODE       LINE  SOURCE

                  05336 			; //*******************  I N C L U D E S    Y    F U N C I O N E S ***********************//
                  05337 			; //**************************************************************************************//
                  05338 			;#include "MATH24F.H"
                  05339 			;#include "MATH16.H"
                  05340 			;#include "MATH24LB.H"
                  05341 			;#include "Temporiz_64Mhz.h"
                  05342 			;#include "LCD_4bit.h"
                  05343 			;#include "medir_18F4XK20.h"
                  05344 			;
                  05345 			;
                  05346 			;void configuraPic (void);
                  05347 			;
                  05348 			; //**************************************************************************************//
                  05349 			; //******************** M E N S A J E S   Y   A R R A Y S *******************************//
                  05350 			; //**************************************************************************************//
                  05351 			;
                  05352 			;static const char mensaje1[19] ="ONDULADOR 50HZ  by ";
                  05353 			;static const char mensaje2[3] ="VAC";
                  05354 			;static const char mensaje3[5] ="VMAX:";
                  05355 			;static const char mensaje4[4] ="RAIZ";
                  05356 			;
                  05357 			; //**************************************************************************************//
                  05358 			; //************************  P R O G R A M A   P R I N C I P A L ************************//
                  05359 			; //**************************************************************************************//
                  05360 			;
                  05361 			;void main (void)
                  05362 			;{
                  05363 main
                  05364 			;
                  05365 			;	
                  05366 			;	configuraPic (); 				// Configuramos todos los puertos y PWM
0013D4 DB6B       05367 	RCALL configuraPic
                  05368 			;
                  05369 			;
                  05370 			;	char p,h=0;
0013D6 0100       05371 	MOVLB 0
0013D8 6B6E       05372 	CLRF  h,1
                  05373 			;
                  05374 			;	OSCTUNE=0b.01.000000; //PLL enable 
0013DA 0E40       05375 	MOVLW 64
0013DC 6E9B       05376 	MOVWF OSCTUNE,0
                  05377 			;	
                  05378 			;	RCON = 0b.01111111; //C18 pag 80 i 167  Causes del RESET i IPEN (priority Enabled o no)
0013DE 0E7F       05379 	MOVLW 127
0013E0 6ED0       05380 	MOVWF RCON,0
                  05381 			;	OSCCON    = 0b.0.111.0.0.00;
0013E2 0E70       05382 	MOVLW 112
0013E4 6ED3       05383 	MOVWF OSCCON,0
                  05384 			;
                  05385 			;	inicializar_lcd(); 
0013E6 EC12 F005  05386 	CALL  inicializar_lcd
                  05387 			;	borrar_lcd();
0013EA EC99 F005  05388 	CALL  borrar_lcd
                  05389 			;//	retardo_100m();
                  05390 			;	RAM_LCD();
0013EE DEE1       05391 	RCALL RAM_LCD
                  05392 			;
                  05393 			;	borrar_lcd();
0013F0 EC99 F005  05394 	CALL  borrar_lcd
                  05395 			;	escribir_posicion (1, 1);
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 91

ADDR   CODE       LINE  SOURCE

0013F4 0E01       05396 	MOVLW 1
0013F6 0100       05397 	MOVLB 0
0013F8 6F9D       05398 	MOVWF linea,1
0013FA 0E01       05399 	MOVLW 1
0013FC EC4D F005  05400 	CALL  escribir_posicion
                  05401 			;	
                  05402 			;	//for(p=0;p<19;p++ )enviar_literal(mensaje1[p]);
                  05403 			;	//enviar_literal(LOGO_SC);
                  05404 			;
                  05405 			;	T0CON   = 0b.01000.001; //(PIC 18F4550)	// Equivale junto con INTCON2 al OPTION_REG del 16F88x).							
                           	
001400 0E41       05406 	MOVLW 65
001402 6ED5       05407 	MOVWF T0CON,0
                  05408 			;	INTCON2 = 0b.0000.0100; //(PIC 18F4550)	// Equivale junto con T0CON al OPTION_REG del 16F88x).	
001404 0E04       05409 	MOVLW 4
001406 6EF1       05410 	MOVWF INTCON2,0
                  05411 			;	TMR0IF = 0;   //T0IF = 0; (PIC 16F88x)	// Ponemos el flanco de interrupciones a cero (aun no se ha efectuado ninguna).
001408 94F2       05412 	BCF   0xFF2,TMR0IF,0
                  05413 			;   // w1   =   0;								// Reseteamos la variable índice de la tabla.
                  05414 			;	LATD.0 =0;           
00140A 908C       05415 	BCF   LATD,0,0
                  05416 			;
                  05417 			;	Vmax = 3.0; //2 el pwm maximo en 
00140C 0100       05418 	MOVLB 0
00140E 6BC4       05419 	CLRF  Vmax,1
001410 0E40       05420 	MOVLW 64
001412 6FC5       05421 	MOVWF Vmax+1,1
001414 0E80       05422 	MOVLW 128
001416 6FC6       05423 	MOVWF Vmax+2,1
                  05424 			;
                  05425 			;	INTCON = 0b.0100.0000;				// Interrupciones globales (bit 7) e interrupción por Timer0 (bit 5) activadas.
001418 0E40       05426 	MOVLW 64
00141A 6EF2       05427 	MOVWF INTCON,0
                  05428 			;
                  05429 			;	// COMENÇO AL PAS PER 0, AMB 2 CICLES DE PWM A Ton=0 --> SON 100uS
                  05430 			;	T=0;
00141C 6BC9       05431 	CLRF  T,1
                  05432 			;	ancho_pwm =0; 
00141E 6BC0       05433 	CLRF  ancho_pwm,1
001420 6BC1       05434 	CLRF  ancho_pwm+1,1
                  05435 			;	bUdw=1;	// Començo carregant 0
001422 81BF       05436 	BSF   0xBF,bUdw,1
                  05437 			;	for (p = 1; p <= 6; p ++)  ancho_pwm = rl (ancho_pwm);
001424 0E01       05438 	MOVLW 1
001426 6F6D       05439 	MOVWF p,1
001428 0E07       05440 m236	MOVLW 7
00142A 0100       05441 	MOVLB 0
00142C 616D       05442 	CPFSLT p,1
00142E D004       05443 	BRA   m237
001430 37C0       05444 	RLCF  ancho_pwm,1,1
001432 37C1       05445 	RLCF  ancho_pwm+1,1,1
001434 2B6D       05446 	INCF  p,1,1
001436 D7F8       05447 	BRA   m236
                  05448 			;	CCPR1L = ancho_pwm.high8;
001438 C0C1 FFBE  05449 m237	MOVFF ancho_pwm+1,CCPR1L
                  05450 			;	CCP1CON.5 = ancho_pwm.7;
00143C 0100       05451 	MOVLB 0
00143E AFC0       05452 	BTFSS ancho_pwm,7,1
001440 9ABD       05453 	BCF   CCP1CON,5,0
001442 BFC0       05454 	BTFSC ancho_pwm,7,1
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 92

ADDR   CODE       LINE  SOURCE

001444 8ABD       05455 	BSF   CCP1CON,5,0
                  05456 			;	CCP1CON.4 = ancho_pwm.6; // PWM carregat a 0
001446 ADC0       05457 	BTFSS ancho_pwm,6,1
001448 98BD       05458 	BCF   CCP1CON,4,0
00144A BDC0       05459 	BTFSC ancho_pwm,6,1
00144C 88BD       05460 	BSF   CCP1CON,4,0
                  05461 			;	TMR2IF=0;	
00144E 929E       05462 	BCF   0xF9E,TMR2IF,0
                  05463 			;	TMR2IE=1; 
001450 829D       05464 	BSF   0xF9D,TMR2IE,0
                  05465 			;	TMR2ON  = 1;
001452 84CA       05466 	BSF   0xFCA,TMR2ON,0
                  05467 			;	T++; SENO = sen[T];		
001454 2BC9       05468 	INCF  T,1,1
001456 51C9       05469 	MOVF  T,W,1
001458 DB43       05470 	RCALL _const1
00145A 0100       05471 	MOVLB 0
00145C 6FC7       05472 	MOVWF SENO,1
00145E 6BC8       05473 	CLRF  SENO+1,1
                  05474 			;	ancho_pwm = (uns16)SENO*Vmax; // PREPARO SEGUENT VALOR
001460 C0C7 F0A4  05475 	MOVFF SENO,arg1f24
001464 C0C8 F0A5  05476 	MOVFF SENO+1,arg1f24+1
001468 6BA6       05477 	CLRF  arg1f24+2,1
00146A EC27 F002  05478 	CALL  _int24ToFloat24
00146E C0C4 F0A7  05479 	MOVFF Vmax,arg2f24
001472 C0C5 F0A8  05480 	MOVFF Vmax+1,arg2f24+1
001476 C0C6 F0A9  05481 	MOVFF Vmax+2,arg2f24+2
00147A EC9B F000  05482 	CALL  _fmul24
00147E EC6C F002  05483 	CALL  _float24ToInt24
001482 C0A4 F0C0  05484 	MOVFF rval_3,ancho_pwm
001486 C0A5 F0C1  05485 	MOVFF rval_3+1,ancho_pwm+1
                  05486 			; //**************************************************************************************//
                  05487 			; //*******************  V A R I A B L E S   L O C A L E L E S ***************************//
                  05488 			; //**************************************************************************************//
                  05489 			;	estado=LECTURA_VAC; //empieza por LECTURA_VAC
00148A 0100       05490 	MOVLB 0
00148C 6BCB       05491 	CLRF  estado,1
                  05492 			;	uns8 x;
                  05493 			;	uns8 vac[16],ac;    //variables para guardar temporalmente las arrays
                  05494 			;	uns8 iac[16],ic;
                  05495 			;	char vbat,o=0,vuelta=0; 
00148E 6B93       05496 	CLRF  o,1
001490 6B94       05497 	CLRF  vuelta,1
                  05498 			;	bit lectura=0;
001492 919C       05499 	BCF   0x9C,lectura,1
                  05500 			;	float raiz;
                  05501 			;	uns16 Mac0,Mac1;
                  05502 			;	
                  05503 			;	escribir_posicion (2, 1);
001494 0E02       05504 	MOVLW 2
001496 6F9D       05505 	MOVWF linea,1
001498 0E01       05506 	MOVLW 1
00149A EC4D F005  05507 	CALL  escribir_posicion
                  05508 			; 	//for(p=0; p<3; p++)enviar_literal(mensaje2[p]);
                  05509 			; 	escribir_posicion (4, 1);
00149E 0E04       05510 	MOVLW 4
0014A0 0100       05511 	MOVLB 0
0014A2 6F9D       05512 	MOVWF linea,1
0014A4 0E01       05513 	MOVLW 1
0014A6 EC4D F005  05514 	CALL  escribir_posicion
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 93

ADDR   CODE       LINE  SOURCE

                  05515 			; 	//for(p=0; p<5; p++)enviar_literal(mensaje3[p]);
                  05516 			; 	escribir_posicion (4, 10);
0014AA 0E04       05517 	MOVLW 4
0014AC 0100       05518 	MOVLB 0
0014AE 6F9D       05519 	MOVWF linea,1
0014B0 0E0A       05520 	MOVLW 10
0014B2 EC4D F005  05521 	CALL  escribir_posicion
                  05522 			;	//for(p=0; p<4; p++)enviar_literal(mensaje4[p]);
                  05523 			; 	GIE=1;
0014B6 8EF2       05524 	BSF   0xFF2,GIE,0
                  05525 			;	ADCON1=0b.0000.0000;
0014B8 6AC1       05526 	CLRF  ADCON1,0
                  05527 			;	ADCON2=0b.10.001.110;
0014BA 0E8E       05528 	MOVLW 142
0014BC 6EC0       05529 	MOVWF ADCON2,0
                  05530 			;
                  05531 			; //**************************************************************************************//
                  05532 			; //**************************  B U C L E   I N F I N I T O  *****************************//
                  05533 			; //**************************************************************************************//
                  05534 			;	while (1)       					
                  05535 			;	{
                  05536 			;		switch(estado){
0014BE 0100       05537 m238	MOVLB 0
0014C0 51CB       05538 	MOVF  estado,W,1
0014C2 B4D8       05539 	BTFSC 0xFD8,Zero_,0
0014C4 D00D       05540 	BRA   m239
0014C6 0A01       05541 	XORLW 1
0014C8 B4D8       05542 	BTFSC 0xFD8,Zero_,0
0014CA D0F9       05543 	BRA   m254
0014CC 0A03       05544 	XORLW 3
0014CE B4D8       05545 	BTFSC 0xFD8,Zero_,0
0014D0 D180       05546 	BRA   m257
0014D2 0A01       05547 	XORLW 1
0014D4 B4D8       05548 	BTFSC 0xFD8,Zero_,0
0014D6 D181       05549 	BRA   m258
0014D8 0A07       05550 	XORLW 7
0014DA B4D8       05551 	BTFSC 0xFD8,Zero_,0
0014DC D1ED       05552 	BRA   m267
0014DE D7EF       05553 	BRA   m238
                  05554 			;			case LECTURA_VAC:
                  05555 			;				x=0;
0014E0 0100       05556 m239	MOVLB 0
0014E2 6B6F       05557 	CLRF  x,1
                  05558 			;				if(!lectura){
0014E4 B19C       05559 	BTFSC 0x9C,lectura,1
0014E6 D065       05560 	BRA   m246
                  05561 			;					while(LATD.0==1){   //vmax en LEO_VAC 18V 22k serie 8k2
0014E8 A08C       05562 m240	BTFSS LATD,0,0
0014EA D063       05563 	BRA   m246
                  05564 			;						if (((T == 5)&&((x==0)||(x==7))) || ((T == 10 )&&((x==1)||(x==6))) || ((T == 15)&&((x==2)||(x==5)))||((T ==20)&&
                           ((x==3)||(x==4)))) {
0014EC 0E05       05565 	MOVLW 5
0014EE 0100       05566 	MOVLB 0
0014F0 63C9       05567 	CPFSEQ T,1
0014F2 D007       05568 	BRA   m241
0014F4 536F       05569 	MOVF  x,1,1
0014F6 B4D8       05570 	BTFSC 0xFD8,Zero_,0
0014F8 D025       05571 	BRA   m244
0014FA 516F       05572 	MOVF  x,W,1
0014FC 0A07       05573 	XORLW 7
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 94

ADDR   CODE       LINE  SOURCE

0014FE B4D8       05574 	BTFSC 0xFD8,Zero_,0
001500 D021       05575 	BRA   m244
001502 0E0A       05576 m241	MOVLW 10
001504 0100       05577 	MOVLB 0
001506 63C9       05578 	CPFSEQ T,1
001508 D006       05579 	BRA   m242
00150A 4D6F       05580 	DCFSNZ x,W,1
00150C D01B       05581 	BRA   m244
00150E 516F       05582 	MOVF  x,W,1
001510 0A06       05583 	XORLW 6
001512 B4D8       05584 	BTFSC 0xFD8,Zero_,0
001514 D017       05585 	BRA   m244
001516 0E0F       05586 m242	MOVLW 15
001518 0100       05587 	MOVLB 0
00151A 63C9       05588 	CPFSEQ T,1
00151C D008       05589 	BRA   m243
00151E 516F       05590 	MOVF  x,W,1
001520 0A02       05591 	XORLW 2
001522 B4D8       05592 	BTFSC 0xFD8,Zero_,0
001524 D00F       05593 	BRA   m244
001526 516F       05594 	MOVF  x,W,1
001528 0A05       05595 	XORLW 5
00152A B4D8       05596 	BTFSC 0xFD8,Zero_,0
00152C D00B       05597 	BRA   m244
00152E 0E14       05598 m243	MOVLW 20
001530 0100       05599 	MOVLB 0
001532 63C9       05600 	CPFSEQ T,1
001534 D03B       05601 	BRA   m245
001536 516F       05602 	MOVF  x,W,1
001538 0A03       05603 	XORLW 3
00153A B4D8       05604 	BTFSC 0xFD8,Zero_,0
00153C D003       05605 	BRA   m244
00153E 0E04       05606 	MOVLW 4
001540 636F       05607 	CPFSEQ x,1
001542 D034       05608 	BRA   m245
                  05609 			;						PORTC.3=1;
001544 8682       05610 m244	BSF   PORTC,3,0
                  05611 			;						ac=medir(LEO_VAC,8);
001546 0100       05612 	MOVLB 0
001548 6BA2       05613 	CLRF  canal,1
00154A 0E08       05614 	MOVLW 8
00154C DED2       05615 	RCALL medir
00154E C0A4 F080  05616 	MOVFF resultado,ac
                  05617 			;						ic=medir(LEO_IAC,8);
001552 0E02       05618 	MOVLW 2
001554 0100       05619 	MOVLB 0
001556 6FA2       05620 	MOVWF canal,1
001558 0E08       05621 	MOVLW 8
00155A DECB       05622 	RCALL medir
00155C C0A4 F091  05623 	MOVFF resultado,ic
                  05624 			;						PORTC.3=0;
001560 9682       05625 	BCF   PORTC,3,0
                  05626 			;						vac[x]=127-ac;
001562 6AEA       05627 	CLRF  FSR0+1,0
001564 0E70       05628 	MOVLW 112
001566 0100       05629 	MOVLB 0
001568 256F       05630 	ADDWF x,W,1
00156A 6EE9       05631 	MOVWF FSR0,0
00156C 5180       05632 	MOVF  ac,W,1
00156E 087F       05633 	SUBLW 127
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 95

ADDR   CODE       LINE  SOURCE

001570 6EEF       05634 	MOVWF INDF0,0
                  05635 			;						iac[x]=ic;
001572 6AEA       05636 	CLRF  FSR0+1,0
001574 0E81       05637 	MOVLW 129
001576 256F       05638 	ADDWF x,W,1
001578 6EE9       05639 	MOVWF FSR0,0
00157A C091 FFEF  05640 	MOVFF ic,INDF0
                  05641 			;						x++;	
00157E 2B6F       05642 	INCF  x,1,1
                  05643 			;						if ((T==20&&x==4)) {
001580 0E14       05644 	MOVLW 20
001582 63C9       05645 	CPFSEQ T,1
001584 D013       05646 	BRA   m245
001586 0E04       05647 	MOVLW 4
001588 636F       05648 	CPFSEQ x,1
00158A D010       05649 	BRA   m245
                  05650 			;							retardo_20u();retardo_20u();retardo_20u();retardo_20u();
00158C ECCD F003  05651 	CALL  retardo_20u
001590 ECCD F003  05652 	CALL  retardo_20u
001594 ECCD F003  05653 	CALL  retardo_20u
001598 ECCD F003  05654 	CALL  retardo_20u
                  05655 			;							retardo_20u();retardo_20u();retardo_20u();retardo_20u();}
00159C ECCD F003  05656 	CALL  retardo_20u
0015A0 ECCD F003  05657 	CALL  retardo_20u
0015A4 ECCD F003  05658 	CALL  retardo_20u
0015A8 ECCD F003  05659 	CALL  retardo_20u
                  05660 			;						}	
                  05661 			;						lectura=1;	
0015AC 0100       05662 m245	MOVLB 0
0015AE 819C       05663 	BSF   0x9C,lectura,1
                  05664 			;					}
0015B0 D79B       05665 	BRA   m240
                  05666 			;				}
                  05667 			;				if(lectura){
0015B2 0100       05668 m246	MOVLB 0
0015B4 A19C       05669 	BTFSS 0x9C,lectura,1
0015B6 D07B       05670 	BRA   m253
                  05671 			;					r= Vmax*10; // ponemos aqui para hacerlo efectivo al paso por cero,se intentó en la interrupcion pero daba problemas el
                            compilador
0015B8 C0C4 F0A4  05672 	MOVFF Vmax,arg1f24
0015BC C0C5 F0A5  05673 	MOVFF Vmax+1,arg1f24+1
0015C0 C0C6 F0A6  05674 	MOVFF Vmax+2,arg1f24+2
0015C4 6BA7       05675 	CLRF  arg2f24,1
0015C6 0E20       05676 	MOVLW 32
0015C8 6FA8       05677 	MOVWF arg2f24+1,1
0015CA 0E82       05678 	MOVLW 130
0015CC 6FA9       05679 	MOVWF arg2f24+2,1
0015CE EC9B F000  05680 	CALL  _fmul24
0015D2 EC6C F002  05681 	CALL  _float24ToInt24
0015D6 C0A4 F0C2  05682 	MOVFF rval_3,r
0015DA C0A5 F0C3  05683 	MOVFF rval_3+1,r+1
                  05684 			;					while(LATD.0==0){
0015DE B08C       05685 m247	BTFSC LATD,0,0
0015E0 D066       05686 	BRA   m253
                  05687 			;						if  (((T == 5)&&((x==8)||(x==15))) || ((T == 10 )&&((x==9)||(x==14))) || ((T == 15)&&((x==10)||(x==13)))||((T ==
                           20)&&((x==11)||(x==12)))) {
0015E2 0E05       05688 	MOVLW 5
0015E4 0100       05689 	MOVLB 0
0015E6 63C9       05690 	CPFSEQ T,1
0015E8 D008       05691 	BRA   m248
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 96

ADDR   CODE       LINE  SOURCE

0015EA 516F       05692 	MOVF  x,W,1
0015EC 0A08       05693 	XORLW 8
0015EE B4D8       05694 	BTFSC 0xFD8,Zero_,0
0015F0 D027       05695 	BRA   m251
0015F2 516F       05696 	MOVF  x,W,1
0015F4 0A0F       05697 	XORLW 15
0015F6 B4D8       05698 	BTFSC 0xFD8,Zero_,0
0015F8 D023       05699 	BRA   m251
0015FA 0E0A       05700 m248	MOVLW 10
0015FC 0100       05701 	MOVLB 0
0015FE 63C9       05702 	CPFSEQ T,1
001600 D008       05703 	BRA   m249
001602 516F       05704 	MOVF  x,W,1
001604 0A09       05705 	XORLW 9
001606 B4D8       05706 	BTFSC 0xFD8,Zero_,0
001608 D01B       05707 	BRA   m251
00160A 516F       05708 	MOVF  x,W,1
00160C 0A0E       05709 	XORLW 14
00160E B4D8       05710 	BTFSC 0xFD8,Zero_,0
001610 D017       05711 	BRA   m251
001612 0E0F       05712 m249	MOVLW 15
001614 0100       05713 	MOVLB 0
001616 63C9       05714 	CPFSEQ T,1
001618 D008       05715 	BRA   m250
00161A 516F       05716 	MOVF  x,W,1
00161C 0A0A       05717 	XORLW 10
00161E B4D8       05718 	BTFSC 0xFD8,Zero_,0
001620 D00F       05719 	BRA   m251
001622 516F       05720 	MOVF  x,W,1
001624 0A0D       05721 	XORLW 13
001626 B4D8       05722 	BTFSC 0xFD8,Zero_,0
001628 D00B       05723 	BRA   m251
00162A 0E14       05724 m250	MOVLW 20
00162C 0100       05725 	MOVLB 0
00162E 63C9       05726 	CPFSEQ T,1
001630 D03B       05727 	BRA   m252
001632 516F       05728 	MOVF  x,W,1
001634 0A0B       05729 	XORLW 11
001636 B4D8       05730 	BTFSC 0xFD8,Zero_,0
001638 D003       05731 	BRA   m251
00163A 0E0C       05732 	MOVLW 12
00163C 636F       05733 	CPFSEQ x,1
00163E D034       05734 	BRA   m252
                  05735 			;						PORTC.3=1;
001640 8682       05736 m251	BSF   PORTC,3,0
                  05737 			;						ac=medir(LEO_VAC,8);
001642 0100       05738 	MOVLB 0
001644 6BA2       05739 	CLRF  canal,1
001646 0E08       05740 	MOVLW 8
001648 DE54       05741 	RCALL medir
00164A C0A4 F080  05742 	MOVFF resultado,ac
                  05743 			;						ic=medir(LEO_IAC,8);
00164E 0E02       05744 	MOVLW 2
001650 0100       05745 	MOVLB 0
001652 6FA2       05746 	MOVWF canal,1
001654 0E08       05747 	MOVLW 8
001656 DE4D       05748 	RCALL medir
001658 C0A4 F091  05749 	MOVFF resultado,ic
                  05750 			;						PORTC=0;
00165C 6A82       05751 	CLRF  PORTC,0
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 97

ADDR   CODE       LINE  SOURCE

                  05752 			;						vac[x]=ac-127;
00165E 6AEA       05753 	CLRF  FSR0+1,0
001660 0E70       05754 	MOVLW 112
001662 0100       05755 	MOVLB 0
001664 256F       05756 	ADDWF x,W,1
001666 6EE9       05757 	MOVWF FSR0,0
001668 0E7F       05758 	MOVLW 127
00166A 5D80       05759 	SUBWF ac,W,1
00166C 6EEF       05760 	MOVWF INDF0,0
                  05761 			;						iac[x]=ic;
00166E 6AEA       05762 	CLRF  FSR0+1,0
001670 0E81       05763 	MOVLW 129
001672 256F       05764 	ADDWF x,W,1
001674 6EE9       05765 	MOVWF FSR0,0
001676 C091 FFEF  05766 	MOVFF ic,INDF0
                  05767 			;						x++;	
00167A 2B6F       05768 	INCF  x,1,1
                  05769 			;						if ((T==20&&x==12)) {
00167C 0E14       05770 	MOVLW 20
00167E 63C9       05771 	CPFSEQ T,1
001680 D013       05772 	BRA   m252
001682 0E0C       05773 	MOVLW 12
001684 636F       05774 	CPFSEQ x,1
001686 D010       05775 	BRA   m252
                  05776 			;							retardo_20u();retardo_20u();retardo_20u();retardo_20u();
001688 ECCD F003  05777 	CALL  retardo_20u
00168C ECCD F003  05778 	CALL  retardo_20u
001690 ECCD F003  05779 	CALL  retardo_20u
001694 ECCD F003  05780 	CALL  retardo_20u
                  05781 			;							retardo_20u();retardo_20u();retardo_20u();retardo_20u();}
001698 ECCD F003  05782 	CALL  retardo_20u
00169C ECCD F003  05783 	CALL  retardo_20u
0016A0 ECCD F003  05784 	CALL  retardo_20u
0016A4 ECCD F003  05785 	CALL  retardo_20u
                  05786 			;						}			
                  05787 			;						lectura=0;
0016A8 0100       05788 m252	MOVLB 0
0016AA 919C       05789 	BCF   0x9C,lectura,1
                  05790 			;					}
0016AC D798       05791 	BRA   m247
                  05792 			;				}
                  05793 			;				estado = CALCULOS_VAC;
0016AE 0E01       05794 m253	MOVLW 1
0016B0 0100       05795 	MOVLB 0
0016B2 6FCB       05796 	MOVWF estado,1
                  05797 			;				if(x<=15) estado = LECTURA_VAC;
0016B4 0E10       05798 	MOVLW 16
0016B6 616F       05799 	CPFSLT x,1
0016B8 D702       05800 	BRA   m238
0016BA 6BCB       05801 	CLRF  estado,1
                  05802 			;			break;
0016BC D700       05803 	BRA   m238
                  05804 			;
                  05805 			;			case CALCULOS_VAC:
                  05806 			;
                  05807 			;				Mac0=0;
0016BE 0100       05808 m254	MOVLB 0
0016C0 6B98       05809 	CLRF  Mac0,1
0016C2 6B99       05810 	CLRF  Mac0+1,1
                  05811 			;				for(p=0;p<16;p++){
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 98

ADDR   CODE       LINE  SOURCE

0016C4 6B6D       05812 	CLRF  p,1
0016C6 0E10       05813 m255	MOVLW 16
0016C8 0100       05814 	MOVLB 0
0016CA 616D       05815 	CPFSLT p,1
0016CC D012       05816 	BRA   m256
                  05817 			;					ac=vac[p];
0016CE 6AEA       05818 	CLRF  FSR0+1,0
0016D0 0E70       05819 	MOVLW 112
0016D2 256D       05820 	ADDWF p,W,1
0016D4 6EE9       05821 	MOVWF FSR0,0
0016D6 CFEF F080  05822 	MOVFF INDF0,ac
                  05823 			;					uns16 d =(uns16)ac*ac;
0016DA 5180       05824 	MOVF  ac,W,1
0016DC 0380       05825 	MULWF ac,1
0016DE CFF3 F0A2  05826 	MOVFF PRODL,d_6
0016E2 CFF4 F0A3  05827 	MOVFF PRODH,d_6+1
                  05828 			;					Mac0+=d;
0016E6 51A2       05829 	MOVF  d_6,W,1
0016E8 2798       05830 	ADDWF Mac0,1,1
0016EA 51A3       05831 	MOVF  d_6+1,W,1
0016EC 2399       05832 	ADDWFC Mac0+1,1,1
                  05833 			;				}
0016EE 2B6D       05834 	INCF  p,1,1
0016F0 D7EA       05835 	BRA   m255
                  05836 			;				Mac1=Mac0;
0016F2 C098 F09A  05837 m256	MOVFF Mac0,Mac1
0016F6 C099 F09B  05838 	MOVFF Mac0+1,Mac1+1
                  05839 			;				Mac0/=p;
0016FA C098 F0B8  05840 	MOVFF Mac0,arg1
0016FE C099 F0B9  05841 	MOVFF Mac0+1,arg1+1
001702 0100       05842 	MOVLB 0
001704 516D       05843 	MOVF  p,W,1
001706 ECC1 F002  05844 	CALL  _divU16_8
00170A C0B8 F098  05845 	MOVFF arg1,Mac0
00170E C0B9 F099  05846 	MOVFF arg1+1,Mac0+1
                  05847 			;				raiz= sqrt (Mac0);
001712 C098 F0A4  05848 	MOVFF Mac0,arg1f24
001716 C099 F0A5  05849 	MOVFF Mac0+1,arg1f24+1
00171A 0100       05850 	MOVLB 0
00171C 6BA6       05851 	CLRF  arg1f24+2,1
00171E EC27 F002  05852 	CALL  _int24ToFloat24
001722 EC24 F003  05853 	CALL  sqrt
001726 C0A4 F095  05854 	MOVFF arg1f24,raiz
00172A C0A5 F096  05855 	MOVFF arg1f24+1,raiz+1
00172E C0A6 F097  05856 	MOVFF arg1f24+2,raiz+2
                  05857 			;				float banda=(BANDA_PROPORCINAL*raiz)/6.0;
001732 0100       05858 	MOVLB 0
001734 6BA4       05859 	CLRF  arg1f24,1
001736 0E20       05860 	MOVLW 32
001738 6FA5       05861 	MOVWF arg1f24+1,1
00173A 0E82       05862 	MOVLW 130
00173C 6FA6       05863 	MOVWF arg1f24+2,1
00173E C095 F0A7  05864 	MOVFF raiz,arg2f24
001742 C096 F0A8  05865 	MOVFF raiz+1,arg2f24+1
001746 C097 F0A9  05866 	MOVFF raiz+2,arg2f24+2
00174A EC9B F000  05867 	CALL  _fmul24
00174E 0100       05868 	MOVLB 0
001750 6BA7       05869 	CLRF  arg2f24,1
001752 0E40       05870 	MOVLW 64
001754 6FA8       05871 	MOVWF arg2f24+1,1
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 99

ADDR   CODE       LINE  SOURCE

001756 0E81       05872 	MOVLW 129
001758 6FA9       05873 	MOVWF arg2f24+2,1
00175A ECFF F000  05874 	CALL  _fdiv24
00175E C0A4 F09D  05875 	MOVFF arg1f24,banda
001762 C0A5 F09E  05876 	MOVFF arg1f24+1,banda+1
001766 C0A6 F09F  05877 	MOVFF arg1f24+2,banda+2
                  05878 			;				raiz-=REF_AC;
00176A C095 F0A4  05879 	MOVFF raiz,arg1f24
00176E C096 F0A5  05880 	MOVFF raiz+1,arg1f24+1
001772 C097 F0A6  05881 	MOVFF raiz+2,arg1f24+2
001776 0100       05882 	MOVLB 0
001778 6BA7       05883 	CLRF  arg2f24,1
00177A 0E78       05884 	MOVLW 120
00177C 6FA8       05885 	MOVWF arg2f24+1,1
00177E 0E83       05886 	MOVLW 131
001780 6FA9       05887 	MOVWF arg2f24+2,1
001782 EC20 F002  05888 	CALL  _fsub24
001786 C0A4 F095  05889 	MOVFF arg1f24,raiz
00178A C0A5 F096  05890 	MOVFF arg1f24+1,raiz+1
00178E C0A6 F097  05891 	MOVFF arg1f24+2,raiz+2
                  05892 			;				Vmax=(raiz/banda)*6.0;
001792 C095 F0A4  05893 	MOVFF raiz,arg1f24
001796 C096 F0A5  05894 	MOVFF raiz+1,arg1f24+1
00179A C097 F0A6  05895 	MOVFF raiz+2,arg1f24+2
00179E C09D F0A7  05896 	MOVFF banda,arg2f24
0017A2 C09E F0A8  05897 	MOVFF banda+1,arg2f24+1
0017A6 C09F F0A9  05898 	MOVFF banda+2,arg2f24+2
0017AA ECFF F000  05899 	CALL  _fdiv24
0017AE 0100       05900 	MOVLB 0
0017B0 6BA7       05901 	CLRF  arg2f24,1
0017B2 0E40       05902 	MOVLW 64
0017B4 6FA8       05903 	MOVWF arg2f24+1,1
0017B6 0E81       05904 	MOVLW 129
0017B8 6FA9       05905 	MOVWF arg2f24+2,1
0017BA EC9B F000  05906 	CALL  _fmul24
0017BE C0A4 F0C4  05907 	MOVFF arg1f24,Vmax
0017C2 C0A5 F0C5  05908 	MOVFF arg1f24+1,Vmax+1
0017C6 C0A6 F0C6  05909 	MOVFF arg1f24+2,Vmax+2
                  05910 			;				
                  05911 			;				estado = ENVIO_LCD;// cambiar a CALCULOS_IAC para la version final!!!!
0017CA 0E04       05912 	MOVLW 4
0017CC 0100       05913 	MOVLB 0
0017CE 6FCB       05914 	MOVWF estado,1
                  05915 			;			
                  05916 			;				break;
0017D0 D676       05917 	BRA   m238
                  05918 			;
                  05919 			;			case CALCULOS_IAC:
                  05920 			;			
                  05921 			;				estado = LECTURAS_VARIAS;
0017D2 0E03       05922 m257	MOVLW 3
0017D4 0100       05923 	MOVLB 0
0017D6 6FCB       05924 	MOVWF estado,1
                  05925 			;			break;
0017D8 D672       05926 	BRA   m238
                  05927 			;																///11,5v-->700
                  05928 			;			case LECTURAS_VARIAS:								///11,8v-->728
                  05929 			;				uns16 bat = medir(LEO_BAT,10);				 	///12,0v-->730
0017DA 0E01       05930 m258	MOVLW 1
0017DC 0100       05931 	MOVLB 0
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 100

ADDR   CODE       LINE  SOURCE

0017DE 6FA2       05932 	MOVWF canal,1
0017E0 0E0A       05933 	MOVLW 10
0017E2 DD87       05934 	RCALL medir
0017E4 C0A4 F0A0  05935 	MOVFF resultado,bat
0017E8 C0A5 F0A1  05936 	MOVFF resultado+1,bat+1
                  05937 			;				if (bat>785)				vbat=BATT_FULL;  	///12,3v-->763
0017EC 0E12       05938 	MOVLW 18
0017EE 0100       05939 	MOVLB 0
0017F0 5DA0       05940 	SUBWF bat,W,1
0017F2 0E03       05941 	MOVLW 3
0017F4 59A1       05942 	SUBWFB bat+1,W,1
0017F6 A0D8       05943 	BTFSS 0xFD8,Carry,0
0017F8 D003       05944 	BRA   m259
0017FA 0E01       05945 	MOVLW 1
0017FC 6F92       05946 	MOVWF vbat,1
                  05947 			;				else if((bat>762&&bat<775))	vbat=BATT_75;		///12,5v-->774
0017FE D058       05948 	BRA   m266
001800 0EFB       05949 m259	MOVLW 251
001802 0100       05950 	MOVLB 0
001804 5DA0       05951 	SUBWF bat,W,1
001806 0E02       05952 	MOVLW 2
001808 59A1       05953 	SUBWFB bat+1,W,1
00180A A0D8       05954 	BTFSS 0xFD8,Carry,0
00180C D009       05955 	BRA   m260
00180E 0E07       05956 	MOVLW 7
001810 5DA0       05957 	SUBWF bat,W,1
001812 0E03       05958 	MOVLW 3
001814 59A1       05959 	SUBWFB bat+1,W,1
001816 B0D8       05960 	BTFSC 0xFD8,Carry,0
001818 D003       05961 	BRA   m260
00181A 0E02       05962 	MOVLW 2
00181C 6F92       05963 	MOVWF vbat,1
                  05964 			;				else if((bat>742&&bat<760)) vbat=BATT_50;		///12,8v-->794
00181E D048       05965 	BRA   m266
001820 0EE7       05966 m260	MOVLW 231
001822 0100       05967 	MOVLB 0
001824 5DA0       05968 	SUBWF bat,W,1
001826 0E02       05969 	MOVLW 2
001828 59A1       05970 	SUBWFB bat+1,W,1
00182A A0D8       05971 	BTFSS 0xFD8,Carry,0
00182C D009       05972 	BRA   m261
00182E 0EF8       05973 	MOVLW 248
001830 5DA0       05974 	SUBWF bat,W,1
001832 0E02       05975 	MOVLW 2
001834 59A1       05976 	SUBWFB bat+1,W,1
001836 B0D8       05977 	BTFSC 0xFD8,Carry,0
001838 D003       05978 	BRA   m261
00183A 0E03       05979 	MOVLW 3
00183C 6F92       05980 	MOVWF vbat,1
                  05981 			;				else if((bat>722&&bat<740)) vbat=BATT_25;		///13,0v-->804
00183E D038       05982 	BRA   m266
001840 0ED3       05983 m261	MOVLW 211
001842 0100       05984 	MOVLB 0
001844 5DA0       05985 	SUBWF bat,W,1
001846 0E02       05986 	MOVLW 2
001848 59A1       05987 	SUBWFB bat+1,W,1
00184A A0D8       05988 	BTFSS 0xFD8,Carry,0
00184C D009       05989 	BRA   m262
00184E 0EE4       05990 	MOVLW 228
001850 5DA0       05991 	SUBWF bat,W,1
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 101

ADDR   CODE       LINE  SOURCE

001852 0E02       05992 	MOVLW 2
001854 59A1       05993 	SUBWFB bat+1,W,1
001856 B0D8       05994 	BTFSC 0xFD8,Carry,0
001858 D003       05995 	BRA   m262
00185A 0E04       05996 	MOVLW 4
00185C 6F92       05997 	MOVWF vbat,1
                  05998 			;				else if((bat>710&&bat<720)) vbat=BATT_10;		///13,5v-->837
00185E D028       05999 	BRA   m266
001860 0EC7       06000 m262	MOVLW 199
001862 0100       06001 	MOVLB 0
001864 5DA0       06002 	SUBWF bat,W,1
001866 0E02       06003 	MOVLW 2
001868 59A1       06004 	SUBWFB bat+1,W,1
00186A A0D8       06005 	BTFSS 0xFD8,Carry,0
00186C D009       06006 	BRA   m263
00186E 0ED0       06007 	MOVLW 208
001870 5DA0       06008 	SUBWF bat,W,1
001872 0E02       06009 	MOVLW 2
001874 59A1       06010 	SUBWFB bat+1,W,1
001876 B0D8       06011 	BTFSC 0xFD8,Carry,0
001878 D003       06012 	BRA   m263
00187A 0E05       06013 	MOVLW 5
00187C 6F92       06014 	MOVWF vbat,1
                  06015 			;				else if(bat<=708){								///14,0v-->872
00187E D018       06016 	BRA   m266
001880 0EC5       06017 m263	MOVLW 197
001882 0100       06018 	MOVLB 0
001884 5DA0       06019 	SUBWF bat,W,1
001886 0E02       06020 	MOVLW 2
001888 59A1       06021 	SUBWFB bat+1,W,1
00188A B0D8       06022 	BTFSC 0xFD8,Carry,0
00188C D011       06023 	BRA   m266
                  06024 			;					o++;										///14,5v-->895
00188E 2B93       06025 	INCF  o,1,1
                  06026 			;					if(o<=5)vbat=BATT_LW;						///15,0v-->946
001890 0E06       06027 	MOVLW 6
001892 6193       06028 	CPFSLT o,1
001894 D002       06029 	BRA   m264
001896 0E06       06030 	MOVLW 6
001898 6F92       06031 	MOVWF vbat,1
                  06032 			;					if(o>6)vbat=BATT_CLEAR;
00189A 0E06       06033 m264	MOVLW 6
00189C 0100       06034 	MOVLB 0
00189E 6593       06035 	CPFSGT o,1
0018A0 D002       06036 	BRA   m265
0018A2 0E07       06037 	MOVLW 7
0018A4 6F92       06038 	MOVWF vbat,1
                  06039 			;					if(o==10)o=0;
0018A6 0E0A       06040 m265	MOVLW 10
0018A8 0100       06041 	MOVLB 0
0018AA 6393       06042 	CPFSEQ o,1
0018AC D001       06043 	BRA   m266
0018AE 6B93       06044 	CLRF  o,1
                  06045 			;				} 			
                  06046 			;				estado= ENVIO_LCD;
0018B0 0E04       06047 m266	MOVLW 4
0018B2 0100       06048 	MOVLB 0
0018B4 6FCB       06049 	MOVWF estado,1
                  06050 			;			break;
0018B6 D603       06051 	BRA   m238
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 102

ADDR   CODE       LINE  SOURCE

                  06052 			;
                  06053 			;			case ENVIO_LCD:
                  06054 			;				//puesto así para tener más velocidad en el bucle principal!!
                  06055 			;				switch (vuelta){
0018B8 0100       06056 m267	MOVLB 0
0018BA 5194       06057 	MOVF  vuelta,W,1
0018BC B4D8       06058 	BTFSC 0xFD8,Zero_,0
0018BE D034       06059 	BRA   m268
0018C0 0A01       06060 	XORLW 1
0018C2 B4D8       06061 	BTFSC 0xFD8,Zero_,0
0018C4 D03A       06062 	BRA   m269
0018C6 0A03       06063 	XORLW 3
0018C8 B4D8       06064 	BTFSC 0xFD8,Zero_,0
0018CA D040       06065 	BRA   m270
0018CC 0A01       06066 	XORLW 1
0018CE B4D8       06067 	BTFSC 0xFD8,Zero_,0
0018D0 D046       06068 	BRA   m271
0018D2 0A07       06069 	XORLW 7
0018D4 B4D8       06070 	BTFSC 0xFD8,Zero_,0
0018D6 D04C       06071 	BRA   m272
0018D8 0A01       06072 	XORLW 1
0018DA B4D8       06073 	BTFSC 0xFD8,Zero_,0
0018DC D052       06074 	BRA   m273
0018DE 0A03       06075 	XORLW 3
0018E0 B4D8       06076 	BTFSC 0xFD8,Zero_,0
0018E2 D058       06077 	BRA   m274
0018E4 0A01       06078 	XORLW 1
0018E6 B4D8       06079 	BTFSC 0xFD8,Zero_,0
0018E8 D05E       06080 	BRA   m275
0018EA 0A0F       06081 	XORLW 15
0018EC B4D8       06082 	BTFSC 0xFD8,Zero_,0
0018EE D064       06083 	BRA   m276
0018F0 0A01       06084 	XORLW 1
0018F2 B4D8       06085 	BTFSC 0xFD8,Zero_,0
0018F4 D06A       06086 	BRA   m277
0018F6 0A03       06087 	XORLW 3
0018F8 B4D8       06088 	BTFSC 0xFD8,Zero_,0
0018FA D070       06089 	BRA   m278
0018FC 0A01       06090 	XORLW 1
0018FE B4D8       06091 	BTFSC 0xFD8,Zero_,0
001900 D076       06092 	BRA   m279
001902 0A07       06093 	XORLW 7
001904 B4D8       06094 	BTFSC 0xFD8,Zero_,0
001906 D07C       06095 	BRA   m280
001908 0A01       06096 	XORLW 1
00190A B4D8       06097 	BTFSC 0xFD8,Zero_,0
00190C D082       06098 	BRA   m281
00190E 0A03       06099 	XORLW 3
001910 B4D8       06100 	BTFSC 0xFD8,Zero_,0
001912 D088       06101 	BRA   m282
001914 0A01       06102 	XORLW 1
001916 B4D8       06103 	BTFSC 0xFD8,Zero_,0
001918 D08E       06104 	BRA   m283
00191A 0A1F       06105 	XORLW 31
00191C B4D8       06106 	BTFSC 0xFD8,Zero_,0
00191E D094       06107 	BRA   m284
001920 0A01       06108 	XORLW 1
001922 B4D8       06109 	BTFSC 0xFD8,Zero_,0
001924 D0AF       06110 	BRA   m285
001926 D0B9       06111 	BRA   m286
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 103

ADDR   CODE       LINE  SOURCE

                  06112 			;					case 0:
                  06113 			;						Enviar_char(2,1,vac[0]);
001928 0E02       06114 m268	MOVLW 2
00192A 0100       06115 	MOVLB 0
00192C 6FA4       06116 	MOVWF linea_5,1
00192E 0E01       06117 	MOVLW 1
001930 6FA5       06118 	MOVWF columna_4,1
001932 5170       06119 	MOVF  vac,W,1
001934 EC08 F008  06120 	CALL  Enviar_char
                  06121 			;					break;
001938 D0B0       06122 	BRA   m286
                  06123 			;					case 1:
                  06124 			;						Enviar_char(2,5,vac[1]);
00193A 0E02       06125 m269	MOVLW 2
00193C 0100       06126 	MOVLB 0
00193E 6FA4       06127 	MOVWF linea_5,1
001940 0E05       06128 	MOVLW 5
001942 6FA5       06129 	MOVWF columna_4,1
001944 5171       06130 	MOVF  vac+1,W,1
001946 EC08 F008  06131 	CALL  Enviar_char
                  06132 			;					break;
00194A D0A7       06133 	BRA   m286
                  06134 			;					case 2:
                  06135 			;						Enviar_char(2,9,vac[2]);
00194C 0E02       06136 m270	MOVLW 2
00194E 0100       06137 	MOVLB 0
001950 6FA4       06138 	MOVWF linea_5,1
001952 0E09       06139 	MOVLW 9
001954 6FA5       06140 	MOVWF columna_4,1
001956 5172       06141 	MOVF  vac+2,W,1
001958 EC08 F008  06142 	CALL  Enviar_char
                  06143 			;					break;
00195C D09E       06144 	BRA   m286
                  06145 			;					case 3:
                  06146 			;						Enviar_char(2,13,vac[3]);
00195E 0E02       06147 m271	MOVLW 2
001960 0100       06148 	MOVLB 0
001962 6FA4       06149 	MOVWF linea_5,1
001964 0E0D       06150 	MOVLW 13
001966 6FA5       06151 	MOVWF columna_4,1
001968 5173       06152 	MOVF  vac+3,W,1
00196A EC08 F008  06153 	CALL  Enviar_char
                  06154 			;					break;
00196E D095       06155 	BRA   m286
                  06156 			;					case 4:
                  06157 			;						Enviar_char(2,17,vac[4]);
001970 0E02       06158 m272	MOVLW 2
001972 0100       06159 	MOVLB 0
001974 6FA4       06160 	MOVWF linea_5,1
001976 0E11       06161 	MOVLW 17
001978 6FA5       06162 	MOVWF columna_4,1
00197A 5174       06163 	MOVF  vac+4,W,1
00197C EC08 F008  06164 	CALL  Enviar_char
                  06165 			;					break;
001980 D08C       06166 	BRA   m286
                  06167 			;					case 5:
                  06168 			;						Enviar_char(3,1,vac[5]);
001982 0E03       06169 m273	MOVLW 3
001984 0100       06170 	MOVLB 0
001986 6FA4       06171 	MOVWF linea_5,1
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 104

ADDR   CODE       LINE  SOURCE

001988 0E01       06172 	MOVLW 1
00198A 6FA5       06173 	MOVWF columna_4,1
00198C 5175       06174 	MOVF  vac+5,W,1
00198E EC08 F008  06175 	CALL  Enviar_char
                  06176 			;					break;
001992 D083       06177 	BRA   m286
                  06178 			;					case 6:
                  06179 			;						Enviar_char(3,5,vac[6]);
001994 0E03       06180 m274	MOVLW 3
001996 0100       06181 	MOVLB 0
001998 6FA4       06182 	MOVWF linea_5,1
00199A 0E05       06183 	MOVLW 5
00199C 6FA5       06184 	MOVWF columna_4,1
00199E 5176       06185 	MOVF  vac+6,W,1
0019A0 EC08 F008  06186 	CALL  Enviar_char
                  06187 			;					break;
0019A4 D07A       06188 	BRA   m286
                  06189 			;					case 7:
                  06190 			;						Enviar_char(3,9,vac[7]);
0019A6 0E03       06191 m275	MOVLW 3
0019A8 0100       06192 	MOVLB 0
0019AA 6FA4       06193 	MOVWF linea_5,1
0019AC 0E09       06194 	MOVLW 9
0019AE 6FA5       06195 	MOVWF columna_4,1
0019B0 5177       06196 	MOVF  vac+7,W,1
0019B2 EC08 F008  06197 	CALL  Enviar_char
                  06198 			;					break;
0019B6 D071       06199 	BRA   m286
                  06200 			;					case 8:
                  06201 			;						Enviar_char(3,13,vac[8]);
0019B8 0E03       06202 m276	MOVLW 3
0019BA 0100       06203 	MOVLB 0
0019BC 6FA4       06204 	MOVWF linea_5,1
0019BE 0E0D       06205 	MOVLW 13
0019C0 6FA5       06206 	MOVWF columna_4,1
0019C2 5178       06207 	MOVF  vac+8,W,1
0019C4 EC08 F008  06208 	CALL  Enviar_char
                  06209 			;					break;
0019C8 D068       06210 	BRA   m286
                  06211 			;					case 9:
                  06212 			;						Enviar_char(3,17,vac[9]);
0019CA 0E03       06213 m277	MOVLW 3
0019CC 0100       06214 	MOVLB 0
0019CE 6FA4       06215 	MOVWF linea_5,1
0019D0 0E11       06216 	MOVLW 17
0019D2 6FA5       06217 	MOVWF columna_4,1
0019D4 5179       06218 	MOVF  vac+9,W,1
0019D6 EC08 F008  06219 	CALL  Enviar_char
                  06220 			;					break;
0019DA D05F       06221 	BRA   m286
                  06222 			;					case 10:
                  06223 			;						Enviar_char(4,1,vac[10]);
0019DC 0E04       06224 m278	MOVLW 4
0019DE 0100       06225 	MOVLB 0
0019E0 6FA4       06226 	MOVWF linea_5,1
0019E2 0E01       06227 	MOVLW 1
0019E4 6FA5       06228 	MOVWF columna_4,1
0019E6 517A       06229 	MOVF  vac+10,W,1
0019E8 EC08 F008  06230 	CALL  Enviar_char
                  06231 			;					break;
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 105

ADDR   CODE       LINE  SOURCE

0019EC D056       06232 	BRA   m286
                  06233 			;					case 11:
                  06234 			;						Enviar_char(4,5,vac[11]);
0019EE 0E04       06235 m279	MOVLW 4
0019F0 0100       06236 	MOVLB 0
0019F2 6FA4       06237 	MOVWF linea_5,1
0019F4 0E05       06238 	MOVLW 5
0019F6 6FA5       06239 	MOVWF columna_4,1
0019F8 517B       06240 	MOVF  vac+11,W,1
0019FA EC08 F008  06241 	CALL  Enviar_char
                  06242 			;					break;
0019FE D04D       06243 	BRA   m286
                  06244 			;					case 12:
                  06245 			;						Enviar_char(4,9,vac[12]);
001A00 0E04       06246 m280	MOVLW 4
001A02 0100       06247 	MOVLB 0
001A04 6FA4       06248 	MOVWF linea_5,1
001A06 0E09       06249 	MOVLW 9
001A08 6FA5       06250 	MOVWF columna_4,1
001A0A 517C       06251 	MOVF  vac+12,W,1
001A0C EC08 F008  06252 	CALL  Enviar_char
                  06253 			;					break;
001A10 D044       06254 	BRA   m286
                  06255 			;					case 13:
                  06256 			;						Enviar_char(4,13,vac[13]);
001A12 0E04       06257 m281	MOVLW 4
001A14 0100       06258 	MOVLB 0
001A16 6FA4       06259 	MOVWF linea_5,1
001A18 0E0D       06260 	MOVLW 13
001A1A 6FA5       06261 	MOVWF columna_4,1
001A1C 517D       06262 	MOVF  vac+13,W,1
001A1E EC08 F008  06263 	CALL  Enviar_char
                  06264 			;					break;
001A22 D03B       06265 	BRA   m286
                  06266 			;					case 14:
                  06267 			;						Enviar_char(4,17,vac[14]);
001A24 0E04       06268 m282	MOVLW 4
001A26 0100       06269 	MOVLB 0
001A28 6FA4       06270 	MOVWF linea_5,1
001A2A 0E11       06271 	MOVLW 17
001A2C 6FA5       06272 	MOVWF columna_4,1
001A2E 517E       06273 	MOVF  vac+14,W,1
001A30 EC08 F008  06274 	CALL  Enviar_char
                  06275 			;					break;
001A34 D032       06276 	BRA   m286
                  06277 			;					case 15:
                  06278 			;						Enviar_char(1,1,vac[15]);
001A36 0E01       06279 m283	MOVLW 1
001A38 0100       06280 	MOVLB 0
001A3A 6FA4       06281 	MOVWF linea_5,1
001A3C 0E01       06282 	MOVLW 1
001A3E 6FA5       06283 	MOVWF columna_4,1
001A40 517F       06284 	MOVF  vac+15,W,1
001A42 EC08 F008  06285 	CALL  Enviar_char
                  06286 			;					break;
001A46 D029       06287 	BRA   m286
                  06288 			;					case 16:
                  06289 			;						uns16 q = (uns16)raiz*10;
001A48 C095 F0A4  06290 m284	MOVFF raiz,arg1f24
001A4C C096 F0A5  06291 	MOVFF raiz+1,arg1f24+1
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 106

ADDR   CODE       LINE  SOURCE

001A50 C097 F0A6  06292 	MOVFF raiz+2,arg1f24+2
001A54 EC6C F002  06293 	CALL  _float24ToInt24
001A58 0E0A       06294 	MOVLW 10
001A5A 0100       06295 	MOVLB 0
001A5C 03A4       06296 	MULWF rval_3,1
001A5E CFF3 F0A2  06297 	MOVFF PRODL,q
001A62 CFF4 F0A3  06298 	MOVFF PRODH,q+1
001A66 0E0A       06299 	MOVLW 10
001A68 03A5       06300 	MULWF rval_3+1,1
001A6A 50F3       06301 	MOVF  PRODL,W,0
001A6C 27A3       06302 	ADDWF q+1,1,1
                  06303 			;						Enviar_uns16(1,15, q);
001A6E 0E01       06304 	MOVLW 1
001A70 6FA4       06305 	MOVWF linea_4,1
001A72 0E0F       06306 	MOVLW 15
001A74 6FA5       06307 	MOVWF columna_3,1
001A76 C0A2 F0A6  06308 	MOVFF q,dato_4
001A7A C0A3 F0A7  06309 	MOVFF q+1,dato_4+1
001A7E ECC8 F006  06310 	CALL  Enviar_uns16
                  06311 			;					break;
001A82 D00B       06312 	BRA   m286
                  06313 			;					case 17:
                  06314 			;						Enviar_uns16(1,5,Mac1);
001A84 0E01       06315 m285	MOVLW 1
001A86 0100       06316 	MOVLB 0
001A88 6FA4       06317 	MOVWF linea_4,1
001A8A 0E05       06318 	MOVLW 5
001A8C 6FA5       06319 	MOVWF columna_3,1
001A8E C09A F0A6  06320 	MOVFF Mac1,dato_4
001A92 C09B F0A7  06321 	MOVFF Mac1+1,dato_4+1
001A96 ECC8 F006  06322 	CALL  Enviar_uns16
                  06323 			;					break;
                  06324 			;				}
                  06325 			;				vuelta++;
001A9A 0100       06326 m286	MOVLB 0
001A9C 2B94       06327 	INCF  vuelta,1,1
                  06328 			;				if(vuelta==18)vuelta=0;
001A9E 0E12       06329 	MOVLW 18
001AA0 6394       06330 	CPFSEQ vuelta,1
001AA2 D001       06331 	BRA   m287
001AA4 6B94       06332 	CLRF  vuelta,1
                  06333 			;				estado = LECTURA_VAC;
001AA6 0100       06334 m287	MOVLB 0
001AA8 6BCB       06335 	CLRF  estado,1
                  06336 			;			break;
001AAA D509       06337 	BRA   m238
                  06338 			;
                  06339 			;		}
                  06340 			;	}	
                  06341 			;}
                  06342 			;
                  06343 			;
                  06344 			; //**************************************************************************************//
                  06345 			; //************************ F U N C I O N E S    V A R I A S ****************************//
                  06346 			; //**************************************************************************************//
                  06347 			;			
                  06348 			;void configuraPic (void)					
                  06349 			;{
                  06350 configuraPic
                  06351 			;	GIE = 0;						// Desactivamos inicialmente todas las interrupciones.
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 107

ADDR   CODE       LINE  SOURCE

001AAC 9EF2       06352 	BCF   0xFF2,GIE,0
                  06353 			;
                  06354 			;	OSCTUNE=0b.01.000000; //PLL enable 
001AAE 0E40       06355 	MOVLW 64
001AB0 6E9B       06356 	MOVWF OSCTUNE,0
                  06357 			;	
                  06358 			;	RCON = 0b.01111111; //C18 pag 80 i 167  Causes del RESET i IPEN (priority Enabled o no)
001AB2 0E7F       06359 	MOVLW 127
001AB4 6ED0       06360 	MOVWF RCON,0
                  06361 			;	OSCCON    = 0b.0.111.0.0.00;//C18 pag 53  //=============== ULL b3 abans 0 
001AB6 0E70       06362 	MOVLW 112
001AB8 6ED3       06363 	MOVWF OSCCON,0
                  06364 			;	
                  06365 			;	ANSEL  = 0b.0000.0111;					// Solo el canal AN0 será entrada analógica, el resto serán entradas/salidas digitales.(PIC 8
                           16F87)
001ABA 0E07       06366 	MOVLW 7
001ABC 6E7E       06367 	MOVWF ANSEL,0
                  06368 			;	//ANSELH = 0b.0000.0000;				// Solo el canal AN0 será entrada analógica, el resto serán entradas/salidas digitales.(PIC 8
                           16F87)
                  06369 			;	
                  06370 			;	TRISA  = 0b.0000.1111;					// PORTA.0 es entrada, el resto son salidas.
001ABE 0E0F       06371 	MOVLW 15
001AC0 6E92       06372 	MOVWF TRISA,0
                  06373 			;	TRISB  = 0b.0000.0000;					// PORTB todo salidas.
001AC2 6A93       06374 	CLRF  TRISB,0
                  06375 			;	TRISC  = 0b.0000.0000;					// PORTC todo salidas además de la salida del PWM.
001AC4 6A94       06376 	CLRF  TRISC,0
                  06377 			;	TRISD  = 0b.0000.0000;					// PORTD todo salidas.				
001AC6 6A95       06378 	CLRF  TRISD,0
                  06379 			;	LATB  = 0x00;							// Inicializa las salidas de PORTB a 0.
001AC8 6A8A       06380 	CLRF  LATB,0
                  06381 			;	PORTC  = 0x00;							// Inicializa las salidas de PORTC a 0.
001ACA 6A82       06382 	CLRF  PORTC,0
                  06383 			;	PORTD  = 0x00;							// Inicializa las salidas de PORTD a 0.
001ACC 6A83       06384 	CLRF  PORTD,0
                  06385 			;
                  06386 			;	//configuro ccp y pwm
                  06387 			;
                  06388 			;
                  06389 			;	T2CON   = 0b.0.0001.0.01;				// Prescaler P1 = 4, TMR2ON = 1 cuenta;	
001ACE 0E09       06390 	MOVLW 9
001AD0 6ECA       06391 	MOVWF T2CON,0
                  06392 			;	PR2     = 199;
001AD2 0EC7       06393 	MOVLW 199
001AD4 6ECB       06394 	MOVWF PR2,0
                  06395 			;	CCP1CON = 0b.1000.1100;					// CCP1: modo PWM half bridge con bits de CCPR1L a 00 inicialmente.
001AD6 0E8C       06396 	MOVLW 140
001AD8 6EBD       06397 	MOVWF CCP1CON,0
                  06398 			;
                  06399 			;	PWM1CON =0b.0000.0100; //tiempo muerto entre P1A y P1B
001ADA 0E04       06400 	MOVLW 4
001ADC 6EB7       06401 	MOVWF PWM1CON,0
001ADE 0012       06402 	RETURN
                  06403 _const1
001AE0 0100       06404 	MOVLB 0
001AE2 6F69       06405 	MOVWF ci,1
001AE4 5169       06406 	MOVF  ci,W,1
001AE6 0FF8       06407 	ADDLW 248
001AE8 6EF6       06408 	MOVWF TBLPTR,0
001AEA 0E1A       06409 	MOVLW 26
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 108

ADDR   CODE       LINE  SOURCE

001AEC 6AF7       06410 	CLRF  TBLPTR+1,0
001AEE 22F7       06411 	ADDWFC TBLPTR+1,1,0
001AF0 6AF8       06412 	CLRF  TBLPTR+2,0
001AF2 0008       06413 	TBLRD *
001AF4 50F5       06414 	MOVF  TABLAT,W,0
001AF6 0012       06415 	RETURN
001AF8 0800       06416 	DW    0x800
001AFA 1710       06417 	DW    0x1710
001AFC 271F       06418 	DW    0x271F
001AFE 362F       06419 	DW    0x362F
001B00 443D       06420 	DW    0x443D
001B02 514B       06421 	DW    0x514B
001B04 5D57       06422 	DW    0x5D57
001B06 6762       06423 	DW    0x6762
001B08 706C       06424 	DW    0x706C
001B0A 7773       06425 	DW    0x7773
001B0C 7B79       06426 	DW    0x7B79
001B0E 7E7D       06427 	DW    0x7E7D
001B10 807F       06428 	DW    0x807F
001B12 100C       06429 	DW    0x100C
001B14 0408       06430 	DW    0x408
001B16 041B       06431 	DW    0x41B
001B18 0304       06432 	DW    0x304
001B1A FFEE       06433 	DW    0xFFEE
001B1C FFFF       06434 	DW    0xFFFF
001B1E FFFF       06435 	DW    0xFFFF
001B20 FFFF       06436 	DW    0xFFFF
001B22 FFEE       06437 	DW    0xFFEE
001B24 FFF1       06438 	DW    0xFFF1
001B26 FFFF       06439 	DW    0xFFFF
001B28 FFFF       06440 	DW    0xFFFF
001B2A FFEE       06441 	DW    0xFFEE
001B2C F1F1       06442 	DW    0xF1F1
001B2E FFFF       06443 	DW    0xFFFF
001B30 FFFF       06444 	DW    0xFFFF
001B32 FFEE       06445 	DW    0xFFEE
001B34 F1F1       06446 	DW    0xF1F1
001B36 FFF1       06447 	DW    0xFFF1
001B38 FFFF       06448 	DW    0xFFFF
001B3A FFEE       06449 	DW    0xFFEE
001B3C F1F1       06450 	DW    0xF1F1
001B3E F1F1       06451 	DW    0xF1F1
001B40 FFFF       06452 	DW    0xFFFF
001B42 FFEE       06453 	DW    0xFFEE
001B44 F1F1       06454 	DW    0xF1F1
001B46 F1F1       06455 	DW    0xF1F1
001B48 FFF1       06456 	DW    0xFFF1
001B4A 0000       06457 	DW    0x0
001B4C 0000       06458 	DW    0x0
001B4E 0000       06459 	DW    0x0
001B50 0000       06460 	DW    0x0
                  06461 
                  06462 	END
                  06463 
                  06464 
                  06465 ; *** KEY INFO ***
                  06466 
                  06467 ; 0x000008  151 word(s)  1 % : highPriorityTimer_0
                  06468 ; 0x001AE0   57 word(s)  0 % : _const1
                  06469 ; 0x000136  100 word(s)  1 % : _fmul24
CC8E Version 1.4,   File: ondulador_float.c   19. May 2015  15:23   Page 109

ADDR   CODE       LINE  SOURCE

                  06470 ; 0x0001FE  122 word(s)  1 % : _fdiv24
                  06471 ; 0x0002F2  167 word(s)  2 % : _fadd24
                  06472 ; 0x000440    7 word(s)  0 % : _fsub24
                  06473 ; 0x00044E   69 word(s)  0 % : _int24ToFloat24
                  06474 ; 0x0004D8   85 word(s)  1 % : _float24ToInt24
                  06475 ; 0x000582   24 word(s)  0 % : _divU16_8
                  06476 ; 0x0005B2   27 word(s)  0 % : _divU16_16
                  06477 ; 0x0005E8   23 word(s)  0 % : _remU16_8
                  06478 ; 0x000616   25 word(s)  0 % : _remU16_16
                  06479 ; 0x000648  169 word(s)  2 % : sqrt
                  06480 ; 0x00079A   10 word(s)  0 % : retardo_20u
                  06481 ; 0x0007AE   19 word(s)  0 % : retardo_1m
                  06482 ; 0x0007D4   20 word(s)  0 % : retardo_50m
                  06483 ; 0x0007FC   18 word(s)  0 % : retardo_100m
                  06484 ; 0x000820   20 word(s)  0 % : retardo_500m
                  06485 ; 0x000848   28 word(s)  0 % : envia_codigo_inicial
                  06486 ; 0x000880   59 word(s)  0 % : enviar_comando
                  06487 ; 0x0008F6   79 word(s)  0 % : enviar_literal
                  06488 ; 0x000994   72 word(s)  0 % : enviar_cifra
                  06489 ; 0x000A24   59 word(s)  0 % : inicializar_lcd
                  06490 ; 0x000A9A   39 word(s)  0 % : escribir_posicion
                  06491 ; 0x000AE8   37 word(s)  0 % : borrar_linea
                  06492 ; 0x000B32    2 word(s)  0 % : borrar_lcd
                  06493 ; 0x000B36  301 word(s)  3 % : Enviar_lcd
                  06494 ; 0x000D90  320 word(s)  3 % : Enviar_uns16
                  06495 ; 0x001010  209 word(s)  2 % : Enviar_char
                  06496 ; 0x0011B2  160 word(s)  1 % : RAM_LCD
                  06497 ; 0x0012F2  113 word(s)  1 % : medir
                  06498 ; 0x001AAC   26 word(s)  0 % : configuraPic
                  06499 ; 0x0013D4  876 word(s) 10 % : main
                  06500 
                  06501 ; RAM usage: 109 bytes (95 local), 659 bytes free
                  06502 ; Maximum call level: 3 (+2 for interrupt)
                  06503 ; Total of 3495 code words (42 %)
