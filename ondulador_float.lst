CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 1

ADDR   CODE       LINE  SOURCE

                  00001 
                  00002 ; CC8E Version 1.4, Copyright (c) B Knudsen Data
                  00003 ; C compiler for the PIC18 microcontrollers
                  00004 ; ************  15. May 2015  20:58  *************
                  00005 
                  00006 	processor  PIC18F44K20
                  00007 	radix  DEC
                  00008 
300000 08FF       00009 	__config 0x300001, 0x8
                  00010 	__config 0x300002, 0x1
300002 1601       00011 	__config 0x300003, 0x16
300004 88FF       00012 	__config 0x300005, 0x88
300006 FF81       00013 	__config 0x300006, 0x81
                  00014 
       0FF6       00015 TBLPTR      EQU   0xFF6
       0FF5       00016 TABLAT      EQU   0xFF5
       0FF4       00017 PRODH       EQU   0xFF4
       0FF3       00018 PRODL       EQU   0xFF3
       0FF2       00019 INTCON      EQU   0xFF2
       0FF1       00020 INTCON2     EQU   0xFF1
       0FEE       00021 POSTINC0    EQU   0xFEE
       0FE9       00022 FSR0        EQU   0xFE9
       0FE0       00023 BSR         EQU   0xFE0
       0FD8       00024 STATUS      EQU   0xFD8
       0000       00025 Carry       EQU   0
       0002       00026 Zero_       EQU   2
       0FD5       00027 T0CON       EQU   0xFD5
       0FD3       00028 OSCCON      EQU   0xFD3
       0FD0       00029 RCON        EQU   0xFD0
       0FCB       00030 PR2         EQU   0xFCB
       0FCA       00031 T2CON       EQU   0xFCA
       0FC4       00032 ADRESH      EQU   0xFC4
       0FC3       00033 ADRESL      EQU   0xFC3
       0FC2       00034 ADCON0      EQU   0xFC2
       0FC1       00035 ADCON1      EQU   0xFC1
       0FC0       00036 ADCON2      EQU   0xFC0
       0FBE       00037 CCPR1L      EQU   0xFBE
       0FBD       00038 CCP1CON     EQU   0xFBD
       0FB7       00039 PWM1CON     EQU   0xFB7
       0F9B       00040 OSCTUNE     EQU   0xF9B
       0F95       00041 TRISD       EQU   0xF95
       0F94       00042 TRISC       EQU   0xF94
       0F93       00043 TRISB       EQU   0xF93
       0F92       00044 TRISA       EQU   0xF92
       0F8C       00045 LATD        EQU   0xF8C
       0F8B       00046 LATC        EQU   0xF8B
       0F8A       00047 LATB        EQU   0xF8A
       0F83       00048 PORTD       EQU   0xF83
       0F82       00049 PORTC       EQU   0xF82
       0F81       00050 PORTB       EQU   0xF81
       0F7E       00051 ANSEL       EQU   0xF7E
       0002       00052 TMR0IF      EQU   2
       0007       00053 GIE         EQU   7
       0002       00054 TMR2ON      EQU   2
       0001       00055 GO          EQU   1
       0007       00056 ADFM        EQU   7
       0001       00057 TMR2IF      EQU   1
       0001       00058 TMR2IE      EQU   1
       0000       00059 bUdw        EQU   0
       00B9       00060 ancho_pwm   EQU   0xB9
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 2

ADDR   CODE       LINE  SOURCE

       00BB       00061 r           EQU   0xBB
       00BD       00062 Vmax        EQU   0xBD
       00C0       00063 SENO        EQU   0xC0
       00C2       00064 T           EQU   0xC2
       00C3       00065 i           EQU   0xC3
       00C4       00066 estado      EQU   0xC4
       0060       00067 svrSTATUS   EQU   0x60
       0061       00068 svrBSR      EQU   0x61
       0062       00069 svrWREG     EQU   0x62
       0063       00070 sv_PRODL    EQU   0x63
       0064       00071 sv_PRODH    EQU   0x64
       0065       00072 sv_TBLPTR   EQU   0x65
       0068       00073 sv_TABLAT   EQU   0x68
       0069       00074 C3cnt       EQU   0x69
       006A       00075 C4tmp       EQU   0x6A
       006C       00076 C5rem       EQU   0x6C
       00B4       00077 PDel0       EQU   0xB4
       00B4       00078 PDel0_2     EQU   0xB4
       00B5       00079 PDel1       EQU   0xB5
       0F7F       00080 PDel0_3     EQU   0xF7F
       0F7F       00081 PDel1_2     EQU   0xF7F
       0F7F       00082 PDel2       EQU   0xF7F
       0F7F       00083 PDel0_4     EQU   0xF7F
       0F7F       00084 PDel1_3     EQU   0xF7F
       0F7F       00085 PDel2_2     EQU   0xF7F
       0F7F       00086 PDel0_5     EQU   0xF7F
       0F7F       00087 PDel1_4     EQU   0xF7F
       0F7F       00088 PDel2_3     EQU   0xF7F
       0099       00089 codigo      EQU   0x99
       00B3       00090 comando     EQU   0xB3
       0099       00091 dato        EQU   0x99
       009A       00092 i_2         EQU   0x9A
       0F7F       00093 dato_2      EQU   0xF7F
       0F7F       00094 i_3         EQU   0xF7F
       0098       00095 i_4         EQU   0x98
       0098       00096 linea       EQU   0x98
       0099       00097 columna     EQU   0x99
       0F7F       00098 linea_2     EQU   0xF7F
       0F7F       00099 i_5         EQU   0xF7F
       0F7F       00100 linea_3     EQU   0xF7F
       0F7F       00101 columna_2   EQU   0xF7F
       0F7F       00102 dato_3      EQU   0xF7F
       0000       00103 bd          EQU   0
       0000       00104 dp          EQU   0
       0000       00105 xi          EQU   0
       0000       00106 ndp         EQU   0
       0F7F       00107 num         EQU   0xF7F
       0F7F       00108 u_milers    EQU   0xF7F
       0F7F       00109 cent        EQU   0xF7F
       0F7F       00110 dec         EQU   0xF7F
       0F7F       00111 unid        EQU   0xF7F
       0F7F       00112 resto1      EQU   0xF7F
       0F7F       00113 i_6         EQU   0xF7F
       0F7F       00114 xx          EQU   0xF7F
       0F7F       00115 dat         EQU   0xF7F
       0F7F       00116 xy          EQU   0xF7F
       0F7F       00117 C6cnt       EQU   0xF7F
       0F7F       00118 C7tmp       EQU   0xF7F
       0F7F       00119 C8rem       EQU   0xF7F
       0F7F       00120 C9cnt       EQU   0xF7F
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 3

ADDR   CODE       LINE  SOURCE

       0F7F       00121 C10tmp      EQU   0xF7F
       0F7F       00122 C11cnt      EQU   0xF7F
       0F7F       00123 C12tmp      EQU   0xF7F
       0F7F       00124 C13rem      EQU   0xF7F
       0F7F       00125 C14cnt      EQU   0xF7F
       0F7F       00126 C15tmp      EQU   0xF7F
       0F7F       00127 C16cnt      EQU   0xF7F
       0F7F       00128 C17tmp      EQU   0xF7F
       0F7F       00129 C18rem      EQU   0xF7F
       0F7F       00130 C19cnt      EQU   0xF7F
       0F7F       00131 C20tmp      EQU   0xF7F
       009F       00132 linea_4     EQU   0x9F
       00A0       00133 columna_3   EQU   0xA0
       00A1       00134 dato_4      EQU   0xA1
       00A3       00135 num_2       EQU   0xA3
       00A5       00136 u_milers_2  EQU   0xA5
       00A7       00137 cent_2      EQU   0xA7
       00A9       00138 d_milers    EQU   0xA9
       00AB       00139 dec_2       EQU   0xAB
       00AC       00140 unid_2      EQU   0xAC
       00AD       00141 resto1_2    EQU   0xAD
       00AE       00142 i_7         EQU   0xAE
       00AF       00143 xx_2        EQU   0xAF
       00B1       00144 dat_2       EQU   0xB1
       00B3       00145 C21cnt      EQU   0xB3
       00B4       00146 C22tmp      EQU   0xB4
       00B6       00147 C23rem      EQU   0xB6
       00B3       00148 C24cnt      EQU   0xB3
       00B4       00149 C25tmp      EQU   0xB4
       00B3       00150 C26cnt      EQU   0xB3
       00B4       00151 C27tmp      EQU   0xB4
       00B6       00152 C28rem      EQU   0xB6
       00B3       00153 C29cnt      EQU   0xB3
       00B4       00154 C30tmp      EQU   0xB4
       00B3       00155 C31cnt      EQU   0xB3
       00B4       00156 C32tmp      EQU   0xB4
       00B6       00157 C33rem      EQU   0xB6
       00B3       00158 C34cnt      EQU   0xB3
       00B4       00159 C35tmp      EQU   0xB4
       00B3       00160 C36cnt      EQU   0xB3
       00B4       00161 C37tmp      EQU   0xB4
       00B5       00162 C38rem      EQU   0xB5
       00B3       00163 C39cnt      EQU   0xB3
       00B4       00164 C40tmp      EQU   0xB4
       0098       00165 i_8         EQU   0x98
       009D       00166 canal       EQU   0x9D
       009E       00167 bits        EQU   0x9E
       009F       00168 resultado   EQU   0x9F
       0001       00169 FpOverflow  EQU   1
       0002       00170 FpUnderFlow EQU   2
       0003       00171 FpDiv0      EQU   3
       0006       00172 FpRounding  EQU   6
       009F       00173 arg1f24     EQU   0x9F
       00A2       00174 arg2f24     EQU   0xA2
       00A5       00175 aarg        EQU   0xA5
       00A7       00176 sign        EQU   0xA7
       00A8       00177 tmpL        EQU   0xA8
       00A5       00178 aarg_2      EQU   0xA5
       00A7       00179 sign_2      EQU   0xA7
       00A8       00180 counter     EQU   0xA8
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 4

ADDR   CODE       LINE  SOURCE

       00A5       00181 xtra        EQU   0xA5
       00A6       00182 temp        EQU   0xA6
       00A7       00183 expo        EQU   0xA7
       00A8       00184 sign_3      EQU   0xA8
       00A5       00185 expo_2      EQU   0xA5
       00A6       00186 xtra_2      EQU   0xA6
       00A7       00187 sign_4      EQU   0xA7
       009F       00188 rval        EQU   0x9F
       00A5       00189 sign_6      EQU   0xA5
       00A6       00190 expo_4      EQU   0xA6
       00A7       00191 xtra_4      EQU   0xA7
       009F       00192 rval_3      EQU   0x9F
       006D       00193 p           EQU   0x6D
       006E       00194 h           EQU   0x6E
       006F       00195 x           EQU   0x6F
       0070       00196 vac         EQU   0x70
       007C       00197 ac          EQU   0x7C
       008A       00198 ic          EQU   0x8A
       008C       00199 rf          EQU   0x8C
       008E       00200 dif         EQU   0x8E
       0090       00201 difMediaAC  EQU   0x90
       0092       00202 difMediaIC  EQU   0x92
       0094       00203 vbat        EQU   0x94
       0095       00204 o           EQU   0x95
       0096       00205 BP          EQU   0x96
       0003       00206 vuelta      EQU   3
       0004       00207 flancoVAC   EQU   4
       0005       00208 flancoIAC   EQU   5
       009D       00209 C41cnt      EQU   0x9D
       009E       00210 C42tmp      EQU   0x9E
       00A0       00211 C43rem      EQU   0xA0
       0098       00212 variacion   EQU   0x98
       009D       00213 C44cnt      EQU   0x9D
       009E       00214 C45tmp      EQU   0x9E
       00A0       00215 C46rem      EQU   0xA0
       009B       00216 bat         EQU   0x9B
       009D       00217 g           EQU   0x9D
       0069       00218 ci          EQU   0x69
                  00219 
000000 EFBD F008  00220 	GOTO main
                  00221 
                  00222   ; FILE ondulador_float.c
                  00223 			;/*
                  00224 			; * Autor: J_Sanchez
                  00225 			; * 
                  00226 			; * Fecha: 31-03-2015
                  00227 			; * Descripcion:Primera prueba con el 18F44K20 para el proyecto del ondulador v2.0
                  00228 			; *  Configuracion: 
                  00229 			; *		Modelo: 18F44K20
                  00230 			; *		Oscilador: Crystal 64Mhz
                  00231 			; *		Puente en H con PWM mejorado
                  00232 			; */
                  00233 			;
                  00234 			; //**************************************************************************************//
                  00235 			; //******************* C O N F I G  U R A C I O N    I N I C I A L  *********************//
                  00236 			; //**************************************************************************************//
                  00237 			; 
                  00238 			; #pragma chip PIC18F44K20
                  00239 			; #pragma config[1] = 0b.0000.1000//pagina 301 datasheet
                  00240 			; #pragma config[2] = 0b.0000.0001
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 5

ADDR   CODE       LINE  SOURCE

                  00241 			; #pragma config[3] = 0b.0001.0110
                  00242 			; #pragma config[5] = 0b.1000.1000//Mirar CCP2 MUX bit 0 
                  00243 			; 				//-->1 = CCP2 input/output is multiplexed with RC1
                  00244 			;				//   -->0 = CCP2 input/output is multiplexed with RB3 
                  00245 			; #pragma config[6] = 0b.1000.0001
                  00246 			; // resto configs son para la proteccion del programa 
                  00247 			;
                  00248 			; #pragma sharedAllocation//evita error en las interrupciones
                  00249 			;
                  00250 			; //**************************************************************************************//
                  00251 			; //********************************  V A R I A B L E S  *********************************//
                  00252 			; //**************************************************************************************//
                  00253 			;#define PORDEBAJO 0
                  00254 			;#define PORENCIMA 1
                  00255 			;
                  00256 			;#define LECTURA_VAC  0
                  00257 			;#define CALCULOS_VAC 1
                  00258 			;#define LECTURA_IAC  2
                  00259 			;#define CALCULOS_IAC 3
                  00260 			;#define LECTURAS_VARIAS 4
                  00261 			;#define ENVIO_LCD    5
                  00262 			;
                  00263 			;#define LEO_VAC		 0
                  00264 			;#define LEO_BAT		 1
                  00265 			;#define LEO_IAC		 2
                  00266 			;
                  00267 			;#define LOGO_SC		 0
                  00268 			;#define BATT_FULL	 1
                  00269 			;#define BATT_75		 2
                  00270 			;#define BATT_50		 3
                  00271 			;#define BATT_25		 4
                  00272 			;#define BATT_10		 5
                  00273 			;#define BATT_LW		 6 
                  00274 			;#define BATT_CLEAR	 7
                  00275 			;
                  00276 			;
                  00277 			;#pragma rambank 0
                  00278 			;bit bUdw; // a 1 puja en la taula (incrementa) , a 0 decrementa
                  00279 			;uns16 ancho_pwm,r;
                  00280 			;float Vmax;
                  00281 			;uns16 SENO;
                  00282 			;char T,i,estado; // Index de la taula
                  00283 			;
                  00284 			;
                  00285 			;static const char sen [26] = 			
                  00286 			;{0,8,16,23,31,39,47,54,61,68,75,81,87,93,98,103,108,112,115,119,121,123,125,126,127,128};
                  00287 			;// PWM maximo 799 para ser 100% 
                  00288 			;
                  00289 			;//=======================================================================
                  00290 			;#include "int18XXX.h"	 // Cap√ßalera de interrupcions.
                  00291 			;
                  00292 			;
                  00293 			;#pragma origin 0x08	//#pragma origin 0x18	(PIC 16F88x)
       0000       00294 	ORG 0x0008
                  00295 			;
                  00296 			;interrupt highPriorityTimer_0 (void)		// Interrupci√≥n por desbordamiento de Timer 0.			
                  00297 			;{
                  00298 highPriorityTimer_0
                  00299 			;	int_save_registers 
000008 CFD8 F060  00300 	MOVFF STATUS,svrSTATUS
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 6

ADDR   CODE       LINE  SOURCE

00000C CFE0 F061  00301 	MOVFF BSR,svrBSR
000010 0100       00302 	MOVLB 0
000012 6F62       00303 	MOVWF svrWREG,1
                  00304 			;
                  00305 			;	// save remaining registers on demand (error/warning)
                  00306 			;	//uns16 sv_FSR0 = FSR0;
                  00307 			;	//uns16 sv_FSR1 = FSR1;
                  00308 			;	//uns16 sv_FSR2 = FSR2;
                  00309 			;	//uns8 sv_PCLATH = PCLATH;
                  00310 			;	//uns8 sv_PCLATU = PCLATU;
                  00311 			;	uns8 sv_PRODL = PRODL;
000014 CFF3 F063  00312 	MOVFF PRODL,sv_PRODL
                  00313 			;	uns8 sv_PRODH = PRODH;
000018 CFF4 F064  00314 	MOVFF PRODH,sv_PRODH
                  00315 			;	uns24 sv_TBLPTR = TBLPTR;
00001C CFF6 F065  00316 	MOVFF TBLPTR,sv_TBLPTR
000020 CFF7 F066  00317 	MOVFF TBLPTR+1,sv_TBLPTR+1
000024 CFF8 F067  00318 	MOVFF TBLPTR+2,sv_TBLPTR+2
                  00319 			;	uns8 sv_TABLAT = TABLAT;
000028 CFF5 F068  00320 	MOVFF TABLAT,sv_TABLAT
                  00321 			;
                  00322 			;
                  00323 			;	     				// Guarda W, STATUS y PCLATH.
                  00324 			;	LATC.0=!LATC.0;
00002C 708B       00325 	BTG   LATC,0,0
                  00326 			;	if(TMR2IF) 	//{ LATD.0= !LATD.0; TMR2IF=0; }
00002E A29E       00327 	BTFSS 0xF9E,TMR2IF,0
000030 D070       00328 	BRA   m011
                  00329 			;	{ 
                  00330 			;		T2CON = 0b.0.0011.1.01; TMR2IF =0; //TMR2ON =1; // PostScaler per 4
000032 0E1D       00331 	MOVLW 29
000034 6ECA       00332 	MOVWF T2CON,0
000036 929E       00333 	BCF   0xF9E,TMR2IF,0
                  00334 			;		for (i = 1; i <= 6; i ++)  ancho_pwm = rl (ancho_pwm);
000038 0E01       00335 	MOVLW 1
00003A 6FC3       00336 	MOVWF i,1
00003C 0E07       00337 m001	MOVLW 7
00003E 0100       00338 	MOVLB 0
000040 61C3       00339 	CPFSLT i,1
000042 D004       00340 	BRA   m002
000044 37B9       00341 	RLCF  ancho_pwm,1,1
000046 37BA       00342 	RLCF  ancho_pwm+1,1,1
000048 2BC3       00343 	INCF  i,1,1
00004A D7F8       00344 	BRA   m001
                  00345 			;		CCPR1L = ancho_pwm.high8;
00004C C0BA FFBE  00346 m002	MOVFF ancho_pwm+1,CCPR1L
                  00347 			;		CCP1CON.5 = ancho_pwm.7;
000050 0100       00348 	MOVLB 0
000052 AFB9       00349 	BTFSS ancho_pwm,7,1
000054 9ABD       00350 	BCF   CCP1CON,5,0
000056 BFB9       00351 	BTFSC ancho_pwm,7,1
000058 8ABD       00352 	BSF   CCP1CON,5,0
                  00353 			;		CCP1CON.4 = ancho_pwm.6;
00005A ADB9       00354 	BTFSS ancho_pwm,6,1
00005C 98BD       00355 	BCF   CCP1CON,4,0
00005E BDB9       00356 	BTFSC ancho_pwm,6,1
000060 88BD       00357 	BSF   CCP1CON,4,0
                  00358 			;				  
                  00359 			;		if(bUdw){ 
000062 A1B8       00360 	BTFSS 0xB8,bUdw,1
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 7

ADDR   CODE       LINE  SOURCE

000064 D007       00361 	BRA   m004
                  00362 			;			if(T>=25)  bUdw=0;      
000066 0E18       00363 	MOVLW 24
000068 65C2       00364 	CPFSGT T,1
00006A D002       00365 	BRA   m003
00006C 91B8       00366 	BCF   0xB8,bUdw,1
                  00367 			;			else T++;
00006E D002       00368 	BRA   m004
000070 0100       00369 m003	MOVLB 0
000072 2BC2       00370 	INCF  T,1,1
                  00371 			;		} 
                  00372 			;		if(!bUdw) T--;                       
000074 0100       00373 m004	MOVLB 0
000076 A1B8       00374 	BTFSS 0xB8,bUdw,1
000078 07C2       00375 	DECF  T,1,1
                  00376 			;		if(T==0) {
00007A 0100       00377 	MOVLB 0
00007C 53C2       00378 	MOVF  T,1,1
00007E A4D8       00379 	BTFSS 0xFD8,Zero_,0
000080 D019       00380 	BRA   m007
                  00381 			;		  	while(!TMR2IF);TMR2IF =0; // ESPERO QUE ACABI  T=1
000082 A29E       00382 m005	BTFSS 0xF9E,TMR2IF,0
000084 D7FE       00383 	BRA   m005
000086 929E       00384 	BCF   0xF9E,TMR2IF,0
                  00385 			;			T2CON = 0b.0.0001.1.01;
000088 0E0D       00386 	MOVLW 13
00008A 6ECA       00387 	MOVWF T2CON,0
                  00388 			;			CCPR1L = 0;
00008C 6ABE       00389 	CLRF  CCPR1L,0
                  00390 			;			CCP1CON.5 = 0;
00008E 9ABD       00391 	BCF   CCP1CON,5,0
                  00392 			;			CCP1CON.4 = 0;	 
000090 98BD       00393 	BCF   CCP1CON,4,0
                  00394 			;			// Posrescaler a 2
                  00395 			;			//while(!TMR2IF); // espero que acabi el T=0
                  00396 			;			//	TMR2IF =0; // Postscaler a 2
                  00397 			;			while(!TMR2IF); // espeor que acabi la 1era meitat del T=0, postsclaer =2
000092 A29E       00398 m006	BTFSS 0xF9E,TMR2IF,0
000094 D7FE       00399 	BRA   m006
                  00400 			;			TMR2IF =0;
000096 929E       00401 	BCF   0xF9E,TMR2IF,0
                  00402 			;			T2CON = 0b.0.0000.1.01;
000098 0E05       00403 	MOVLW 5
00009A 6ECA       00404 	MOVWF T2CON,0
                  00405 			;			CCPR1L = 0;
00009C 6ABE       00406 	CLRF  CCPR1L,0
                  00407 			;			CCP1CON.5 = 0;
00009E 9ABD       00408 	BCF   CCP1CON,5,0
                  00409 			;			CCP1CON.4 = 0;
0000A0 98BD       00410 	BCF   CCP1CON,4,0
                  00411 			;			LATD.0= !LATD.0;
0000A2 708C       00412 	BTG   LATD,0,0
                  00413 			;			
                  00414 			;			bUdw=1;  
0000A4 0100       00415 	MOVLB 0
0000A6 81B8       00416 	BSF   0xB8,bUdw,1
                  00417 			;			T=1; 
0000A8 0E01       00418 	MOVLW 1
0000AA 6FC2       00419 	MOVWF T,1
                  00420 			;			if(estado==ENVIO_LCD) estado = LECTURA_VAC;  // el deixo sortir
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 8

ADDR   CODE       LINE  SOURCE

0000AC 0E05       00421 	MOVLW 5
0000AE 63C4       00422 	CPFSEQ estado,1
0000B0 D001       00423 	BRA   m007
0000B2 6BC4       00424 	CLRF  estado,1
                  00425 			;		}			  
                  00426 			;							
                  00427 			;		SENO = sen[T];
0000B4 0100       00428 m007	MOVLB 0
0000B6 51C2       00429 	MOVF  T,W,1
0000B8 EC62 F00C  00430 	CALL  _const1
0000BC 0100       00431 	MOVLB 0
0000BE 6FC0       00432 	MOVWF SENO,1
0000C0 6BC1       00433 	CLRF  SENO+1,1
                  00434 			;		ancho_pwm = (uns16)SENO*r;
0000C2 51C0       00435 	MOVF  SENO,W,1
0000C4 03BB       00436 	MULWF r,1
0000C6 CFF3 F0B9  00437 	MOVFF PRODL,ancho_pwm
0000CA CFF4 F0BA  00438 	MOVFF PRODH,ancho_pwm+1
0000CE 51C1       00439 	MOVF  SENO+1,W,1
0000D0 03BB       00440 	MULWF r,1
0000D2 50F3       00441 	MOVF  PRODL,W,0
0000D4 27BA       00442 	ADDWF ancho_pwm+1,1,1
0000D6 51C0       00443 	MOVF  SENO,W,1
0000D8 03BC       00444 	MULWF r+1,1
0000DA 50F3       00445 	MOVF  PRODL,W,0
0000DC 27BA       00446 	ADDWF ancho_pwm+1,1,1
                  00447 			;		ancho_pwm=ancho_pwm/10;
0000DE 51B9       00448 	MOVF  ancho_pwm,W,1
0000E0 6F6A       00449 	MOVWF C4tmp,1
0000E2 51BA       00450 	MOVF  ancho_pwm+1,W,1
0000E4 6F6B       00451 	MOVWF C4tmp+1,1
0000E6 6B6C       00452 	CLRF  C5rem,1
0000E8 0E10       00453 	MOVLW 16
0000EA 6F69       00454 	MOVWF C3cnt,1
0000EC 0100       00455 m008	MOVLB 0
0000EE 376A       00456 	RLCF  C4tmp,1,1
0000F0 376B       00457 	RLCF  C4tmp+1,1,1
0000F2 376C       00458 	RLCF  C5rem,1,1
0000F4 B0D8       00459 	BTFSC 0xFD8,Carry,0
0000F6 D004       00460 	BRA   m009
0000F8 0E0A       00461 	MOVLW 10
0000FA 5D6C       00462 	SUBWF C5rem,W,1
0000FC A0D8       00463 	BTFSS 0xFD8,Carry,0
0000FE D004       00464 	BRA   m010
000100 0E0A       00465 m009	MOVLW 10
000102 0100       00466 	MOVLB 0
000104 5F6C       00467 	SUBWF C5rem,1,1
000106 80D8       00468 	BSF   0xFD8,Carry,0
000108 0100       00469 m010	MOVLB 0
00010A 37B9       00470 	RLCF  ancho_pwm,1,1
00010C 37BA       00471 	RLCF  ancho_pwm+1,1,1
00010E 2F69       00472 	DECFSZ C3cnt,1,1
000110 D7ED       00473 	BRA   m008
                  00474 			;		//Vmax=3.0;
                  00475 			;				  			  
                  00476 			;	} 
                  00477 			;			
                  00478 			;	// restore registers that are saved
                  00479 			;	//FSR0 = sv_FSR0;
                  00480 			;	//FSR1 = sv_FSR1;
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 9

ADDR   CODE       LINE  SOURCE

                  00481 			;	//FSR2 = sv_FSR2;
                  00482 			;	//PCLATH = sv_PCLATH;
                  00483 			;	//PCLATU = sv_PCLATU;
                  00484 			;	PRODL = sv_PRODL;
000112 C063 FFF3  00485 m011	MOVFF sv_PRODL,PRODL
                  00486 			;	PRODH = sv_PRODH;
000116 C064 FFF4  00487 	MOVFF sv_PRODH,PRODH
                  00488 			;	TBLPTR = sv_TBLPTR;
00011A C065 FFF6  00489 	MOVFF sv_TBLPTR,TBLPTR
00011E C066 FFF7  00490 	MOVFF sv_TBLPTR+1,TBLPTR+1
000122 C067 FFF8  00491 	MOVFF sv_TBLPTR+2,TBLPTR+2
                  00492 			;	TABLAT = sv_TABLAT;
000126 C068 FFF5  00493 	MOVFF sv_TABLAT,TABLAT
                  00494 			;
                  00495 			;    int_restore_registers 					// Devuelve W, STATUS y PCLATH.
00012A 0100       00496 	MOVLB 0
00012C 5162       00497 	MOVF  svrWREG,W,1
00012E C061 FFE0  00498 	MOVFF svrBSR,BSR
000132 C060 FFD8  00499 	MOVFF svrSTATUS,STATUS
                  00500 			;}
000136 0010       00501 	RETFIE
                  00502 
                  00503   ; FILE Temporiz_64Mhz.h
                  00504 			;void retardo_20u(void){
                  00505 retardo_20u
                  00506 			;	
                  00507 			;		char PDel0;
                  00508 			;		#asm
                  00509 			;		;-------------------------------------------------------------
                  00510 			;		DEMORA  movlw     .78       ; 1 set numero de repeticion 
000138 0E4E       00511 	MOVLW 78
                  00512 			;		        movwf     PDel0     ; 1 |
00013A 6FB4       00513 	MOVWF PDel0,1
                  00514 			;		PLoop0  clrwdt              ; 1 clear watchdog
00013C 0004       00515 m012	CLRWDT
                  00516 			;		        decfsz    PDel0, 1  ; 1 + (1) es el tiempo 0  ?
00013E 2FB4       00517 	DECFSZ PDel0,1,1
                  00518 			;		        goto      PLoop0    ; 2 no, loop
000140 EF9E F000  00519 	GOTO  m012
                  00520 			;		PDelL1  goto PDelL2         ; 2 ciclos delay
000144 EFA4 F000  00521 	GOTO  m013
                  00522 			;		PDelL2  clrwdt              ; 1 ciclo delay
000148 0004       00523 m013	CLRWDT
                  00524 			;		        return              ; 2+2 Fin.
00014A 0012       00525 	RETURN
                  00526 			;		;-------------------------------------------------------------
                  00527 			;		#endasm
                  00528 			;	
                  00529 			;}
                  00530 			;void retardo_1m(void){
                  00531 retardo_1m
                  00532 			;	char PDel0,PDel1;
                  00533 			;	#asm
                  00534 			;	;-------------------------------------------------------------
                  00535 			;	DEMORA  movlw     .15       ; 1 set numero de repeticion  (B)
00014C 0E0F       00536 	MOVLW 15
                  00537 			;	        movwf     PDel0     ; 1 |
00014E 6FB4       00538 	MOVWF PDel0_2,1
                  00539 			;	PLoop1  movlw     .177      ; 1 set numero de repeticion  (A)
000150 0EB1       00540 m014	MOVLW 177
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 10

ADDR   CODE       LINE  SOURCE

                  00541 			;	        movwf     PDel1     ; 1 |
000152 6FB5       00542 	MOVWF PDel1,1
                  00543 			;	PLoop2  clrwdt              ; 1 clear watchdog
000154 0004       00544 m015	CLRWDT
                  00545 			;	PDelL1  goto PDelL2         ; 2 ciclos delay
000156 EFAD F000  00546 	GOTO  m016
                  00547 			;	PDelL2  
                  00548 			;	        decfsz    PDel1, 1  ; 1 + (1) es el tiempo 0  ? (A)
00015A 2FB5       00549 m016	DECFSZ PDel1,1,1
                  00550 			;	        goto      PLoop2    ; 2 no, loop
00015C EFAA F000  00551 	GOTO  m015
                  00552 			;	        decfsz    PDel0,  1 ; 1 + (1) es el tiempo 0  ? (B)
000160 2FB4       00553 	DECFSZ PDel0_2,1,1
                  00554 			;	        goto      PLoop1    ; 2 no, loop
000162 EFA8 F000  00555 	GOTO  m014
                  00556 			;	PDelL3  goto PDelL4         ; 2 ciclos delay
000166 EFB5 F000  00557 	GOTO  m017
                  00558 			;	PDelL4  goto PDelL5         ; 2 ciclos delay
00016A EFB7 F000  00559 m017	GOTO  m018
                  00560 			;	PDelL5  clrwdt              ; 1 ciclo delay
00016E 0004       00561 m018	CLRWDT
                  00562 			;	        return              ; 2+2 Fin.
000170 0012       00563 	RETURN
                  00564 			;	;-------------------------------------------------------------
                  00565 			;	#endasm
                  00566 			;}
                  00567 			;void retardo_50m(void){
                  00568 retardo_50m
                  00569 			;	char PDel0,PDel1,PDel2;
                  00570 			;	#asm
                  00571 			;	;-------------------------------------------------------------
                  00572 			;	DEMORA  movlw     .18       ; 1 set numero de repeticion  (C)
000172 0E12       00573 	MOVLW 18
                  00574 			;	        movwf     PDel0     ; 1 |
000174 6E7F       00575 	MOVWF PDel0_3,0
                  00576 			;	PLoop0  movlw     .55       ; 1 set numero de repeticion  (B)
000176 0E37       00577 m019	MOVLW 55
                  00578 			;	        movwf     PDel1     ; 1 |
000178 6E7F       00579 	MOVWF PDel1_2,0
                  00580 			;	PLoop1  movlw     .201      ; 1 set numero de repeticion  (A)
00017A 0EC9       00581 m020	MOVLW 201
                  00582 			;	        movwf     PDel2     ; 1 |
00017C 6E7F       00583 	MOVWF PDel2,0
                  00584 			;	PLoop2  clrwdt              ; 1 clear watchdog
00017E 0004       00585 m021	CLRWDT
                  00586 			;	        decfsz    PDel2, 1  ; 1 + (1) es el tiempo 0  ? (A)
000180 2E7F       00587 	DECFSZ PDel2,1,0
                  00588 			;	        goto      PLoop2    ; 2 no, loop
000182 EFBF F000  00589 	GOTO  m021
                  00590 			;	        decfsz    PDel1,  1 ; 1 + (1) es el tiempo 0  ? (B)
000186 2E7F       00591 	DECFSZ PDel1_2,1,0
                  00592 			;	        goto      PLoop1    ; 2 no, loop
000188 EFBD F000  00593 	GOTO  m020
                  00594 			;	        decfsz    PDel0,  1 ; 1 + (1) es el tiempo 0  ? (C)
00018C 2E7F       00595 	DECFSZ PDel0_3,1,0
                  00596 			;	        goto      PLoop0    ; 2 no, loop
00018E EFBB F000  00597 	GOTO  m019
                  00598 			;	PDelL1  goto PDelL2         ; 2 ciclos delay
000192 EFCB F000  00599 	GOTO  m022
                  00600 			;	PDelL2  clrwdt              ; 1 ciclo delay
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 11

ADDR   CODE       LINE  SOURCE

000196 0004       00601 m022	CLRWDT
                  00602 			;	        return              ; 2+2 Fin.
000198 0012       00603 	RETURN
                  00604 			;	;-------------------------------------------------------------
                  00605 			;	#endasm
                  00606 			;}
                  00607 			;void retardo_100m(void){
                  00608 retardo_100m
                  00609 			;	char PDel0,PDel1,PDel2;
                  00610 			;	#asm
                  00611 			;	;-------------------------------------------------------------
                  00612 			;	DEMORA  movlw     .23       ; 1 set numero de repeticion  (C)
00019A 0E17       00613 	MOVLW 23
                  00614 			;	        movwf     PDel0     ; 1 |
00019C 6E7F       00615 	MOVWF PDel0_4,0
                  00616 			;	PLoop0  movlw     .59       ; 1 set numero de repeticion  (B)
00019E 0E3B       00617 m023	MOVLW 59
                  00618 			;	        movwf     PDel1     ; 1 |
0001A0 6E7F       00619 	MOVWF PDel1_3,0
                  00620 			;	PLoop1  movlw     .235      ; 1 set numero de repeticion  (A)
0001A2 0EEB       00621 m024	MOVLW 235
                  00622 			;	        movwf     PDel2     ; 1 |
0001A4 6E7F       00623 	MOVWF PDel2_2,0
                  00624 			;	PLoop2  clrwdt              ; 1 clear watchdog
0001A6 0004       00625 m025	CLRWDT
                  00626 			;	        clrwdt              ; 1 ciclo delay
0001A8 0004       00627 	CLRWDT
                  00628 			;	        decfsz    PDel2, 1  ; 1 + (1) es el tiempo 0  ? (A)
0001AA 2E7F       00629 	DECFSZ PDel2_2,1,0
                  00630 			;	        goto      PLoop2    ; 2 no, loop
0001AC EFD3 F000  00631 	GOTO  m025
                  00632 			;	        decfsz    PDel1,  1 ; 1 + (1) es el tiempo 0  ? (B)
0001B0 2E7F       00633 	DECFSZ PDel1_3,1,0
                  00634 			;	        goto      PLoop1    ; 2 no, loop
0001B2 EFD1 F000  00635 	GOTO  m024
                  00636 			;	        decfsz    PDel0,  1 ; 1 + (1) es el tiempo 0  ? (C)
0001B6 2E7F       00637 	DECFSZ PDel0_4,1,0
                  00638 			;	        goto      PLoop0    ; 2 no, loop
0001B8 EFCF F000  00639 	GOTO  m023
                  00640 			;	        return              ; 2+2 Fin.
0001BC 0012       00641 	RETURN
                  00642 			;	;-------------------------------------------------------------
                  00643 			;	#endasm
                  00644 			;}
                  00645 			;void retardo_500m(void){
                  00646 retardo_500m
                  00647 			;	char PDel0,PDel1,PDel2;
                  00648 			;	#asm
                  00649 			;	;-------------------------------------------------------------
                  00650 			;	DEMORA  movlw     .54       ; 1 set numero de repeticion  (C)
0001BE 0E36       00651 	MOVLW 54
                  00652 			;	        movwf     PDel0     ; 1 |
0001C0 6E7F       00653 	MOVWF PDel0_5,0
                  00654 			;	PLoop0  movlw     .188      ; 1 set numero de repeticion  (B)
0001C2 0EBC       00655 m026	MOVLW 188
                  00656 			;	        movwf     PDel1     ; 1 |
0001C4 6E7F       00657 	MOVWF PDel1_4,0
                  00658 			;	PLoop1  movlw     .196      ; 1 set numero de repeticion  (A)
0001C6 0EC4       00659 m027	MOVLW 196
                  00660 			;	        movwf     PDel2     ; 1 |
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 12

ADDR   CODE       LINE  SOURCE

0001C8 6E7F       00661 	MOVWF PDel2_3,0
                  00662 			;	PLoop2  clrwdt              ; 1 clear watchdog
0001CA 0004       00663 m028	CLRWDT
                  00664 			;	        decfsz    PDel2, 1  ; 1 + (1) es el tiempo 0  ? (A)
0001CC 2E7F       00665 	DECFSZ PDel2_3,1,0
                  00666 			;	        goto      PLoop2    ; 2 no, loop
0001CE EFE5 F000  00667 	GOTO  m028
                  00668 			;	        decfsz    PDel1,  1 ; 1 + (1) es el tiempo 0  ? (B)
0001D2 2E7F       00669 	DECFSZ PDel1_4,1,0
                  00670 			;	        goto      PLoop1    ; 2 no, loop
0001D4 EFE3 F000  00671 	GOTO  m027
                  00672 			;	        decfsz    PDel0,  1 ; 1 + (1) es el tiempo 0  ? (C)
0001D8 2E7F       00673 	DECFSZ PDel0_5,1,0
                  00674 			;	        goto      PLoop0    ; 2 no, loop
0001DA EFE1 F000  00675 	GOTO  m026
                  00676 			;	PDelL1  goto PDelL2         ; 2 ciclos delay
0001DE EFF1 F000  00677 	GOTO  m029
                  00678 			;	PDelL2  clrwdt              ; 1 ciclo delay
0001E2 0004       00679 m029	CLRWDT
                  00680 			;	        return              ; 2+2 Fin.
0001E4 0012       00681 	RETURN
                  00682 			;	;-------------------------------------------------------------
                  00683 			;	#endasm
                  00684 
                  00685   ; FILE LCD_4bit.h
                  00686 			;
                  00687 			;/*
                  00688 			;	ESTA LIBRERIA NO SIRVE PARA LA PLACA DE PROTOTIPOS ES SOLO PARA LA PLACA DEL ONDULADOR!!!!!
                  00689 			;*/
                  00690 			;
                  00691 			;void envia_codigo_inicial (char codigo)
                  00692 			;{
                  00693 envia_codigo_inicial
0001E6 0100       00694 	MOVLB 0
0001E8 6F99       00695 	MOVWF codigo,1
                  00696 			;	PORTB.5=0;nop();
0001EA 9A81       00697 	BCF   PORTB,5,0
0001EC 0000       00698 	NOP  
                  00699 			;	PORTB.3 = codigo.4;
0001EE A999       00700 	BTFSS codigo,4,1
0001F0 9681       00701 	BCF   PORTB,3,0
0001F2 B999       00702 	BTFSC codigo,4,1
0001F4 8681       00703 	BSF   PORTB,3,0
                  00704 			;	nop();
0001F6 0000       00705 	NOP  
                  00706 			;	PORTB.2 = codigo.5;
0001F8 AB99       00707 	BTFSS codigo,5,1
0001FA 9481       00708 	BCF   PORTB,2,0
0001FC BB99       00709 	BTFSC codigo,5,1
0001FE 8481       00710 	BSF   PORTB,2,0
                  00711 			;	nop();
000200 0000       00712 	NOP  
                  00713 			;	PORTB.1 = codigo.6;
000202 AD99       00714 	BTFSS codigo,6,1
000204 9281       00715 	BCF   PORTB,1,0
000206 BD99       00716 	BTFSC codigo,6,1
000208 8281       00717 	BSF   PORTB,1,0
                  00718 			;	nop();
00020A 0000       00719 	NOP  
                  00720 			;	PORTB.0 = codigo.7;
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 13

ADDR   CODE       LINE  SOURCE

00020C AF99       00721 	BTFSS codigo,7,1
00020E 9081       00722 	BCF   PORTB,0,0
000210 BF99       00723 	BTFSC codigo,7,1
000212 8081       00724 	BSF   PORTB,0,0
                  00725 			;	nop();
000214 0000       00726 	NOP  
                  00727 			;	PORTB.4 = 1; 
000216 8881       00728 	BSF   PORTB,4,0
                  00729 			;	retardo_20u();
000218 DF8F       00730 	RCALL retardo_20u
                  00731 			;	PORTB.4 = 0; 
00021A 9881       00732 	BCF   PORTB,4,0
                  00733 			;
                  00734 			;	return;
00021C 0012       00735 	RETURN
                  00736 			;}
                  00737 			; 
                  00738 			;void enviar_comando (char comando) 
                  00739 			;{
                  00740 enviar_comando
00021E 0100       00741 	MOVLB 0
000220 6FB3       00742 	MOVWF comando,1
                  00743 			;	
                  00744 			;	PORTB.3 =  comando.4;nop();
000222 A9B3       00745 	BTFSS comando,4,1
000224 9681       00746 	BCF   PORTB,3,0
000226 B9B3       00747 	BTFSC comando,4,1
000228 8681       00748 	BSF   PORTB,3,0
00022A 0000       00749 	NOP  
                  00750 			;	PORTB.2 =  comando.5;nop();
00022C ABB3       00751 	BTFSS comando,5,1
00022E 9481       00752 	BCF   PORTB,2,0
000230 BBB3       00753 	BTFSC comando,5,1
000232 8481       00754 	BSF   PORTB,2,0
000234 0000       00755 	NOP  
                  00756 			;	PORTB.1 =  comando.6;nop();
000236 ADB3       00757 	BTFSS comando,6,1
000238 9281       00758 	BCF   PORTB,1,0
00023A BDB3       00759 	BTFSC comando,6,1
00023C 8281       00760 	BSF   PORTB,1,0
00023E 0000       00761 	NOP  
                  00762 			;	PORTB.0 =  comando.7;
000240 AFB3       00763 	BTFSS comando,7,1
000242 9081       00764 	BCF   PORTB,0,0
000244 BFB3       00765 	BTFSC comando,7,1
000246 8081       00766 	BSF   PORTB,0,0
                  00767 			;	retardo_1m ();
000248 DF81       00768 	RCALL retardo_1m
                  00769 			;	PORTB.5 = 0;  									// Modo comando.
00024A 9A81       00770 	BCF   PORTB,5,0
                  00771 			;	retardo_20u (); //
00024C DF75       00772 	RCALL retardo_20u
                  00773 			;	PORTB.4 = 1;  									// Breve pulso.
00024E 8881       00774 	BSF   PORTB,4,0
                  00775 			;	retardo_20u ();
000250 DF73       00776 	RCALL retardo_20u
                  00777 			;	PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
000252 9881       00778 	BCF   PORTB,4,0
                  00779 			;	retardo_1m ();
000254 DF7B       00780 	RCALL retardo_1m
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 14

ADDR   CODE       LINE  SOURCE

                  00781 			;	retardo_1m ();
000256 DF7A       00782 	RCALL retardo_1m
                  00783 			;	comando = swap (comando);
000258 0100       00784 	MOVLB 0
00025A 3BB3       00785 	SWAPF comando,1,1
                  00786 			;	PORTB.3 =  comando.4;nop();
00025C A9B3       00787 	BTFSS comando,4,1
00025E 9681       00788 	BCF   PORTB,3,0
000260 B9B3       00789 	BTFSC comando,4,1
000262 8681       00790 	BSF   PORTB,3,0
000264 0000       00791 	NOP  
                  00792 			;	PORTB.2 =  comando.5;nop();
000266 ABB3       00793 	BTFSS comando,5,1
000268 9481       00794 	BCF   PORTB,2,0
00026A BBB3       00795 	BTFSC comando,5,1
00026C 8481       00796 	BSF   PORTB,2,0
00026E 0000       00797 	NOP  
                  00798 			;	PORTB.1 =  comando.6;nop();
000270 ADB3       00799 	BTFSS comando,6,1
000272 9281       00800 	BCF   PORTB,1,0
000274 BDB3       00801 	BTFSC comando,6,1
000276 8281       00802 	BSF   PORTB,1,0
000278 0000       00803 	NOP  
                  00804 			;	PORTB.0 =  comando.7;nop();
00027A AFB3       00805 	BTFSS comando,7,1
00027C 9081       00806 	BCF   PORTB,0,0
00027E BFB3       00807 	BTFSC comando,7,1
000280 8081       00808 	BSF   PORTB,0,0
000282 0000       00809 	NOP  
                  00810 			;	retardo_1m ();
000284 DF63       00811 	RCALL retardo_1m
                  00812 			;	PORTB.5 = 0;  									// Modo comando.
000286 9A81       00813 	BCF   PORTB,5,0
                  00814 			;	retardo_20u ();
000288 DF57       00815 	RCALL retardo_20u
                  00816 			;	PORTB.4 = 1;  									// Breve pulso.
00028A 8881       00817 	BSF   PORTB,4,0
                  00818 			;	retardo_20u ();
00028C DF55       00819 	RCALL retardo_20u
                  00820 			;	PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
00028E 9881       00821 	BCF   PORTB,4,0
                  00822 			;	retardo_1m ();
000290 DF5D       00823 	RCALL retardo_1m
                  00824 			;	retardo_1m ();
000292 D75C       00825 	BRA   retardo_1m
                  00826 			;	//leds_OFF (10);
                  00827 			;	
                  00828 			;	
                  00829 			;	return;
                  00830 			;}    
                  00831 			;
                  00832 			;void enviar_literal (char dato) 
                  00833 			;{
                  00834 enviar_literal
000294 0100       00835 	MOVLB 0
000296 6F99       00836 	MOVWF dato,1
                  00837 			;    char i;
                  00838 			;
                  00839 			;	
                  00840 			;	PORTB.3 = dato.4;
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 15

ADDR   CODE       LINE  SOURCE

000298 A999       00841 	BTFSS dato,4,1
00029A 9681       00842 	BCF   PORTB,3,0
00029C B999       00843 	BTFSC dato,4,1
00029E 8681       00844 	BSF   PORTB,3,0
                  00845 			;	nop();
0002A0 0000       00846 	NOP  
                  00847 			;	PORTB.2 = dato.5;
0002A2 AB99       00848 	BTFSS dato,5,1
0002A4 9481       00849 	BCF   PORTB,2,0
0002A6 BB99       00850 	BTFSC dato,5,1
0002A8 8481       00851 	BSF   PORTB,2,0
                  00852 			;	nop();
0002AA 0000       00853 	NOP  
                  00854 			;	PORTB.1 = dato.6;
0002AC AD99       00855 	BTFSS dato,6,1
0002AE 9281       00856 	BCF   PORTB,1,0
0002B0 BD99       00857 	BTFSC dato,6,1
0002B2 8281       00858 	BSF   PORTB,1,0
                  00859 			;	nop();
0002B4 0000       00860 	NOP  
                  00861 			;	PORTB.0 = dato.7;
0002B6 AF99       00862 	BTFSS dato,7,1
0002B8 9081       00863 	BCF   PORTB,0,0
0002BA BF99       00864 	BTFSC dato,7,1
0002BC 8081       00865 	BSF   PORTB,0,0
                  00866 			;	nop();
0002BE 0000       00867 	NOP  
                  00868 			;	PORTB.5 = 1;  									// Modo dato.
0002C0 8A81       00869 	BSF   PORTB,5,0
                  00870 			;	retardo_20u ();
0002C2 DF3A       00871 	RCALL retardo_20u
                  00872 			;	PORTB.4 = 1;  									// Breve pulso.
0002C4 8881       00873 	BSF   PORTB,4,0
                  00874 			;	retardo_20u ();
0002C6 DF38       00875 	RCALL retardo_20u
                  00876 			;	PORTB.4 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
0002C8 9881       00877 	BCF   PORTB,4,0
                  00878 			;	for (i = 1; i <= 6; i++) retardo_20u ();
0002CA 0E01       00879 	MOVLW 1
0002CC 0100       00880 	MOVLB 0
0002CE 6F9A       00881 	MOVWF i_2,1
0002D0 0E07       00882 m030	MOVLW 7
0002D2 0100       00883 	MOVLB 0
0002D4 619A       00884 	CPFSLT i_2,1
0002D6 D004       00885 	BRA   m031
0002D8 DF2F       00886 	RCALL retardo_20u
0002DA 0100       00887 	MOVLB 0
0002DC 2B9A       00888 	INCF  i_2,1,1
0002DE D7F8       00889 	BRA   m030
                  00890 			;	dato = swap (dato);
0002E0 0100       00891 m031	MOVLB 0
0002E2 3B99       00892 	SWAPF dato,1,1
                  00893 			;	PORTB.3 = dato.4;nop();
0002E4 A999       00894 	BTFSS dato,4,1
0002E6 9681       00895 	BCF   PORTB,3,0
0002E8 B999       00896 	BTFSC dato,4,1
0002EA 8681       00897 	BSF   PORTB,3,0
0002EC 0000       00898 	NOP  
                  00899 			;	PORTB.2 = dato.5;nop();
0002EE AB99       00900 	BTFSS dato,5,1
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 16

ADDR   CODE       LINE  SOURCE

0002F0 9481       00901 	BCF   PORTB,2,0
0002F2 BB99       00902 	BTFSC dato,5,1
0002F4 8481       00903 	BSF   PORTB,2,0
0002F6 0000       00904 	NOP  
                  00905 			;	PORTB.1 = dato.6;nop();
0002F8 AD99       00906 	BTFSS dato,6,1
0002FA 9281       00907 	BCF   PORTB,1,0
0002FC BD99       00908 	BTFSC dato,6,1
0002FE 8281       00909 	BSF   PORTB,1,0
000300 0000       00910 	NOP  
                  00911 			;	PORTB.0 = dato.7;nop();
000302 AF99       00912 	BTFSS dato,7,1
000304 9081       00913 	BCF   PORTB,0,0
000306 BF99       00914 	BTFSC dato,7,1
000308 8081       00915 	BSF   PORTB,0,0
00030A 0000       00916 	NOP  
                  00917 			;	retardo_1m ();
00030C DF1F       00918 	RCALL retardo_1m
                  00919 			;	PORTB.5 = 1;  									// Modo dato.
00030E 8A81       00920 	BSF   PORTB,5,0
                  00921 			;	retardo_1m ();
000310 DF1D       00922 	RCALL retardo_1m
                  00923 			;	PORTB.4 = 1;  									// Breve pulso.
000312 8881       00924 	BSF   PORTB,4,0
                  00925 			;	retardo_20u ();
000314 DF11       00926 	RCALL retardo_20u
                  00927 			;	PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
000316 9881       00928 	BCF   PORTB,4,0
                  00929 			;	for (i = 1; i<= 6; i++) retardo_20u ();
000318 0E01       00930 	MOVLW 1
00031A 0100       00931 	MOVLB 0
00031C 6F9A       00932 	MOVWF i_2,1
00031E 0E07       00933 m032	MOVLW 7
000320 0100       00934 	MOVLB 0
000322 619A       00935 	CPFSLT i_2,1
000324 D004       00936 	BRA   m033
000326 DF08       00937 	RCALL retardo_20u
000328 0100       00938 	MOVLB 0
00032A 2B9A       00939 	INCF  i_2,1,1
00032C D7F8       00940 	BRA   m032
                  00941 			;	enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.	
00032E 0E0C       00942 m033	MOVLW 12
000330 D776       00943 	BRA   enviar_comando
                  00944 			;	return;
                  00945 			;}   
                  00946 			;
                  00947 			;void enviar_cifra (char dato) 
                  00948 			;{
                  00949 enviar_cifra
000332 6E7F       00950 	MOVWF dato_2,0
                  00951 			;    char i;
                  00952 			;	dato = dato + 0x30; 							// Convierto el n˙mero en su equivalente ASCII literal. 
000334 0E30       00953 	MOVLW 48
000336 267F       00954 	ADDWF dato_2,1,0
                  00955 			;	PORTB.3 = dato.4;
000338 A87F       00956 	BTFSS dato_2,4,0
00033A 9681       00957 	BCF   PORTB,3,0
00033C B87F       00958 	BTFSC dato_2,4,0
00033E 8681       00959 	BSF   PORTB,3,0
                  00960 			;	nop();
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 17

ADDR   CODE       LINE  SOURCE

000340 0000       00961 	NOP  
                  00962 			;	PORTB.2 = dato.5;
000342 AA7F       00963 	BTFSS dato_2,5,0
000344 9481       00964 	BCF   PORTB,2,0
000346 BA7F       00965 	BTFSC dato_2,5,0
000348 8481       00966 	BSF   PORTB,2,0
                  00967 			;	nop();
00034A 0000       00968 	NOP  
                  00969 			;	PORTB.1 = dato.6;
00034C AC7F       00970 	BTFSS dato_2,6,0
00034E 9281       00971 	BCF   PORTB,1,0
000350 BC7F       00972 	BTFSC dato_2,6,0
000352 8281       00973 	BSF   PORTB,1,0
                  00974 			;	nop();
000354 0000       00975 	NOP  
                  00976 			;	PORTB.0 = dato.7;
000356 AE7F       00977 	BTFSS dato_2,7,0
000358 9081       00978 	BCF   PORTB,0,0
00035A BE7F       00979 	BTFSC dato_2,7,0
00035C 8081       00980 	BSF   PORTB,0,0
                  00981 			;	nop();
00035E 0000       00982 	NOP  
                  00983 			;	PORTB.5 = 1;  									// Modo dato.
000360 8A81       00984 	BSF   PORTB,5,0
                  00985 			;	retardo_20u ();
000362 DEEA       00986 	RCALL retardo_20u
                  00987 			;	PORTB.4 = 1;  									// Breve pulso.
000364 8881       00988 	BSF   PORTB,4,0
                  00989 			;	retardo_20u ();
000366 DEE8       00990 	RCALL retardo_20u
                  00991 			;	PORTB.4 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
000368 9881       00992 	BCF   PORTB,4,0
                  00993 			;	for (i = 1; i <= 6; i++) retardo_20u ();
00036A 0E01       00994 	MOVLW 1
00036C 6E7F       00995 	MOVWF i_3,0
00036E 0E07       00996 m034	MOVLW 7
000370 607F       00997 	CPFSLT i_3,0
000372 D003       00998 	BRA   m035
000374 DEE1       00999 	RCALL retardo_20u
000376 2A7F       01000 	INCF  i_3,1,0
000378 D7FA       01001 	BRA   m034
                  01002 			;	dato = swap (dato);
00037A 3A7F       01003 m035	SWAPF dato_2,1,0
                  01004 			;	PORTB.3 = dato.4;
00037C A87F       01005 	BTFSS dato_2,4,0
00037E 9681       01006 	BCF   PORTB,3,0
000380 B87F       01007 	BTFSC dato_2,4,0
000382 8681       01008 	BSF   PORTB,3,0
                  01009 			;	nop();
000384 0000       01010 	NOP  
                  01011 			;	PORTB.2 = dato.5;
000386 AA7F       01012 	BTFSS dato_2,5,0
000388 9481       01013 	BCF   PORTB,2,0
00038A BA7F       01014 	BTFSC dato_2,5,0
00038C 8481       01015 	BSF   PORTB,2,0
                  01016 			;	nop();
00038E 0000       01017 	NOP  
                  01018 			;	PORTB.1 = dato.6;
000390 AC7F       01019 	BTFSS dato_2,6,0
000392 9281       01020 	BCF   PORTB,1,0
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 18

ADDR   CODE       LINE  SOURCE

000394 BC7F       01021 	BTFSC dato_2,6,0
000396 8281       01022 	BSF   PORTB,1,0
                  01023 			;	nop();
000398 0000       01024 	NOP  
                  01025 			;	PORTB.0 = dato.7;
00039A AE7F       01026 	BTFSS dato_2,7,0
00039C 9081       01027 	BCF   PORTB,0,0
00039E BE7F       01028 	BTFSC dato_2,7,0
0003A0 8081       01029 	BSF   PORTB,0,0
                  01030 			;	retardo_1m ();
0003A2 DED4       01031 	RCALL retardo_1m
                  01032 			;	PORTB.5 = 1;  									// Modo dato.
0003A4 8A81       01033 	BSF   PORTB,5,0
                  01034 			;	retardo_1m ();
0003A6 DED2       01035 	RCALL retardo_1m
                  01036 			;	PORTB.4 = 1;  									// Breve pulso.
0003A8 8881       01037 	BSF   PORTB,4,0
                  01038 			;	retardo_20u ();
0003AA DEC6       01039 	RCALL retardo_20u
                  01040 			;	PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
0003AC 9881       01041 	BCF   PORTB,4,0
                  01042 			;	for (i = 1; i<= 6; i++) retardo_20u ();
0003AE 0E01       01043 	MOVLW 1
0003B0 6E7F       01044 	MOVWF i_3,0
0003B2 0E07       01045 m036	MOVLW 7
0003B4 607F       01046 	CPFSLT i_3,0
0003B6 D003       01047 	BRA   m037
0003B8 DEBF       01048 	RCALL retardo_20u
0003BA 2A7F       01049 	INCF  i_3,1,0
0003BC D7FA       01050 	BRA   m036
                  01051 			;	enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.
0003BE 0E0C       01052 m037	MOVLW 12
0003C0 D72E       01053 	BRA   enviar_comando
                  01054 			;	return;
                  01055 			;} 
                  01056 			;
                  01057 			;void inicializar_lcd (void) 
                  01058 			;{
                  01059 inicializar_lcd
                  01060 			;	char i;
                  01061 			;	clrwdt () ;	
0003C2 0004       01062 	CLRWDT
                  01063 			;	for (i = 1; i < 21; i++) retardo_1m ();    
0003C4 0E01       01064 	MOVLW 1
0003C6 0100       01065 	MOVLB 0
0003C8 6F98       01066 	MOVWF i_4,1
0003CA 0E15       01067 m038	MOVLW 21
0003CC 0100       01068 	MOVLB 0
0003CE 6198       01069 	CPFSLT i_4,1
0003D0 D004       01070 	BRA   m039
0003D2 DEBC       01071 	RCALL retardo_1m
0003D4 0100       01072 	MOVLB 0
0003D6 2B98       01073 	INCF  i_4,1,1
0003D8 D7F8       01074 	BRA   m038
                  01075 			;	envia_codigo_inicial (0b.00.11.0000);
0003DA 0E30       01076 m039	MOVLW 48
0003DC DF04       01077 	RCALL envia_codigo_inicial
                  01078 			;	for (i = 1; i < 6; i++) retardo_1m ();
0003DE 0E01       01079 	MOVLW 1
0003E0 0100       01080 	MOVLB 0
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 19

ADDR   CODE       LINE  SOURCE

0003E2 6F98       01081 	MOVWF i_4,1
0003E4 0E06       01082 m040	MOVLW 6
0003E6 0100       01083 	MOVLB 0
0003E8 6198       01084 	CPFSLT i_4,1
0003EA D004       01085 	BRA   m041
0003EC DEAF       01086 	RCALL retardo_1m
0003EE 0100       01087 	MOVLB 0
0003F0 2B98       01088 	INCF  i_4,1,1
0003F2 D7F8       01089 	BRA   m040
                  01090 			;    envia_codigo_inicial (0b.00.11.0000);	
0003F4 0E30       01091 m041	MOVLW 48
0003F6 DEF7       01092 	RCALL envia_codigo_inicial
                  01093 			;	for (i = 1; i< 11; i++) retardo_20u ();
0003F8 0E01       01094 	MOVLW 1
0003FA 0100       01095 	MOVLB 0
0003FC 6F98       01096 	MOVWF i_4,1
0003FE 0E0B       01097 m042	MOVLW 11
000400 0100       01098 	MOVLB 0
000402 6198       01099 	CPFSLT i_4,1
000404 D004       01100 	BRA   m043
000406 DE98       01101 	RCALL retardo_20u
000408 0100       01102 	MOVLB 0
00040A 2B98       01103 	INCF  i_4,1,1
00040C D7F8       01104 	BRA   m042
                  01105 			;    envia_codigo_inicial (0b.00.11.0000);
00040E 0E30       01106 m043	MOVLW 48
000410 DEEA       01107 	RCALL envia_codigo_inicial
                  01108 			;	for (i = 1; i < 11; i++) retardo_20u ();
000412 0E01       01109 	MOVLW 1
000414 0100       01110 	MOVLB 0
000416 6F98       01111 	MOVWF i_4,1
000418 0E0B       01112 m044	MOVLW 11
00041A 0100       01113 	MOVLB 0
00041C 6198       01114 	CPFSLT i_4,1
00041E D004       01115 	BRA   m045
000420 DE8B       01116 	RCALL retardo_20u
000422 0100       01117 	MOVLB 0
000424 2B98       01118 	INCF  i_4,1,1
000426 D7F8       01119 	BRA   m044
                  01120 			;	envia_codigo_inicial (0b.00.10.0000);			// A 4 bits.
000428 0E20       01121 m045	MOVLW 32
00042A DEDD       01122 	RCALL envia_codigo_inicial
                  01123 			;	enviar_comando (0b.0010.1000);					// A 4 bits, doble lÌnea, caracteres 5x7.
00042C 0E28       01124 	MOVLW 40
00042E DEF7       01125 	RCALL enviar_comando
                  01126 			;	enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.
000430 0E0C       01127 	MOVLW 12
000432 DEF5       01128 	RCALL enviar_comando
                  01129 			;	enviar_comando (0b.0000.0010);  				// Cursor en home, inicio de primera linea.
000434 0E02       01130 	MOVLW 2
000436 D6F3       01131 	BRA   enviar_comando
                  01132 			;	return;
                  01133 			;}
                  01134 			;
                  01135 			;void escribir_posicion (char linea, char columna)
                  01136 			;{
                  01137 escribir_posicion
000438 0100       01138 	MOVLB 0
00043A 6F99       01139 	MOVWF columna,1
                  01140 			;	
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 20

ADDR   CODE       LINE  SOURCE

                  01141 			;	switch (linea) 									// (se resta una unidad a la coordenada lÌnea para que la posiciÛn colum
                           na inicial sea 1 y no 0).
00043C 5198       01142 	MOVF  linea,W,1
00043E 0A01       01143 	XORLW 1
000440 B4D8       01144 	BTFSC 0xFD8,Zero_,0
000442 D00A       01145 	BRA   m046
000444 0A03       01146 	XORLW 3
000446 B4D8       01147 	BTFSC 0xFD8,Zero_,0
000448 D00C       01148 	BRA   m047
00044A 0A01       01149 	XORLW 1
00044C B4D8       01150 	BTFSC 0xFD8,Zero_,0
00044E D00E       01151 	BRA   m048
000450 0A07       01152 	XORLW 7
000452 B4D8       01153 	BTFSC 0xFD8,Zero_,0
000454 D010       01154 	BRA   m049
000456 D016       01155 	BRA   m050
                  01156 			;		{
                  01157 			;			case 1:
                  01158 			;				enviar_comando (127 + columna); 	// Inicio primera linea.
000458 0E7F       01159 m046	MOVLW 127
00045A 0100       01160 	MOVLB 0
00045C 2599       01161 	ADDWF columna,W,1
00045E DEDF       01162 	RCALL enviar_comando
                  01163 			;			break;
000460 D011       01164 	BRA   m050
                  01165 			;						
                  01166 			;			case 2:
                  01167 			;				enviar_comando (191 + columna); 	// Inicio segunda lÌnea.
000462 0EBF       01168 m047	MOVLW 191
000464 0100       01169 	MOVLB 0
000466 2599       01170 	ADDWF columna,W,1
000468 DEDA       01171 	RCALL enviar_comando
                  01172 			;			break;			
00046A D00C       01173 	BRA   m050
                  01174 			;
                  01175 			;			case 3:
                  01176 			;				enviar_comando (147 + columna);		// Inicio tercera lÌnea (cursor en posiciÛn 20 de la primera lÌnea).
00046C 0E93       01177 m048	MOVLW 147
00046E 0100       01178 	MOVLB 0
000470 2599       01179 	ADDWF columna,W,1
000472 DED5       01180 	RCALL enviar_comando
                  01181 			;			break;				
000474 D007       01182 	BRA   m050
                  01183 			;			
                  01184 			;			case 4:
                  01185 			;				enviar_comando (211 + columna); 	// Inicio cuarta lÌnea (cursor en posiciÛn 20 de la segunda lÌnea).
000476 0ED3       01186 m049	MOVLW 211
000478 0100       01187 	MOVLB 0
00047A 2599       01188 	ADDWF columna,W,1
00047C DED0       01189 	RCALL enviar_comando
                  01190 			;			break;
00047E D002       01191 	BRA   m050
                  01192 			;			enviar_comando (0b.0000.1100);			// Pantalla encendida, sin cursor.
000480 0E0C       01193 	MOVLW 12
000482 D6CD       01194 	BRA   enviar_comando
                  01195 			;		}
                  01196 			;	
                  01197 			;	
                  01198 			;}
000484 0012       01199 m050	RETURN
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 21

ADDR   CODE       LINE  SOURCE

                  01200 			;
                  01201 			;void borrar_linea (char linea)
                  01202 			;{
                  01203 borrar_linea
000486 6E7F       01204 	MOVWF linea_2,0
                  01205 			;	char i;
                  01206 			;		
                  01207 			;	switch (linea) 									// (se resta una unidad a la coordenada lÌnea para que la posiciÛn colum
                           na inicial sea 1 y no 0).
000488 507F       01208 	MOVF  linea_2,W,0
00048A 0A01       01209 	XORLW 1
00048C B4D8       01210 	BTFSC 0xFD8,Zero_,0
00048E D00A       01211 	BRA   m051
000490 0A03       01212 	XORLW 3
000492 B4D8       01213 	BTFSC 0xFD8,Zero_,0
000494 D00A       01214 	BRA   m052
000496 0A01       01215 	XORLW 1
000498 B4D8       01216 	BTFSC 0xFD8,Zero_,0
00049A D00A       01217 	BRA   m053
00049C 0A07       01218 	XORLW 7
00049E B4D8       01219 	BTFSC 0xFD8,Zero_,0
0004A0 D00A       01220 	BRA   m054
0004A2 D00B       01221 	BRA   m055
                  01222 			;		{
                  01223 			;			case 1:
                  01224 			;				enviar_comando (128); 				// Inicio primera linea.
0004A4 0E80       01225 m051	MOVLW 128
0004A6 DEBB       01226 	RCALL enviar_comando
                  01227 			;			break;
0004A8 D008       01228 	BRA   m055
                  01229 			;						
                  01230 			;			case 2:
                  01231 			;				enviar_comando (192); 				// Inicio segunda lÌnea.
0004AA 0EC0       01232 m052	MOVLW 192
0004AC DEB8       01233 	RCALL enviar_comando
                  01234 			;			break;			
0004AE D005       01235 	BRA   m055
                  01236 			;
                  01237 			;			case 3:
                  01238 			;				enviar_comando (148); 				// Inicio tercera lÌnea (cursor en posiciÛn 20 de la primera lÌnea).
0004B0 0E94       01239 m053	MOVLW 148
0004B2 DEB5       01240 	RCALL enviar_comando
                  01241 			;			break;				
0004B4 D002       01242 	BRA   m055
                  01243 			;			
                  01244 			;			case 4:
                  01245 			;				enviar_comando (212); 				// Inicio cuarta lÌnea (cursor en posiciÛn 20 de la segunda lÌnea).
0004B6 0ED4       01246 m054	MOVLW 212
0004B8 DEB2       01247 	RCALL enviar_comando
                  01248 			;			break;
                  01249 			;		}
                  01250 			;	for (i = 1; i < 21; i++) enviar_literal (' '); 	// Envio 20 car·cteres en blanco y posiciono en la siguiente lÌnea.
0004BA 0E01       01251 m055	MOVLW 1
0004BC 6E7F       01252 	MOVWF i_5,0
0004BE 0E15       01253 m056	MOVLW 21
0004C0 607F       01254 	CPFSLT i_5,0
0004C2 D004       01255 	BRA   m057
0004C4 0E20       01256 	MOVLW 32
0004C6 DEE6       01257 	RCALL enviar_literal
0004C8 2A7F       01258 	INCF  i_5,1,0
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 22

ADDR   CODE       LINE  SOURCE

0004CA D7F9       01259 	BRA   m056
                  01260 			;	enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.	
0004CC 0E0C       01261 m057	MOVLW 12
0004CE D6A7       01262 	BRA   enviar_comando
                  01263 			;}
                  01264 			;
                  01265 			;void borrar_lcd (void)
                  01266 			;{
                  01267 borrar_lcd
                  01268 			;	enviar_comando (0b.0000.0001);  				// Borrado del display y cursor en la posiciÛn inicial.	
0004D0 0E01       01269 	MOVLW 1
0004D2 D6A5       01270 	BRA   enviar_comando
                  01271 			;}
                  01272 			;
                  01273 			;void Enviar_lcd (char linea, char columna, uns16 dato, bit bd, bit dp, bit xi,bit ndp)
                  01274 			;            //fila , col , uns16 , bd -> si 0 posa espai si "0" a l'esquerra ,, dp -> si "0"--> posa punt decimal
                  01275 			;{
                  01276 Enviar_lcd
                  01277 			;// Aquesta funcio, posiciona Fila i Columna d'un LCD 4x20 i envia una xifra uns16 descomposant-la i posant 
                  01278 			;//  decimal o no, segons sigui dp, si "0"--> posa punt decimal , si dp "1" -> no posa dp
                  01279 			;//  si bd = "0" -> posa espai, si bd = "1"  --> No  posa espai i posa el 0.
                  01280 			;// si xi = 0 -> 3 xifres,, si xi = 1  -> 4 xifres
                  01281 			;// Atencio, amb dp S'UTILIZA un ESPAI MES
                  01282 			;// amb 4 xifres, tambe es representen 3, pero es gasta un espai de mes.
                  01283 			;// ESPI utilitzat...3 per 3 xifres,, 4 per 3xifres + dp   O 4xifres s/dp ,, 5 per 4 xifres + dp
                  01284 			;// ndp ..si "0"...1decimal... si "1"   2 decimals
                  01285 			;	uns16 num, u_milers, cent;
                  01286 			;	char dec, unid, resto1;
                  01287 			;	char i, xx, yy, dat,xy;
                  01288 			;	
                  01289 			;	//CON_LCD ();
                  01290 			;	//posiciono
                  01291 			;	switch (linea) 									// (se resta una unidad a la coordenada lÌnea para que la posiciÛn colum
                           na inicial sea 1 y no 0).
0004D4 507F       01292 	MOVF  linea_3,W,0
0004D6 0A01       01293 	XORLW 1
0004D8 B4D8       01294 	BTFSC 0xFD8,Zero_,0
0004DA D00A       01295 	BRA   m058
0004DC 0A03       01296 	XORLW 3
0004DE B4D8       01297 	BTFSC 0xFD8,Zero_,0
0004E0 D00B       01298 	BRA   m059
0004E2 0A01       01299 	XORLW 1
0004E4 B4D8       01300 	BTFSC 0xFD8,Zero_,0
0004E6 D00C       01301 	BRA   m060
0004E8 0A07       01302 	XORLW 7
0004EA B4D8       01303 	BTFSC 0xFD8,Zero_,0
0004EC D00D       01304 	BRA   m061
0004EE D012       01305 	BRA   m062
                  01306 			;		{
                  01307 			;			case 1:	enviar_comando (127 + columna); 	// inicio primera linea.
0004F0 0E7F       01308 m058	MOVLW 127
0004F2 247F       01309 	ADDWF columna_2,W,0
0004F4 DE94       01310 	RCALL enviar_comando
                  01311 			;			break;	
0004F6 D00E       01312 	BRA   m062
                  01313 			;			case 2:	enviar_comando (191 + columna); 	// inicio segunda lÌnea.
0004F8 0EBF       01314 m059	MOVLW 191
0004FA 247F       01315 	ADDWF columna_2,W,0
0004FC DE90       01316 	RCALL enviar_comando
                  01317 			;			break;			
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 23

ADDR   CODE       LINE  SOURCE

0004FE D00A       01318 	BRA   m062
                  01319 			;			case 3:	enviar_comando (147 + columna); 	// inicio tercera lÌnea (cursor en posiciÛn 20 de la primera lÌnea).
000500 0E93       01320 m060	MOVLW 147
000502 247F       01321 	ADDWF columna_2,W,0
000504 DE8C       01322 	RCALL enviar_comando
                  01323 			;			break;				
000506 D006       01324 	BRA   m062
                  01325 			;			case 4:	enviar_comando (211 + columna); 	// inicio cuarta lÌnea (cursor en posiciÛn 20 de la segunda lÌnea).
000508 0ED3       01326 m061	MOVLW 211
00050A 247F       01327 	ADDWF columna_2,W,0
00050C DE88       01328 	RCALL enviar_comando
                  01329 			;			break;	
00050E D002       01330 	BRA   m062
                  01331 			;			enviar_comando (0b.0000.1100);			// pantalla encendida, sin cursor
000510 0E0C       01332 	MOVLW 12
000512 DE85       01333 	RCALL enviar_comando
                  01334 			;		}				
                  01335 			;		if (!xi)
000514 B07F       01336 m062	BTFSC 0xF7F,xi,0
000516 D011       01337 	BRA   m063
                  01338 			;		{
                  01339 			;			xy = 2;
000518 0E02       01340 	MOVLW 2
00051A 6E7F       01341 	MOVWF xy,0
                  01342 			;			u_milers = 0;
00051C 6A7F       01343 	CLRF  u_milers,0
00051E 6A7F       01344 	CLRF  u_milers+1,0
                  01345 			;			if (dato > 999) { enviar_literal ('>');enviar_literal ('E');enviar_literal ('r'); goto so; }
000520 0EE8       01346 	MOVLW 232
000522 5C7F       01347 	SUBWF dato_3,W,0
000524 0E03       01348 	MOVLW 3
000526 587F       01349 	SUBWFB dato_3+1,W,0
000528 A0D8       01350 	BTFSS 0xFD8,Carry,0
00052A D04D       01351 	BRA   m069
00052C 0E3E       01352 	MOVLW 62
00052E DEB2       01353 	RCALL enviar_literal
000530 0E45       01354 	MOVLW 69
000532 DEB0       01355 	RCALL enviar_literal
000534 0E72       01356 	MOVLW 114
000536 DEAE       01357 	RCALL enviar_literal
000538 D13B       01358 	BRA   m099
                  01359 			;		    else goto sa;
                  01360 			;		}
                  01361 			;		else
                  01362 			;		{
                  01363 			;			xy = 1;
00053A 0E01       01364 m063	MOVLW 1
00053C 6E7F       01365 	MOVWF xy,0
                  01366 			;			if (dato > 9999) { enviar_literal ('>');enviar_literal ('E');enviar_literal ('r'); goto so; }
00053E 0E10       01367 	MOVLW 16
000540 5C7F       01368 	SUBWF dato_3,W,0
000542 0E27       01369 	MOVLW 39
000544 587F       01370 	SUBWFB dato_3+1,W,0
000546 A0D8       01371 	BTFSS 0xFD8,Carry,0
000548 D007       01372 	BRA   m064
00054A 0E3E       01373 	MOVLW 62
00054C DEA3       01374 	RCALL enviar_literal
00054E 0E45       01375 	MOVLW 69
000550 DEA1       01376 	RCALL enviar_literal
000552 0E72       01377 	MOVLW 114
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 24

ADDR   CODE       LINE  SOURCE

000554 DE9F       01378 	RCALL enviar_literal
000556 D12C       01379 	BRA   m099
                  01380 			;		}
                  01381 			;			// Separo per 4 xifres
                  01382 			;			num = dato; // per 4 xifres
000558 CF7F FF7F  01383 m064	MOVFF dato_3,num
00055C CF7F FF7F  01384 	MOVFF dato_3+1,num+1
                  01385 			;			u_milers = num / 1000;
000560 507F       01386 	MOVF  num,W,0
000562 6E7F       01387 	MOVWF C7tmp,0
000564 507F       01388 	MOVF  num+1,W,0
000566 6E7F       01389 	MOVWF C7tmp+1,0
000568 6A7F       01390 	CLRF  C8rem,0
00056A 6A7F       01391 	CLRF  C8rem+1,0
00056C 0E10       01392 	MOVLW 16
00056E 6E7F       01393 	MOVWF C6cnt,0
000570 367F       01394 m065	RLCF  C7tmp,1,0
000572 367F       01395 	RLCF  C7tmp+1,1,0
000574 367F       01396 	RLCF  C8rem,1,0
000576 367F       01397 	RLCF  C8rem+1,1,0
000578 0EE8       01398 	MOVLW 232
00057A 5C7F       01399 	SUBWF C8rem,W,0
00057C 0E03       01400 	MOVLW 3
00057E 587F       01401 	SUBWFB C8rem+1,W,0
000580 A0D8       01402 	BTFSS 0xFD8,Carry,0
000582 D005       01403 	BRA   m066
000584 0EE8       01404 	MOVLW 232
000586 5E7F       01405 	SUBWF C8rem,1,0
000588 0E03       01406 	MOVLW 3
00058A 5A7F       01407 	SUBWFB C8rem+1,1,0
00058C 80D8       01408 	BSF   0xFD8,Carry,0
00058E 367F       01409 m066	RLCF  u_milers,1,0
000590 367F       01410 	RLCF  u_milers+1,1,0
000592 2E7F       01411 	DECFSZ C6cnt,1,0
000594 D7ED       01412 	BRA   m065
                  01413 			;			dato = num % 1000;
000596 507F       01414 	MOVF  num,W,0
000598 6E7F       01415 	MOVWF C10tmp,0
00059A 507F       01416 	MOVF  num+1,W,0
00059C 6E7F       01417 	MOVWF C10tmp+1,0
00059E 6A7F       01418 	CLRF  dato_3,0
0005A0 6A7F       01419 	CLRF  dato_3+1,0
0005A2 0E10       01420 	MOVLW 16
0005A4 6E7F       01421 	MOVWF C9cnt,0
0005A6 367F       01422 m067	RLCF  C10tmp,1,0
0005A8 367F       01423 	RLCF  C10tmp+1,1,0
0005AA 367F       01424 	RLCF  dato_3,1,0
0005AC 367F       01425 	RLCF  dato_3+1,1,0
0005AE 0EE8       01426 	MOVLW 232
0005B0 5C7F       01427 	SUBWF dato_3,W,0
0005B2 0E03       01428 	MOVLW 3
0005B4 587F       01429 	SUBWFB dato_3+1,W,0
0005B6 A0D8       01430 	BTFSS 0xFD8,Carry,0
0005B8 D004       01431 	BRA   m068
0005BA 0EE8       01432 	MOVLW 232
0005BC 5E7F       01433 	SUBWF dato_3,1,0
0005BE 0E03       01434 	MOVLW 3
0005C0 5A7F       01435 	SUBWFB dato_3+1,1,0
0005C2 2E7F       01436 m068	DECFSZ C9cnt,1,0
0005C4 D7F0       01437 	BRA   m067
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 25

ADDR   CODE       LINE  SOURCE

                  01438 			;			// Separo per 3 xifres
                  01439 			;sa:			cent   = dato   / 100;   	
0005C6 507F       01440 m069	MOVF  dato_3,W,0
0005C8 6E7F       01441 	MOVWF C12tmp,0
0005CA 507F       01442 	MOVF  dato_3+1,W,0
0005CC 6E7F       01443 	MOVWF C12tmp+1,0
0005CE 6A7F       01444 	CLRF  C13rem,0
0005D0 0E10       01445 	MOVLW 16
0005D2 6E7F       01446 	MOVWF C11cnt,0
0005D4 367F       01447 m070	RLCF  C12tmp,1,0
0005D6 367F       01448 	RLCF  C12tmp+1,1,0
0005D8 367F       01449 	RLCF  C13rem,1,0
0005DA B0D8       01450 	BTFSC 0xFD8,Carry,0
0005DC D004       01451 	BRA   m071
0005DE 0E64       01452 	MOVLW 100
0005E0 5C7F       01453 	SUBWF C13rem,W,0
0005E2 A0D8       01454 	BTFSS 0xFD8,Carry,0
0005E4 D003       01455 	BRA   m072
0005E6 0E64       01456 m071	MOVLW 100
0005E8 5E7F       01457 	SUBWF C13rem,1,0
0005EA 80D8       01458 	BSF   0xFD8,Carry,0
0005EC 367F       01459 m072	RLCF  cent,1,0
0005EE 367F       01460 	RLCF  cent+1,1,0
0005F0 2E7F       01461 	DECFSZ C11cnt,1,0
0005F2 D7F0       01462 	BRA   m070
                  01463 			;			resto1 = dato   % 100;
0005F4 507F       01464 	MOVF  dato_3,W,0
0005F6 6E7F       01465 	MOVWF C15tmp,0
0005F8 507F       01466 	MOVF  dato_3+1,W,0
0005FA 6E7F       01467 	MOVWF C15tmp+1,0
0005FC 6A7F       01468 	CLRF  resto1,0
0005FE 0E10       01469 	MOVLW 16
000600 6E7F       01470 	MOVWF C14cnt,0
000602 367F       01471 m073	RLCF  C15tmp,1,0
000604 367F       01472 	RLCF  C15tmp+1,1,0
000606 367F       01473 	RLCF  resto1,1,0
000608 B0D8       01474 	BTFSC 0xFD8,Carry,0
00060A D004       01475 	BRA   m074
00060C 0E64       01476 	MOVLW 100
00060E 5C7F       01477 	SUBWF resto1,W,0
000610 A0D8       01478 	BTFSS 0xFD8,Carry,0
000612 D002       01479 	BRA   m075
000614 0E64       01480 m074	MOVLW 100
000616 5E7F       01481 	SUBWF resto1,1,0
000618 2E7F       01482 m075	DECFSZ C14cnt,1,0
00061A D7F3       01483 	BRA   m073
                  01484 			;			dec    = resto1 /  10;  
00061C 507F       01485 	MOVF  resto1,W,0
00061E 6E7F       01486 	MOVWF C17tmp,0
000620 6A7F       01487 	CLRF  C18rem,0
000622 0E08       01488 	MOVLW 8
000624 6E7F       01489 	MOVWF C16cnt,0
000626 367F       01490 m076	RLCF  C17tmp,1,0
000628 367F       01491 	RLCF  C18rem,1,0
00062A 0E0A       01492 	MOVLW 10
00062C 5C7F       01493 	SUBWF C18rem,W,0
00062E A0D8       01494 	BTFSS 0xFD8,Carry,0
000630 D003       01495 	BRA   m077
000632 0E0A       01496 	MOVLW 10
000634 5E7F       01497 	SUBWF C18rem,1,0
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 26

ADDR   CODE       LINE  SOURCE

000636 80D8       01498 	BSF   0xFD8,Carry,0
000638 367F       01499 m077	RLCF  dec,1,0
00063A 2E7F       01500 	DECFSZ C16cnt,1,0
00063C D7F4       01501 	BRA   m076
                  01502 			;			unid   = resto1 %  10; 		
00063E 507F       01503 	MOVF  resto1,W,0
000640 6E7F       01504 	MOVWF C20tmp,0
000642 6A7F       01505 	CLRF  unid,0
000644 0E08       01506 	MOVLW 8
000646 6E7F       01507 	MOVWF C19cnt,0
000648 367F       01508 m078	RLCF  C20tmp,1,0
00064A 367F       01509 	RLCF  unid,1,0
00064C 0E0A       01510 	MOVLW 10
00064E 5C7F       01511 	SUBWF unid,W,0
000650 A0D8       01512 	BTFSS 0xFD8,Carry,0
000652 D002       01513 	BRA   m079
000654 0E0A       01514 	MOVLW 10
000656 5E7F       01515 	SUBWF unid,1,0
000658 2E7F       01516 m079	DECFSZ C19cnt,1,0
00065A D7F6       01517 	BRA   m078
                  01518 			;		// Envio
                  01519 			;		for (xx = xy; xx < 7; xx++)
00065C CF7F FF7F  01520 	MOVFF xy,xx
000660 0E07       01521 m080	MOVLW 7
000662 607F       01522 	CPFSLT xx,0
000664 D0A5       01523 	BRA   m099
                  01524 			;		{
                  01525 			;			clrwdt () ;
000666 0004       01526 	CLRWDT
                  01527 			;			if (xx == 1) 
000668 2C7F       01528 	DECFSZ xx,W,0
00066A D00B       01529 	BRA   m082
                  01530 			;			{
                  01531 			;				if ((u_milers==0)&&(!bd)) dat = ' '; // bd =0 --> espai
00066C 507F       01532 	MOVF  u_milers,W,0
00066E 107F       01533 	IORWF u_milers+1,W,0
000670 A4D8       01534 	BTFSS 0xFD8,Zero_,0
000672 D005       01535 	BRA   m081
000674 B07F       01536 	BTFSC 0xF7F,bd,0
000676 D003       01537 	BRA   m081
000678 0E20       01538 	MOVLW 32
00067A 6E7F       01539 	MOVWF dat,0
                  01540 			;				else dat = u_milers;
00067C D002       01541 	BRA   m082
00067E CF7F FF7F  01542 m081	MOVFF u_milers,dat
                  01543 			;			}
                  01544 			;			if (xx == 2) 
000682 0E02       01545 m082	MOVLW 2
000684 627F       01546 	CPFSEQ xx,0
000686 D00F       01547 	BRA   m084
                  01548 			;			{
                  01549 			;				if ((u_milers==0)&&(cent==0)&&(!bd)) dat = ' '; // bd =0 --> espai
000688 507F       01550 	MOVF  u_milers,W,0
00068A 107F       01551 	IORWF u_milers+1,W,0
00068C A4D8       01552 	BTFSS 0xFD8,Zero_,0
00068E D009       01553 	BRA   m083
000690 507F       01554 	MOVF  cent,W,0
000692 107F       01555 	IORWF cent+1,W,0
000694 A4D8       01556 	BTFSS 0xFD8,Zero_,0
000696 D005       01557 	BRA   m083
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 27

ADDR   CODE       LINE  SOURCE

000698 B07F       01558 	BTFSC 0xF7F,bd,0
00069A D003       01559 	BRA   m083
00069C 0E20       01560 	MOVLW 32
00069E 6E7F       01561 	MOVWF dat,0
                  01562 			;				else dat = cent;
0006A0 D002       01563 	BRA   m084
0006A2 CF7F FF7F  01564 m083	MOVFF cent,dat
                  01565 			;			}
                  01566 			;			if (xx == 3) 
0006A6 0E03       01567 m084	MOVLW 3
0006A8 627F       01568 	CPFSEQ xx,0
0006AA D00A       01569 	BRA   m087
                  01570 			;			{
                  01571 			;				if(ndp) { if (dp==0) dat = '.';
0006AC A07F       01572 	BTFSS 0xF7F,ndp,0
0006AE D007       01573 	BRA   m086
0006B0 B07F       01574 	BTFSC 0xF7F,dp,0
0006B2 D003       01575 	BRA   m085
0006B4 0E2E       01576 	MOVLW 46
0006B6 6E7F       01577 	MOVWF dat,0
                  01578 			;				          else xx++;  
0006B8 D003       01579 	BRA   m087
0006BA 2A7F       01580 m085	INCF  xx,1,0
                  01581 			;				        }
                  01582 			;				else xx++;		
0006BC D001       01583 	BRA   m087
0006BE 2A7F       01584 m086	INCF  xx,1,0
                  01585 			;			}
                  01586 			;			if (xx == 4)
0006C0 0E04       01587 m087	MOVLW 4
0006C2 627F       01588 	CPFSEQ xx,0
0006C4 D012       01589 	BRA   m089
                  01590 			;			{
                  01591 			;				if ((u_milers==0)&&(cent==0)&&(dec==0)&&(!bd)) dat = ' ';
0006C6 507F       01592 	MOVF  u_milers,W,0
0006C8 107F       01593 	IORWF u_milers+1,W,0
0006CA A4D8       01594 	BTFSS 0xFD8,Zero_,0
0006CC D00C       01595 	BRA   m088
0006CE 507F       01596 	MOVF  cent,W,0
0006D0 107F       01597 	IORWF cent+1,W,0
0006D2 A4D8       01598 	BTFSS 0xFD8,Zero_,0
0006D4 D008       01599 	BRA   m088
0006D6 507F       01600 	MOVF  dec,W,0
0006D8 A4D8       01601 	BTFSS 0xFD8,Zero_,0
0006DA D005       01602 	BRA   m088
0006DC B07F       01603 	BTFSC 0xF7F,bd,0
0006DE D003       01604 	BRA   m088
0006E0 0E20       01605 	MOVLW 32
0006E2 6E7F       01606 	MOVWF dat,0
                  01607 			;				else dat = dec ;
0006E4 D002       01608 	BRA   m089
0006E6 CF7F FF7F  01609 m088	MOVFF dec,dat
                  01610 			;			}
                  01611 			;			if (xx == 5)
0006EA 0E05       01612 m089	MOVLW 5
0006EC 627F       01613 	CPFSEQ xx,0
0006EE D00A       01614 	BRA   m092
                  01615 			;			{
                  01616 			;				if(!ndp) { if (dp==0) dat = '.';	
0006F0 B07F       01617 	BTFSC 0xF7F,ndp,0
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 28

ADDR   CODE       LINE  SOURCE

0006F2 D007       01618 	BRA   m091
0006F4 B07F       01619 	BTFSC 0xF7F,dp,0
0006F6 D003       01620 	BRA   m090
0006F8 0E2E       01621 	MOVLW 46
0006FA 6E7F       01622 	MOVWF dat,0
                  01623 			;				           else xx++;
0006FC D003       01624 	BRA   m092
0006FE 2A7F       01625 m090	INCF  xx,1,0
                  01626 			;						 }
                  01627 			;				else xx++;		 
000700 D001       01628 	BRA   m092
000702 2A7F       01629 m091	INCF  xx,1,0
                  01630 			;			}
                  01631 			;			if (xx == 6) dat = unid;
000704 0E06       01632 m092	MOVLW 6
000706 627F       01633 	CPFSEQ xx,0
000708 D002       01634 	BRA   m093
00070A CF7F FF7F  01635 	MOVFF unid,dat
                  01636 			;						
                  01637 			;			if ((dat!='.')&&(dat!=' ')) dat = dat + 0x30;
00070E 507F       01638 m093	MOVF  dat,W,0
000710 0A2E       01639 	XORLW 46
000712 B4D8       01640 	BTFSC 0xFD8,Zero_,0
000714 D006       01641 	BRA   m094
000716 507F       01642 	MOVF  dat,W,0
000718 0A20       01643 	XORLW 32
00071A B4D8       01644 	BTFSC 0xFD8,Zero_,0
00071C D002       01645 	BRA   m094
00071E 0E30       01646 	MOVLW 48
000720 267F       01647 	ADDWF dat,1,0
                  01648 			;
                  01649 			;			PORTB.3 = dat.4;nop();
000722 A87F       01650 m094	BTFSS dat,4,0
000724 9681       01651 	BCF   PORTB,3,0
000726 B87F       01652 	BTFSC dat,4,0
000728 8681       01653 	BSF   PORTB,3,0
00072A 0000       01654 	NOP  
                  01655 			;			PORTB.2 = dat.5;nop();
00072C AA7F       01656 	BTFSS dat,5,0
00072E 9481       01657 	BCF   PORTB,2,0
000730 BA7F       01658 	BTFSC dat,5,0
000732 8481       01659 	BSF   PORTB,2,0
000734 0000       01660 	NOP  
                  01661 			;			PORTB.1 = dat.6;nop();
000736 AC7F       01662 	BTFSS dat,6,0
000738 9281       01663 	BCF   PORTB,1,0
00073A BC7F       01664 	BTFSC dat,6,0
00073C 8281       01665 	BSF   PORTB,1,0
00073E 0000       01666 	NOP  
                  01667 			;			PORTB.0 = dat.7;nop();
000740 AE7F       01668 	BTFSS dat,7,0
000742 9081       01669 	BCF   PORTB,0,0
000744 BE7F       01670 	BTFSC dat,7,0
000746 8081       01671 	BSF   PORTB,0,0
000748 0000       01672 	NOP  
                  01673 			;			PORTB.5 = 1;  									// Modo dato.
00074A 8A81       01674 	BSF   PORTB,5,0
                  01675 			;			retardo_20u ();
00074C DCF5       01676 	RCALL retardo_20u
                  01677 			;			PORTB.4 = 1;  									// Breve pulso.
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 29

ADDR   CODE       LINE  SOURCE

00074E 8881       01678 	BSF   PORTB,4,0
                  01679 			;			retardo_20u ();
000750 DCF3       01680 	RCALL retardo_20u
                  01681 			;			PORTB.4 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
000752 9881       01682 	BCF   PORTB,4,0
                  01683 			;			for (i = 1; i <= 6; i++) retardo_20u ();
000754 0E01       01684 	MOVLW 1
000756 6E7F       01685 	MOVWF i_6,0
000758 0E07       01686 m095	MOVLW 7
00075A 607F       01687 	CPFSLT i_6,0
00075C D003       01688 	BRA   m096
00075E DCEC       01689 	RCALL retardo_20u
000760 2A7F       01690 	INCF  i_6,1,0
000762 D7FA       01691 	BRA   m095
                  01692 			;			dat = swap (dat);
000764 3A7F       01693 m096	SWAPF dat,1,0
                  01694 			;			PORTB.3 = dat.4;nop();
000766 A87F       01695 	BTFSS dat,4,0
000768 9681       01696 	BCF   PORTB,3,0
00076A B87F       01697 	BTFSC dat,4,0
00076C 8681       01698 	BSF   PORTB,3,0
00076E 0000       01699 	NOP  
                  01700 			;			PORTB.2 = dat.5;nop();
000770 AA7F       01701 	BTFSS dat,5,0
000772 9481       01702 	BCF   PORTB,2,0
000774 BA7F       01703 	BTFSC dat,5,0
000776 8481       01704 	BSF   PORTB,2,0
000778 0000       01705 	NOP  
                  01706 			;			PORTB.1 = dat.6;nop();
00077A AC7F       01707 	BTFSS dat,6,0
00077C 9281       01708 	BCF   PORTB,1,0
00077E BC7F       01709 	BTFSC dat,6,0
000780 8281       01710 	BSF   PORTB,1,0
000782 0000       01711 	NOP  
                  01712 			;			PORTB.0 = dat.7;
000784 AE7F       01713 	BTFSS dat,7,0
000786 9081       01714 	BCF   PORTB,0,0
000788 BE7F       01715 	BTFSC dat,7,0
00078A 8081       01716 	BSF   PORTB,0,0
                  01717 			;			retardo_1m ();
00078C DCDF       01718 	RCALL retardo_1m
                  01719 			;			PORTB.5 = 1;  									// Modo dato.
00078E 8A81       01720 	BSF   PORTB,5,0
                  01721 			;			retardo_1m ();
000790 DCDD       01722 	RCALL retardo_1m
                  01723 			;			PORTB.4 = 1;  									// Breve pulso.
000792 8881       01724 	BSF   PORTB,4,0
                  01725 			;			retardo_20u ();
000794 DCD1       01726 	RCALL retardo_20u
                  01727 			;			PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
000796 9881       01728 	BCF   PORTB,4,0
                  01729 			;			for (i = 1; i<= 6; i++) retardo_20u ();
000798 0E01       01730 	MOVLW 1
00079A 6E7F       01731 	MOVWF i_6,0
00079C 0E07       01732 m097	MOVLW 7
00079E 607F       01733 	CPFSLT i_6,0
0007A0 D003       01734 	BRA   m098
0007A2 DCCA       01735 	RCALL retardo_20u
0007A4 2A7F       01736 	INCF  i_6,1,0
0007A6 D7FA       01737 	BRA   m097
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 30

ADDR   CODE       LINE  SOURCE

                  01738 			;			enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.			
0007A8 0E0C       01739 m098	MOVLW 12
0007AA DD39       01740 	RCALL enviar_comando
                  01741 			;		}
0007AC 2A7F       01742 	INCF  xx,1,0
0007AE D758       01743 	BRA   m080
                  01744 			;so:	//DESCON_LCD ();
                  01745 			;	return;
0007B0 0012       01746 m099	RETURN
                  01747 			;}
                  01748 			;
                  01749 			;void Enviar_uns16(char linea,char columna,uns16 dato){
                  01750 Enviar_uns16
                  01751 			;	//utilizaremos esta funcion en caso de necesitar un numero entero hasta 65536(16bits)
                  01752 			;	uns16 num, u_milers, cent, d_milers;
                  01753 			;	char dec, unid, resto1;
                  01754 			;	char i, xx, yy, dat,xy;
                  01755 			;
                  01756 			;	switch (linea) 									// (se resta una unidad a la coordenada lÌnea para que la posiciÛn colum
                           na inicial sea 1 y no 0).
0007B2 0100       01757 	MOVLB 0
0007B4 519F       01758 	MOVF  linea_4,W,1
0007B6 0A01       01759 	XORLW 1
0007B8 B4D8       01760 	BTFSC 0xFD8,Zero_,0
0007BA D00A       01761 	BRA   m100
0007BC 0A03       01762 	XORLW 3
0007BE B4D8       01763 	BTFSC 0xFD8,Zero_,0
0007C0 D00C       01764 	BRA   m101
0007C2 0A01       01765 	XORLW 1
0007C4 B4D8       01766 	BTFSC 0xFD8,Zero_,0
0007C6 D00E       01767 	BRA   m102
0007C8 0A07       01768 	XORLW 7
0007CA B4D8       01769 	BTFSC 0xFD8,Zero_,0
0007CC D010       01770 	BRA   m103
0007CE D016       01771 	BRA   m104
                  01772 			;		{
                  01773 			;			case 1:	enviar_comando (127 + columna); 	// inicio primera linea.
0007D0 0E7F       01774 m100	MOVLW 127
0007D2 0100       01775 	MOVLB 0
0007D4 25A0       01776 	ADDWF columna_3,W,1
0007D6 DD23       01777 	RCALL enviar_comando
                  01778 			;			break;	
0007D8 D011       01779 	BRA   m104
                  01780 			;			case 2:	enviar_comando (191 + columna); 	// inicio segunda lÌnea.
0007DA 0EBF       01781 m101	MOVLW 191
0007DC 0100       01782 	MOVLB 0
0007DE 25A0       01783 	ADDWF columna_3,W,1
0007E0 DD1E       01784 	RCALL enviar_comando
                  01785 			;			break;			
0007E2 D00C       01786 	BRA   m104
                  01787 			;			case 3:	enviar_comando (147 + columna); 	// inicio tercera lÌnea (cursor en posiciÛn 20 de la primera lÌnea).
0007E4 0E93       01788 m102	MOVLW 147
0007E6 0100       01789 	MOVLB 0
0007E8 25A0       01790 	ADDWF columna_3,W,1
0007EA DD19       01791 	RCALL enviar_comando
                  01792 			;			break;				
0007EC D007       01793 	BRA   m104
                  01794 			;			case 4:	enviar_comando (211 + columna); 	// inicio cuarta lÌnea (cursor en posiciÛn 20 de la segunda lÌnea).
0007EE 0ED3       01795 m103	MOVLW 211
0007F0 0100       01796 	MOVLB 0
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 31

ADDR   CODE       LINE  SOURCE

0007F2 25A0       01797 	ADDWF columna_3,W,1
0007F4 DD14       01798 	RCALL enviar_comando
                  01799 			;			break;	
0007F6 D002       01800 	BRA   m104
                  01801 			;			enviar_comando (0b.0000.1100);			// pantalla encendida, sin cursor
0007F8 0E0C       01802 	MOVLW 12
0007FA DD11       01803 	RCALL enviar_comando
                  01804 			;		}				
                  01805 			;	
                  01806 			;			
                  01807 			;			num = dato; 
0007FC C0A1 F0A3  01808 m104	MOVFF dato_4,num_2
000800 C0A2 F0A4  01809 	MOVFF dato_4+1,num_2+1
                  01810 			;			d_milers =num/10000;
000804 0100       01811 	MOVLB 0
000806 51A3       01812 	MOVF  num_2,W,1
000808 6FB4       01813 	MOVWF C22tmp,1
00080A 51A4       01814 	MOVF  num_2+1,W,1
00080C 6FB5       01815 	MOVWF C22tmp+1,1
00080E 6BB6       01816 	CLRF  C23rem,1
000810 6BB7       01817 	CLRF  C23rem+1,1
000812 0E10       01818 	MOVLW 16
000814 6FB3       01819 	MOVWF C21cnt,1
000816 0100       01820 m105	MOVLB 0
000818 37B4       01821 	RLCF  C22tmp,1,1
00081A 37B5       01822 	RLCF  C22tmp+1,1,1
00081C 37B6       01823 	RLCF  C23rem,1,1
00081E 37B7       01824 	RLCF  C23rem+1,1,1
000820 0E10       01825 	MOVLW 16
000822 5DB6       01826 	SUBWF C23rem,W,1
000824 0E27       01827 	MOVLW 39
000826 59B7       01828 	SUBWFB C23rem+1,W,1
000828 A0D8       01829 	BTFSS 0xFD8,Carry,0
00082A D006       01830 	BRA   m106
00082C 0E10       01831 	MOVLW 16
00082E 0100       01832 	MOVLB 0
000830 5FB6       01833 	SUBWF C23rem,1,1
000832 0E27       01834 	MOVLW 39
000834 5BB7       01835 	SUBWFB C23rem+1,1,1
000836 80D8       01836 	BSF   0xFD8,Carry,0
000838 0100       01837 m106	MOVLB 0
00083A 37A9       01838 	RLCF  d_milers,1,1
00083C 37AA       01839 	RLCF  d_milers+1,1,1
00083E 2FB3       01840 	DECFSZ C21cnt,1,1
000840 D7EA       01841 	BRA   m105
                  01842 			;			num= num%10000;
000842 51A3       01843 	MOVF  num_2,W,1
000844 6FB4       01844 	MOVWF C25tmp,1
000846 51A4       01845 	MOVF  num_2+1,W,1
000848 6FB5       01846 	MOVWF C25tmp+1,1
00084A 6BA3       01847 	CLRF  num_2,1
00084C 6BA4       01848 	CLRF  num_2+1,1
00084E 0E10       01849 	MOVLW 16
000850 6FB3       01850 	MOVWF C24cnt,1
000852 0100       01851 m107	MOVLB 0
000854 37B4       01852 	RLCF  C25tmp,1,1
000856 37B5       01853 	RLCF  C25tmp+1,1,1
000858 37A3       01854 	RLCF  num_2,1,1
00085A 37A4       01855 	RLCF  num_2+1,1,1
00085C 0E10       01856 	MOVLW 16
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 32

ADDR   CODE       LINE  SOURCE

00085E 5DA3       01857 	SUBWF num_2,W,1
000860 0E27       01858 	MOVLW 39
000862 59A4       01859 	SUBWFB num_2+1,W,1
000864 A0D8       01860 	BTFSS 0xFD8,Carry,0
000866 D005       01861 	BRA   m108
000868 0E10       01862 	MOVLW 16
00086A 0100       01863 	MOVLB 0
00086C 5FA3       01864 	SUBWF num_2,1,1
00086E 0E27       01865 	MOVLW 39
000870 5BA4       01866 	SUBWFB num_2+1,1,1
000872 0100       01867 m108	MOVLB 0
000874 2FB3       01868 	DECFSZ C24cnt,1,1
000876 D7ED       01869 	BRA   m107
                  01870 			;			u_milers = num / 1000;
000878 51A3       01871 	MOVF  num_2,W,1
00087A 6FB4       01872 	MOVWF C27tmp,1
00087C 51A4       01873 	MOVF  num_2+1,W,1
00087E 6FB5       01874 	MOVWF C27tmp+1,1
000880 6BB6       01875 	CLRF  C28rem,1
000882 6BB7       01876 	CLRF  C28rem+1,1
000884 0E10       01877 	MOVLW 16
000886 6FB3       01878 	MOVWF C26cnt,1
000888 0100       01879 m109	MOVLB 0
00088A 37B4       01880 	RLCF  C27tmp,1,1
00088C 37B5       01881 	RLCF  C27tmp+1,1,1
00088E 37B6       01882 	RLCF  C28rem,1,1
000890 37B7       01883 	RLCF  C28rem+1,1,1
000892 0EE8       01884 	MOVLW 232
000894 5DB6       01885 	SUBWF C28rem,W,1
000896 0E03       01886 	MOVLW 3
000898 59B7       01887 	SUBWFB C28rem+1,W,1
00089A A0D8       01888 	BTFSS 0xFD8,Carry,0
00089C D006       01889 	BRA   m110
00089E 0EE8       01890 	MOVLW 232
0008A0 0100       01891 	MOVLB 0
0008A2 5FB6       01892 	SUBWF C28rem,1,1
0008A4 0E03       01893 	MOVLW 3
0008A6 5BB7       01894 	SUBWFB C28rem+1,1,1
0008A8 80D8       01895 	BSF   0xFD8,Carry,0
0008AA 0100       01896 m110	MOVLB 0
0008AC 37A5       01897 	RLCF  u_milers_2,1,1
0008AE 37A6       01898 	RLCF  u_milers_2+1,1,1
0008B0 2FB3       01899 	DECFSZ C26cnt,1,1
0008B2 D7EA       01900 	BRA   m109
                  01901 			;			dato = num % 1000;
0008B4 51A3       01902 	MOVF  num_2,W,1
0008B6 6FB4       01903 	MOVWF C30tmp,1
0008B8 51A4       01904 	MOVF  num_2+1,W,1
0008BA 6FB5       01905 	MOVWF C30tmp+1,1
0008BC 6BA1       01906 	CLRF  dato_4,1
0008BE 6BA2       01907 	CLRF  dato_4+1,1
0008C0 0E10       01908 	MOVLW 16
0008C2 6FB3       01909 	MOVWF C29cnt,1
0008C4 0100       01910 m111	MOVLB 0
0008C6 37B4       01911 	RLCF  C30tmp,1,1
0008C8 37B5       01912 	RLCF  C30tmp+1,1,1
0008CA 37A1       01913 	RLCF  dato_4,1,1
0008CC 37A2       01914 	RLCF  dato_4+1,1,1
0008CE 0EE8       01915 	MOVLW 232
0008D0 5DA1       01916 	SUBWF dato_4,W,1
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 33

ADDR   CODE       LINE  SOURCE

0008D2 0E03       01917 	MOVLW 3
0008D4 59A2       01918 	SUBWFB dato_4+1,W,1
0008D6 A0D8       01919 	BTFSS 0xFD8,Carry,0
0008D8 D005       01920 	BRA   m112
0008DA 0EE8       01921 	MOVLW 232
0008DC 0100       01922 	MOVLB 0
0008DE 5FA1       01923 	SUBWF dato_4,1,1
0008E0 0E03       01924 	MOVLW 3
0008E2 5BA2       01925 	SUBWFB dato_4+1,1,1
0008E4 0100       01926 m112	MOVLB 0
0008E6 2FB3       01927 	DECFSZ C29cnt,1,1
0008E8 D7ED       01928 	BRA   m111
                  01929 			;
                  01930 			;			cent   = dato   / 100;   	
0008EA 51A1       01931 	MOVF  dato_4,W,1
0008EC 6FB4       01932 	MOVWF C32tmp,1
0008EE 51A2       01933 	MOVF  dato_4+1,W,1
0008F0 6FB5       01934 	MOVWF C32tmp+1,1
0008F2 6BB6       01935 	CLRF  C33rem,1
0008F4 0E10       01936 	MOVLW 16
0008F6 6FB3       01937 	MOVWF C31cnt,1
0008F8 0100       01938 m113	MOVLB 0
0008FA 37B4       01939 	RLCF  C32tmp,1,1
0008FC 37B5       01940 	RLCF  C32tmp+1,1,1
0008FE 37B6       01941 	RLCF  C33rem,1,1
000900 B0D8       01942 	BTFSC 0xFD8,Carry,0
000902 D004       01943 	BRA   m114
000904 0E64       01944 	MOVLW 100
000906 5DB6       01945 	SUBWF C33rem,W,1
000908 A0D8       01946 	BTFSS 0xFD8,Carry,0
00090A D004       01947 	BRA   m115
00090C 0E64       01948 m114	MOVLW 100
00090E 0100       01949 	MOVLB 0
000910 5FB6       01950 	SUBWF C33rem,1,1
000912 80D8       01951 	BSF   0xFD8,Carry,0
000914 0100       01952 m115	MOVLB 0
000916 37A7       01953 	RLCF  cent_2,1,1
000918 37A8       01954 	RLCF  cent_2+1,1,1
00091A 2FB3       01955 	DECFSZ C31cnt,1,1
00091C D7ED       01956 	BRA   m113
                  01957 			;			resto1 = dato   % 100;
00091E 51A1       01958 	MOVF  dato_4,W,1
000920 6FB4       01959 	MOVWF C35tmp,1
000922 51A2       01960 	MOVF  dato_4+1,W,1
000924 6FB5       01961 	MOVWF C35tmp+1,1
000926 6BAD       01962 	CLRF  resto1_2,1
000928 0E10       01963 	MOVLW 16
00092A 6FB3       01964 	MOVWF C34cnt,1
00092C 0100       01965 m116	MOVLB 0
00092E 37B4       01966 	RLCF  C35tmp,1,1
000930 37B5       01967 	RLCF  C35tmp+1,1,1
000932 37AD       01968 	RLCF  resto1_2,1,1
000934 B0D8       01969 	BTFSC 0xFD8,Carry,0
000936 D004       01970 	BRA   m117
000938 0E64       01971 	MOVLW 100
00093A 5DAD       01972 	SUBWF resto1_2,W,1
00093C A0D8       01973 	BTFSS 0xFD8,Carry,0
00093E D003       01974 	BRA   m118
000940 0E64       01975 m117	MOVLW 100
000942 0100       01976 	MOVLB 0
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 34

ADDR   CODE       LINE  SOURCE

000944 5FAD       01977 	SUBWF resto1_2,1,1
000946 0100       01978 m118	MOVLB 0
000948 2FB3       01979 	DECFSZ C34cnt,1,1
00094A D7F0       01980 	BRA   m116
                  01981 			;			dec    = resto1 /  10;  
00094C 51AD       01982 	MOVF  resto1_2,W,1
00094E 6FB4       01983 	MOVWF C37tmp,1
000950 6BB5       01984 	CLRF  C38rem,1
000952 0E08       01985 	MOVLW 8
000954 6FB3       01986 	MOVWF C36cnt,1
000956 0100       01987 m119	MOVLB 0
000958 37B4       01988 	RLCF  C37tmp,1,1
00095A 37B5       01989 	RLCF  C38rem,1,1
00095C 0E0A       01990 	MOVLW 10
00095E 5DB5       01991 	SUBWF C38rem,W,1
000960 A0D8       01992 	BTFSS 0xFD8,Carry,0
000962 D004       01993 	BRA   m120
000964 0E0A       01994 	MOVLW 10
000966 0100       01995 	MOVLB 0
000968 5FB5       01996 	SUBWF C38rem,1,1
00096A 80D8       01997 	BSF   0xFD8,Carry,0
00096C 0100       01998 m120	MOVLB 0
00096E 37AB       01999 	RLCF  dec_2,1,1
000970 2FB3       02000 	DECFSZ C36cnt,1,1
000972 D7F1       02001 	BRA   m119
                  02002 			;			unid   = resto1 %  10; 		
000974 51AD       02003 	MOVF  resto1_2,W,1
000976 6FB4       02004 	MOVWF C40tmp,1
000978 6BAC       02005 	CLRF  unid_2,1
00097A 0E08       02006 	MOVLW 8
00097C 6FB3       02007 	MOVWF C39cnt,1
00097E 0100       02008 m121	MOVLB 0
000980 37B4       02009 	RLCF  C40tmp,1,1
000982 37AC       02010 	RLCF  unid_2,1,1
000984 0E0A       02011 	MOVLW 10
000986 5DAC       02012 	SUBWF unid_2,W,1
000988 A0D8       02013 	BTFSS 0xFD8,Carry,0
00098A D003       02014 	BRA   m122
00098C 0E0A       02015 	MOVLW 10
00098E 0100       02016 	MOVLB 0
000990 5FAC       02017 	SUBWF unid_2,1,1
000992 0100       02018 m122	MOVLB 0
000994 2FB3       02019 	DECFSZ C39cnt,1,1
000996 D7F3       02020 	BRA   m121
                  02021 			;		// Envio
                  02022 			;		for (xx=0 ; xx < 5; xx++)
000998 6BAF       02023 	CLRF  xx_2,1
00099A 0E05       02024 m123	MOVLW 5
00099C 0100       02025 	MOVLB 0
00099E 61AF       02026 	CPFSLT xx_2,1
0009A0 D0B4       02027 	BRA   m139
                  02028 			;		{
                  02029 			;			switch(xx){
0009A2 51AF       02030 	MOVF  xx_2,W,1
0009A4 B4D8       02031 	BTFSC 0xFD8,Zero_,0
0009A6 D00D       02032 	BRA   m124
0009A8 0A01       02033 	XORLW 1
0009AA B4D8       02034 	BTFSC 0xFD8,Zero_,0
0009AC D015       02035 	BRA   m126
0009AE 0A03       02036 	XORLW 3
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 35

ADDR   CODE       LINE  SOURCE

0009B0 B4D8       02037 	BTFSC 0xFD8,Zero_,0
0009B2 D021       02038 	BRA   m128
0009B4 0A01       02039 	XORLW 1
0009B6 B4D8       02040 	BTFSC 0xFD8,Zero_,0
0009B8 D031       02041 	BRA   m130
0009BA 0A07       02042 	XORLW 7
0009BC B4D8       02043 	BTFSC 0xFD8,Zero_,0
0009BE D044       02044 	BRA   m132
0009C0 D045       02045 	BRA   m133
                  02046 			;				case 0:
                  02047 			;					if (d_milers==0) dat = ' '; 
0009C2 0100       02048 m124	MOVLB 0
0009C4 51A9       02049 	MOVF  d_milers,W,1
0009C6 11AA       02050 	IORWF d_milers+1,W,1
0009C8 A4D8       02051 	BTFSS 0xFD8,Zero_,0
0009CA D003       02052 	BRA   m125
0009CC 0E20       02053 	MOVLW 32
0009CE 6FB1       02054 	MOVWF dat_2,1
                  02055 			;					else dat = d_milers;
0009D0 D03D       02056 	BRA   m133
0009D2 C0A9 F0B1  02057 m125	MOVFF d_milers,dat_2
                  02058 			;					break;
0009D6 D03A       02059 	BRA   m133
                  02060 			;				case 1:
                  02061 			;					if ((u_milers==0)&&(d_milers==0)) dat = ' ';
0009D8 0100       02062 m126	MOVLB 0
0009DA 51A5       02063 	MOVF  u_milers_2,W,1
0009DC 11A6       02064 	IORWF u_milers_2+1,W,1
0009DE A4D8       02065 	BTFSS 0xFD8,Zero_,0
0009E0 D007       02066 	BRA   m127
0009E2 51A9       02067 	MOVF  d_milers,W,1
0009E4 11AA       02068 	IORWF d_milers+1,W,1
0009E6 A4D8       02069 	BTFSS 0xFD8,Zero_,0
0009E8 D003       02070 	BRA   m127
0009EA 0E20       02071 	MOVLW 32
0009EC 6FB1       02072 	MOVWF dat_2,1
                  02073 			;					else dat = u_milers;
0009EE D02E       02074 	BRA   m133
0009F0 C0A5 F0B1  02075 m127	MOVFF u_milers_2,dat_2
                  02076 			;					break;
0009F4 D02B       02077 	BRA   m133
                  02078 			;				case 2:
                  02079 			;					if ((d_milers==0)&&(u_milers==0)&&(cent==0)) dat = ' '; 
0009F6 0100       02080 m128	MOVLB 0
0009F8 51A9       02081 	MOVF  d_milers,W,1
0009FA 11AA       02082 	IORWF d_milers+1,W,1
0009FC A4D8       02083 	BTFSS 0xFD8,Zero_,0
0009FE D00B       02084 	BRA   m129
000A00 51A5       02085 	MOVF  u_milers_2,W,1
000A02 11A6       02086 	IORWF u_milers_2+1,W,1
000A04 A4D8       02087 	BTFSS 0xFD8,Zero_,0
000A06 D007       02088 	BRA   m129
000A08 51A7       02089 	MOVF  cent_2,W,1
000A0A 11A8       02090 	IORWF cent_2+1,W,1
000A0C A4D8       02091 	BTFSS 0xFD8,Zero_,0
000A0E D003       02092 	BRA   m129
000A10 0E20       02093 	MOVLW 32
000A12 6FB1       02094 	MOVWF dat_2,1
                  02095 			;					else dat = cent;
000A14 D01B       02096 	BRA   m133
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 36

ADDR   CODE       LINE  SOURCE

000A16 C0A7 F0B1  02097 m129	MOVFF cent_2,dat_2
                  02098 			;					break;
000A1A D018       02099 	BRA   m133
                  02100 			;				case 3:
                  02101 			;					if ((u_milers==0)&&(cent==0)&&(dec==0)&&(d_milers==0)) dat = ' ';
000A1C 0100       02102 m130	MOVLB 0
000A1E 51A5       02103 	MOVF  u_milers_2,W,1
000A20 11A6       02104 	IORWF u_milers_2+1,W,1
000A22 A4D8       02105 	BTFSS 0xFD8,Zero_,0
000A24 D00E       02106 	BRA   m131
000A26 51A7       02107 	MOVF  cent_2,W,1
000A28 11A8       02108 	IORWF cent_2+1,W,1
000A2A A4D8       02109 	BTFSS 0xFD8,Zero_,0
000A2C D00A       02110 	BRA   m131
000A2E 53AB       02111 	MOVF  dec_2,1,1
000A30 A4D8       02112 	BTFSS 0xFD8,Zero_,0
000A32 D007       02113 	BRA   m131
000A34 51A9       02114 	MOVF  d_milers,W,1
000A36 11AA       02115 	IORWF d_milers+1,W,1
000A38 A4D8       02116 	BTFSS 0xFD8,Zero_,0
000A3A D003       02117 	BRA   m131
000A3C 0E20       02118 	MOVLW 32
000A3E 6FB1       02119 	MOVWF dat_2,1
                  02120 			;					else dat = dec ;
000A40 D005       02121 	BRA   m133
000A42 C0AB F0B1  02122 m131	MOVFF dec_2,dat_2
                  02123 			;					break;
000A46 D002       02124 	BRA   m133
                  02125 			;				case 4:
                  02126 			;					dat = unid;
000A48 C0AC F0B1  02127 m132	MOVFF unid_2,dat_2
                  02128 			;					break;
                  02129 			;			}		
                  02130 			;			if (dat!=' ') dat = dat + 0x30;
000A4C 0100       02131 m133	MOVLB 0
000A4E 51B1       02132 	MOVF  dat_2,W,1
000A50 0A20       02133 	XORLW 32
000A52 B4D8       02134 	BTFSC 0xFD8,Zero_,0
000A54 D002       02135 	BRA   m134
000A56 0E30       02136 	MOVLW 48
000A58 27B1       02137 	ADDWF dat_2,1,1
                  02138 			;			PORTB.3 = dat.4;nop();
000A5A 0100       02139 m134	MOVLB 0
000A5C A9B1       02140 	BTFSS dat_2,4,1
000A5E 9681       02141 	BCF   PORTB,3,0
000A60 B9B1       02142 	BTFSC dat_2,4,1
000A62 8681       02143 	BSF   PORTB,3,0
000A64 0000       02144 	NOP  
                  02145 			;			PORTB.2 = dat.5;nop();
000A66 ABB1       02146 	BTFSS dat_2,5,1
000A68 9481       02147 	BCF   PORTB,2,0
000A6A BBB1       02148 	BTFSC dat_2,5,1
000A6C 8481       02149 	BSF   PORTB,2,0
000A6E 0000       02150 	NOP  
                  02151 			;			PORTB.1 = dat.6;nop();
000A70 ADB1       02152 	BTFSS dat_2,6,1
000A72 9281       02153 	BCF   PORTB,1,0
000A74 BDB1       02154 	BTFSC dat_2,6,1
000A76 8281       02155 	BSF   PORTB,1,0
000A78 0000       02156 	NOP  
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 37

ADDR   CODE       LINE  SOURCE

                  02157 			;			PORTB.0 = dat.7;nop();
000A7A AFB1       02158 	BTFSS dat_2,7,1
000A7C 9081       02159 	BCF   PORTB,0,0
000A7E BFB1       02160 	BTFSC dat_2,7,1
000A80 8081       02161 	BSF   PORTB,0,0
000A82 0000       02162 	NOP  
                  02163 			;			PORTB.5 = 1;  									// Modo dato.
000A84 8A81       02164 	BSF   PORTB,5,0
                  02165 			;			retardo_20u ();
000A86 EC9C F000  02166 	CALL  retardo_20u
                  02167 			;			PORTB.4 = 1;  									// Breve pulso.
000A8A 8881       02168 	BSF   PORTB,4,0
                  02169 			;			retardo_20u ();
000A8C EC9C F000  02170 	CALL  retardo_20u
                  02171 			;			PORTB.4 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
000A90 9881       02172 	BCF   PORTB,4,0
                  02173 			;			for (i = 1; i <= 6; i++) retardo_20u ();
000A92 0E01       02174 	MOVLW 1
000A94 0100       02175 	MOVLB 0
000A96 6FAE       02176 	MOVWF i_7,1
000A98 0E07       02177 m135	MOVLW 7
000A9A 0100       02178 	MOVLB 0
000A9C 61AE       02179 	CPFSLT i_7,1
000A9E D005       02180 	BRA   m136
000AA0 EC9C F000  02181 	CALL  retardo_20u
000AA4 0100       02182 	MOVLB 0
000AA6 2BAE       02183 	INCF  i_7,1,1
000AA8 D7F7       02184 	BRA   m135
                  02185 			;			dat = swap (dat);
000AAA 0100       02186 m136	MOVLB 0
000AAC 3BB1       02187 	SWAPF dat_2,1,1
                  02188 			;			PORTB.3 = dat.4;nop();
000AAE A9B1       02189 	BTFSS dat_2,4,1
000AB0 9681       02190 	BCF   PORTB,3,0
000AB2 B9B1       02191 	BTFSC dat_2,4,1
000AB4 8681       02192 	BSF   PORTB,3,0
000AB6 0000       02193 	NOP  
                  02194 			;			PORTB.2 = dat.5;nop();
000AB8 ABB1       02195 	BTFSS dat_2,5,1
000ABA 9481       02196 	BCF   PORTB,2,0
000ABC BBB1       02197 	BTFSC dat_2,5,1
000ABE 8481       02198 	BSF   PORTB,2,0
000AC0 0000       02199 	NOP  
                  02200 			;			PORTB.1 = dat.6;nop();
000AC2 ADB1       02201 	BTFSS dat_2,6,1
000AC4 9281       02202 	BCF   PORTB,1,0
000AC6 BDB1       02203 	BTFSC dat_2,6,1
000AC8 8281       02204 	BSF   PORTB,1,0
000ACA 0000       02205 	NOP  
                  02206 			;			PORTB.0 = dat.7;
000ACC AFB1       02207 	BTFSS dat_2,7,1
000ACE 9081       02208 	BCF   PORTB,0,0
000AD0 BFB1       02209 	BTFSC dat_2,7,1
000AD2 8081       02210 	BSF   PORTB,0,0
                  02211 			;			retardo_1m ();
000AD4 ECA6 F000  02212 	CALL  retardo_1m
                  02213 			;			PORTB.5 = 1;  									// Modo dato.
000AD8 8A81       02214 	BSF   PORTB,5,0
                  02215 			;			retardo_1m ();
000ADA ECA6 F000  02216 	CALL  retardo_1m
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 38

ADDR   CODE       LINE  SOURCE

                  02217 			;			PORTB.4 = 1;  									// Breve pulso.
000ADE 8881       02218 	BSF   PORTB,4,0
                  02219 			;			retardo_20u ();
000AE0 EC9C F000  02220 	CALL  retardo_20u
                  02221 			;			PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
000AE4 9881       02222 	BCF   PORTB,4,0
                  02223 			;			for (i = 1; i<= 6; i++) retardo_20u ();
000AE6 0E01       02224 	MOVLW 1
000AE8 0100       02225 	MOVLB 0
000AEA 6FAE       02226 	MOVWF i_7,1
000AEC 0E07       02227 m137	MOVLW 7
000AEE 0100       02228 	MOVLB 0
000AF0 61AE       02229 	CPFSLT i_7,1
000AF2 D005       02230 	BRA   m138
000AF4 EC9C F000  02231 	CALL  retardo_20u
000AF8 0100       02232 	MOVLB 0
000AFA 2BAE       02233 	INCF  i_7,1,1
000AFC D7F7       02234 	BRA   m137
                  02235 			;			enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.			
000AFE 0E0C       02236 m138	MOVLW 12
000B00 EC0F F001  02237 	CALL  enviar_comando
                  02238 			;		}
000B04 0100       02239 	MOVLB 0
000B06 2BAF       02240 	INCF  xx_2,1,1
000B08 D748       02241 	BRA   m123
                  02242 			;
                  02243 			;	return;
000B0A 0012       02244 m139	RETURN
                  02245 			;
                  02246 			;}
                  02247 			;
                  02248 			;//***********************************************************************************************
                  02249 			;//***********************************************************************************************
                  02250 			;// Definicio caracter especial : PROCES  -> posar x, on volguem el pixel ,pes 16 8 4 2 1  Rtat Hexa
                  02251 			;//                         -  contar pesos ( veure exple, per Ah)             ° °x°x° ° ° 0x0C
                  02252 			;//                             -  de dalt a baix, es el codi a posar          °x° ° °x° ° 0x12
                  02253 			;//                                                en el vector.               °x°x°x°x° ° 0x1E
                  02254 			;//                   - Al inici cridar funcio per ecriure CGRAM               °x° ° °x° ° 0x12
                  02255 			;//                    - Hi caben 8 carac especials de 64 a 120                ° ° °x° ° ° 0x00
                  02256 			;//                       de 8 e 8,  64 , 72, 80, 88, 96,104.112,120           ° ° °x°x°x° 0x04
                  02257 			;//                   - Despres d'escriure la CGRAM, cal fer un                ° ° °x° °x° 0x07
                  02258 			;//                     comando, per no apuntar a la CGRAM                     ° ° °x° °x° 0x05
                  02259 			;// Per escriure simbol .... fer :   enviar_literal(3);enviar_literal(4);
                  02260 			;//************IMPORTANTE****************************************
                  02261 			;//******Poner despues de inicializar_lcd();*********************
                  02262 			;void RAM_LCD (void)
                  02263 			;{
                  02264 RAM_LCD
                  02265 			;	static const char Carac_1[] = {0x0C,0x10,0x08,0x04,0x1B,0x04,0x04,0x03};//caracter micro 	//escribir_literal(0);
                  02266 			;	static const char Carac_2[] = {0xEE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};	//escribir_literal(1); BAT_FULL
                  02267 			;	static const char Carac_3[] = {0xEE,0xFF,0xF1,0xFF,0xFF,0xFF,0xFF,0xFF};	// ""...               BAT_75
                  02268 			;	static const char Carac_4[] = {0xEE,0xFF,0xF1,0xF1,0xFF,0xFF,0xFF,0xFF};					    // BAT_50
                  02269 			;	static const char Carac_5[] = {0xEE,0xFF,0xF1,0xF1,0xF1,0xFF,0xFF,0xFF};					    // BAT_25
                  02270 			;	static const char Carac_6[] = {0xEE,0xFF,0xF1,0xF1,0xF1,0xF1,0xFF,0xFF};					    // BAT_10
                  02271 			;	static const char Carac_7[] = {0xEE,0xFF,0xF1,0xF1,0xF1,0xF1,0xF1,0xFF};					    // BAT_LW
                  02272 			;	static const char Carac_8[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
                  02273 			;	// 1era posicio CGRAM es la 64 , 72, 80, 88, 96,104.112,120
                  02274 			;	char i;
                  02275 			;	
                  02276 			;	enviar_comando (64);// primera posicio del Carac_1, els altres seran consecutius
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 39

ADDR   CODE       LINE  SOURCE

000B0C 0E40       02277 	MOVLW 64
000B0E EC0F F001  02278 	CALL  enviar_comando
                  02279 			;	retardo_20u ();
000B12 EC9C F000  02280 	CALL  retardo_20u
                  02281 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_1[i]); retardo_20u (); retardo_20u ();}
000B16 0100       02282 	MOVLB 0
000B18 6B98       02283 	CLRF  i_8,1
000B1A 0E08       02284 m140	MOVLW 8
000B1C 0100       02285 	MOVLB 0
000B1E 6198       02286 	CPFSLT i_8,1
000B20 D00D       02287 	BRA   m141
000B22 0E1A       02288 	MOVLW 26
000B24 2598       02289 	ADDWF i_8,W,1
000B26 EC62 F00C  02290 	CALL  _const1
000B2A EC4A F001  02291 	CALL  enviar_literal
000B2E EC9C F000  02292 	CALL  retardo_20u
000B32 EC9C F000  02293 	CALL  retardo_20u
000B36 0100       02294 	MOVLB 0
000B38 2B98       02295 	INCF  i_8,1,1
000B3A D7EF       02296 	BRA   m140
                  02297 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_2[i]); retardo_20u (); retardo_20u ();}
000B3C 0100       02298 m141	MOVLB 0
000B3E 6B98       02299 	CLRF  i_8,1
000B40 0E08       02300 m142	MOVLW 8
000B42 0100       02301 	MOVLB 0
000B44 6198       02302 	CPFSLT i_8,1
000B46 D00D       02303 	BRA   m143
000B48 0E22       02304 	MOVLW 34
000B4A 2598       02305 	ADDWF i_8,W,1
000B4C EC62 F00C  02306 	CALL  _const1
000B50 EC4A F001  02307 	CALL  enviar_literal
000B54 EC9C F000  02308 	CALL  retardo_20u
000B58 EC9C F000  02309 	CALL  retardo_20u
000B5C 0100       02310 	MOVLB 0
000B5E 2B98       02311 	INCF  i_8,1,1
000B60 D7EF       02312 	BRA   m142
                  02313 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_3[i]); retardo_20u (); retardo_20u ();}
000B62 0100       02314 m143	MOVLB 0
000B64 6B98       02315 	CLRF  i_8,1
000B66 0E08       02316 m144	MOVLW 8
000B68 0100       02317 	MOVLB 0
000B6A 6198       02318 	CPFSLT i_8,1
000B6C D00D       02319 	BRA   m145
000B6E 0E2A       02320 	MOVLW 42
000B70 2598       02321 	ADDWF i_8,W,1
000B72 EC62 F00C  02322 	CALL  _const1
000B76 EC4A F001  02323 	CALL  enviar_literal
000B7A EC9C F000  02324 	CALL  retardo_20u
000B7E EC9C F000  02325 	CALL  retardo_20u
000B82 0100       02326 	MOVLB 0
000B84 2B98       02327 	INCF  i_8,1,1
000B86 D7EF       02328 	BRA   m144
                  02329 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_4[i]); retardo_20u (); retardo_20u ();}
000B88 0100       02330 m145	MOVLB 0
000B8A 6B98       02331 	CLRF  i_8,1
000B8C 0E08       02332 m146	MOVLW 8
000B8E 0100       02333 	MOVLB 0
000B90 6198       02334 	CPFSLT i_8,1
000B92 D00D       02335 	BRA   m147
000B94 0E32       02336 	MOVLW 50
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 40

ADDR   CODE       LINE  SOURCE

000B96 2598       02337 	ADDWF i_8,W,1
000B98 EC62 F00C  02338 	CALL  _const1
000B9C EC4A F001  02339 	CALL  enviar_literal
000BA0 EC9C F000  02340 	CALL  retardo_20u
000BA4 EC9C F000  02341 	CALL  retardo_20u
000BA8 0100       02342 	MOVLB 0
000BAA 2B98       02343 	INCF  i_8,1,1
000BAC D7EF       02344 	BRA   m146
                  02345 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_5[i]); retardo_20u (); retardo_20u ();}
000BAE 0100       02346 m147	MOVLB 0
000BB0 6B98       02347 	CLRF  i_8,1
000BB2 0E08       02348 m148	MOVLW 8
000BB4 0100       02349 	MOVLB 0
000BB6 6198       02350 	CPFSLT i_8,1
000BB8 D00D       02351 	BRA   m149
000BBA 0E3A       02352 	MOVLW 58
000BBC 2598       02353 	ADDWF i_8,W,1
000BBE EC62 F00C  02354 	CALL  _const1
000BC2 EC4A F001  02355 	CALL  enviar_literal
000BC6 EC9C F000  02356 	CALL  retardo_20u
000BCA EC9C F000  02357 	CALL  retardo_20u
000BCE 0100       02358 	MOVLB 0
000BD0 2B98       02359 	INCF  i_8,1,1
000BD2 D7EF       02360 	BRA   m148
                  02361 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_6[i]); retardo_20u (); retardo_20u ();}
000BD4 0100       02362 m149	MOVLB 0
000BD6 6B98       02363 	CLRF  i_8,1
000BD8 0E08       02364 m150	MOVLW 8
000BDA 0100       02365 	MOVLB 0
000BDC 6198       02366 	CPFSLT i_8,1
000BDE D00D       02367 	BRA   m151
000BE0 0E42       02368 	MOVLW 66
000BE2 2598       02369 	ADDWF i_8,W,1
000BE4 EC62 F00C  02370 	CALL  _const1
000BE8 EC4A F001  02371 	CALL  enviar_literal
000BEC EC9C F000  02372 	CALL  retardo_20u
000BF0 EC9C F000  02373 	CALL  retardo_20u
000BF4 0100       02374 	MOVLB 0
000BF6 2B98       02375 	INCF  i_8,1,1
000BF8 D7EF       02376 	BRA   m150
                  02377 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_7[i]); retardo_20u (); retardo_20u ();}
000BFA 0100       02378 m151	MOVLB 0
000BFC 6B98       02379 	CLRF  i_8,1
000BFE 0E08       02380 m152	MOVLW 8
000C00 0100       02381 	MOVLB 0
000C02 6198       02382 	CPFSLT i_8,1
000C04 D00D       02383 	BRA   m153
000C06 0E4A       02384 	MOVLW 74
000C08 2598       02385 	ADDWF i_8,W,1
000C0A EC62 F00C  02386 	CALL  _const1
000C0E EC4A F001  02387 	CALL  enviar_literal
000C12 EC9C F000  02388 	CALL  retardo_20u
000C16 EC9C F000  02389 	CALL  retardo_20u
000C1A 0100       02390 	MOVLB 0
000C1C 2B98       02391 	INCF  i_8,1,1
000C1E D7EF       02392 	BRA   m152
                  02393 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_8[i]); retardo_20u (); retardo_20u ();}	
000C20 0100       02394 m153	MOVLB 0
000C22 6B98       02395 	CLRF  i_8,1
000C24 0E08       02396 m154	MOVLW 8
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 41

ADDR   CODE       LINE  SOURCE

000C26 0100       02397 	MOVLB 0
000C28 6198       02398 	CPFSLT i_8,1
000C2A D00D       02399 	BRA   m155
000C2C 0E52       02400 	MOVLW 82
000C2E 2598       02401 	ADDWF i_8,W,1
000C30 EC62 F00C  02402 	CALL  _const1
000C34 EC4A F001  02403 	CALL  enviar_literal
000C38 EC9C F000  02404 	CALL  retardo_20u
000C3C EC9C F000  02405 	CALL  retardo_20u
000C40 0100       02406 	MOVLB 0
000C42 2B98       02407 	INCF  i_8,1,1
000C44 D7EF       02408 	BRA   m154
                  02409 			;	enviar_comando (0b.0000.0010);
000C46 0E02       02410 m155	MOVLW 2
000C48 EF0F F001  02411 	GOTO  enviar_comando
                  02412 			;	
                  02413 			;	return;
                  02414 
                  02415   ; FILE medir_18F4XK20.h
                  02416 			;/*funci√≥n void medir (char, char)
                  02417 			;recibe como par√°metros:
                  02418 			;Primer par√°metro: el canal A/D a convertir  (0...4,8...13) . Si est√° fuera del rango, toma 0 por defecto
                  02419 			;Segundo par√°metro: solo admite 8 o 10 (bits del resultado). si el par√°metro no es 8 o 10,
                  02420 			;interpreta autom√°ticamente a 10.
                  02421 			;Siempre. se configura autom√°ticamente la entrada anal√≥gica solicitada. Fosc/32
                  02422 			;Requiere la funci√≥n retardo_20u()  (en retardos.h)
                  02423 			;resultado: en ADRESH:ADRESL
                  02424 			;*/
                  02425 			;uns16 medir (char canal, char bits)
                  02426 			;{
                  02427 medir
000C4C 0100       02428 	MOVLB 0
000C4E 6F9E       02429 	MOVWF bits,1
                  02430 			;	uns16 resultado;
                  02431 			;	switch (canal)
000C50 519D       02432 	MOVF  canal,W,1
000C52 B4D8       02433 	BTFSC 0xFD8,Zero_,0
000C54 D028       02434 	BRA   m156
000C56 0A01       02435 	XORLW 1
000C58 B4D8       02436 	BTFSC 0xFD8,Zero_,0
000C5A D028       02437 	BRA   m157
000C5C 0A03       02438 	XORLW 3
000C5E B4D8       02439 	BTFSC 0xFD8,Zero_,0
000C60 D028       02440 	BRA   m158
000C62 0A01       02441 	XORLW 1
000C64 B4D8       02442 	BTFSC 0xFD8,Zero_,0
000C66 D028       02443 	BRA   m159
000C68 0A07       02444 	XORLW 7
000C6A B4D8       02445 	BTFSC 0xFD8,Zero_,0
000C6C D028       02446 	BRA   m160
000C6E 0A01       02447 	XORLW 1
000C70 B4D8       02448 	BTFSC 0xFD8,Zero_,0
000C72 D028       02449 	BRA   m161
000C74 0A03       02450 	XORLW 3
000C76 B4D8       02451 	BTFSC 0xFD8,Zero_,0
000C78 D028       02452 	BRA   m162
000C7A 0A01       02453 	XORLW 1
000C7C B4D8       02454 	BTFSC 0xFD8,Zero_,0
000C7E D028       02455 	BRA   m163
000C80 0A0F       02456 	XORLW 15
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 42

ADDR   CODE       LINE  SOURCE

000C82 B4D8       02457 	BTFSC 0xFD8,Zero_,0
000C84 D028       02458 	BRA   m164
000C86 0A01       02459 	XORLW 1
000C88 B4D8       02460 	BTFSC 0xFD8,Zero_,0
000C8A D028       02461 	BRA   m165
000C8C 0A03       02462 	XORLW 3
000C8E B4D8       02463 	BTFSC 0xFD8,Zero_,0
000C90 D028       02464 	BRA   m166
000C92 0A01       02465 	XORLW 1
000C94 B4D8       02466 	BTFSC 0xFD8,Zero_,0
000C96 D028       02467 	BRA   m167
000C98 0A07       02468 	XORLW 7
000C9A B4D8       02469 	BTFSC 0xFD8,Zero_,0
000C9C D028       02470 	BRA   m168
000C9E 0A01       02471 	XORLW 1
000CA0 B4D8       02472 	BTFSC 0xFD8,Zero_,0
000CA2 D028       02473 	BRA   m169
000CA4 D02A       02474 	BRA   m170
                  02475 			;	{
                  02476 			;		//del 0 al 4, est√°n en el PORTA
                  02477 			;		case 0: 	ADCON0 = 0b.00.0000.01;		break;
000CA6 0E01       02478 m156	MOVLW 1
000CA8 6EC2       02479 	MOVWF ADCON0,0
000CAA D029       02480 	BRA   m171
                  02481 			;		case 1:		ADCON0 = 0b.00.0001.01;		break;
000CAC 0E05       02482 m157	MOVLW 5
000CAE 6EC2       02483 	MOVWF ADCON0,0
000CB0 D026       02484 	BRA   m171
                  02485 			;		case 2:		ADCON0 = 0b.00.0010.01;		break;
000CB2 0E09       02486 m158	MOVLW 9
000CB4 6EC2       02487 	MOVWF ADCON0,0
000CB6 D023       02488 	BRA   m171
                  02489 			;		case 3:		ADCON0 = 0b.00.0011.01;		break;
000CB8 0E0D       02490 m159	MOVLW 13
000CBA 6EC2       02491 	MOVWF ADCON0,0
000CBC D020       02492 	BRA   m171
                  02493 			;		case 4:		ADCON0 = 0b.00.0100.01;		break;
000CBE 0E11       02494 m160	MOVLW 17
000CC0 6EC2       02495 	MOVWF ADCON0,0
000CC2 D01D       02496 	BRA   m171
                  02497 			;		case 5:		ADCON0 = 0b.00.0101.01;		break;
000CC4 0E15       02498 m161	MOVLW 21
000CC6 6EC2       02499 	MOVWF ADCON0,0
000CC8 D01A       02500 	BRA   m171
                  02501 			;		case 6:		ADCON0 = 0b.00.0110.01;		break;
000CCA 0E19       02502 m162	MOVLW 25
000CCC 6EC2       02503 	MOVWF ADCON0,0
000CCE D017       02504 	BRA   m171
                  02505 			;		case 7:		ADCON0 = 0b.00.0111.01;		break;
000CD0 0E1D       02506 m163	MOVLW 29
000CD2 6EC2       02507 	MOVWF ADCON0,0
000CD4 D014       02508 	BRA   m171
                  02509 			;		case 8:		ADCON0 = 0b.00.1000.01;		break;
000CD6 0E21       02510 m164	MOVLW 33
000CD8 6EC2       02511 	MOVWF ADCON0,0
000CDA D011       02512 	BRA   m171
                  02513 			;		case 9:		ADCON0 = 0b.00.1001.01;		break;
000CDC 0E25       02514 m165	MOVLW 37
000CDE 6EC2       02515 	MOVWF ADCON0,0
000CE0 D00E       02516 	BRA   m171
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 43

ADDR   CODE       LINE  SOURCE

                  02517 			;		case 10:	ADCON0 = 0b.00.1010.01;		break;
000CE2 0E29       02518 m166	MOVLW 41
000CE4 6EC2       02519 	MOVWF ADCON0,0
000CE6 D00B       02520 	BRA   m171
                  02521 			;		case 11:	ADCON0 = 0b.00.1011.01;		break;
000CE8 0E2D       02522 m167	MOVLW 45
000CEA 6EC2       02523 	MOVWF ADCON0,0
000CEC D008       02524 	BRA   m171
                  02525 			;		case 12:	ADCON0 = 0b.00.1100.01;		break;
000CEE 0E31       02526 m168	MOVLW 49
000CF0 6EC2       02527 	MOVWF ADCON0,0
000CF2 D005       02528 	BRA   m171
                  02529 			;		case 13:	ADCON0 = 0b.00.1101.01;		break;
000CF4 0E35       02530 m169	MOVLW 53
000CF6 6EC2       02531 	MOVWF ADCON0,0
000CF8 D002       02532 	BRA   m171
                  02533 			;		default:	ADCON0 = 0b.00.0000.01;
000CFA 0E01       02534 m170	MOVLW 1
000CFC 6EC2       02535 	MOVWF ADCON0,0
                  02536 			;	}
                  02537 			;	if (bits == 8){ADFM=0;GO = 1;  while(GO);resultado = ADRESH;}
000CFE 0E08       02538 m171	MOVLW 8
000D00 0100       02539 	MOVLB 0
000D02 639E       02540 	CPFSEQ bits,1
000D04 D009       02541 	BRA   m173
000D06 9EC0       02542 	BCF   0xFC0,ADFM,0
000D08 82C2       02543 	BSF   0xFC2,GO,0
000D0A B2C2       02544 m172	BTFSC 0xFC2,GO,0
000D0C D7FE       02545 	BRA   m172
000D0E CFC4 F09F  02546 	MOVFF ADRESH,resultado
000D12 0100       02547 	MOVLB 0
000D14 6BA0       02548 	CLRF  resultado+1,1
                  02549 			;	else 		  {ADFM=1;GO = 1;  while(GO);resultado.low8 = ADRESL;resultado.high8 = ADRESH;}
000D16 D008       02550 	BRA   m175
000D18 8EC0       02551 m173	BSF   0xFC0,ADFM,0
000D1A 82C2       02552 	BSF   0xFC2,GO,0
000D1C B2C2       02553 m174	BTFSC 0xFC2,GO,0
000D1E D7FE       02554 	BRA   m174
000D20 CFC3 F09F  02555 	MOVFF ADRESL,resultado
000D24 CFC4 F0A0  02556 	MOVFF ADRESH,resultado+1
                  02557 			;   	
                  02558 			;   	return resultado;
000D28 0100       02559 m175	MOVLB 0
000D2A 519F       02560 	MOVF  resultado,W,1
000D2C 0012       02561 	RETURN
                  02562 
                  02563   ; FILE MATH24F.H
                  02564 			;// *************************************************
                  02565 			;// 24 bit basic floating point math operations
                  02566 			;// Copyright (c) B Knudsen Data, Norway, 2000 - 2005
                  02567 			;// *************************************************
                  02568 			;
                  02569 			;#pragma library 1
                  02570 			;/* PROTOTYPES for page definition in application header file:
                  02571 			;float24 operator* _fmul24( float24 arg1f24, float24 arg2f24);
                  02572 			;float24 operator/ _fdiv24( float24 arg1f24, float24 arg2f24);
                  02573 			;float24 operator+ _fadd24( float24 arg1f24, float24 arg2f24);
                  02574 			;float24 operator- _fsub24( float24 arg1f24, float24 arg2f24);
                  02575 			;float24 operator= _int24ToFloat24( int24 arg1f24);
                  02576 			;float24 operator= _int32ToFloat24( int32 arg32);
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 44

ADDR   CODE       LINE  SOURCE

                  02577 			;int24 operator= _float24ToInt24( float24 arg1f24);
                  02578 			;bit operator< _f24_LT_f24( float24 arg1f24, float24 arg2f24);
                  02579 			;bit operator>= _f24_GE_f24( float24 arg1f24, float24 arg2f24);
                  02580 			;bit operator> _f24_GT_f24( float24 arg1f24, float24 arg2f24);
                  02581 			;bit operator<= _f24_LE_f24( float24 arg1f24, float24 arg2f24);
                  02582 			;*/
                  02583 			;
                  02584 			;// DEFINABLE SYMBOLS (in the application code):
                  02585 			;//#define FP_OPTIM_SPEED  // optimize for SPEED: default
                  02586 			;//#define FP_OPTIM_SIZE   // optimize for SIZE
                  02587 			;//#define DISABLE_ROUNDING   // disable rounding and save code space
                  02588 			;
                  02589 			;#define float24ToIEEE754(a) { a.mid8=rl(a.mid8); a.high8=rr(a.high8);\
                  02590 			;                              a.mid8=rr(a.mid8); }
                  02591 			;#define IEEE754ToFloat24(a) { a.mid8=rl(a.mid8); a.high8=rl(a.high8);\
                  02592 			;                              a.mid8=rr(a.mid8); }
                  02593 			;
                  02594 			;
                  02595 			;/*  24 bit floating point format:
                  02596 			;
                  02597 			;  address  ID
                  02598 			;    X      a.low8  : LSB, bit 0-7 of mantissa
                  02599 			;    X+1    a.mid8  : bit 8-14 of mantissa, bit 15 is the sign bit
                  02600 			;    X+2    a.high8 : MSB, bit 0-7 of exponent, with bias 0x7F
                  02601 			;
                  02602 			;    bit 15 of mantissa is a hidden bit, always equal to 1
                  02603 			;    zero (0.0) :  a.high8 = 0 (mantissa & sign ignored)
                  02604 			;
                  02605 			;   MSB    LSB
                  02606 			;    7F 00 00  : 1.0   =  1.0  * 2**(0x7F-0x7F) = 1.0 * 1
                  02607 			;    7F 80 00  : -1.0  = -1.0  * 2**(0x7F-0x7F) = -1.0 * 1
                  02608 			;    80 00 00  : 2.0   =  1.0  * 2**(0x80-0x7F) = 1.0 * 2
                  02609 			;    80 40 00  : 3.0   =  1.5  * 2**(0x80-0x7F) = 1.5 * 2
                  02610 			;    7E 60 00  : 0.875 =  1.75 * 2**(0x7E-0x7F) = 1.75 * 0.5
                  02611 			;    7F 60 00  : 1.75  =  1.75 * 2**(0x7E-0x7F) = 1.75 * 1
                  02612 			;    7F 7F FF  : 1.999969482
                  02613 			;    00 7C 5A  : 0.0 (mantissa & sign ignored)
                  02614 			;    01 00 00  : 1.17549435e-38 =  1.0 * 2**(0x01-0x7F)
                  02615 			;    FE 7F FF  : 3.40277175e+38 =  1.999969482 * 2**(0xFE-0x7F)
                  02616 			;    FF 00 00  : +INF : positive infinity
                  02617 			;    FF 80 00  : -INF : negative infinity
                  02618 			;*/                 
                  02619 			;
                  02620 			;#define  FpBIAS  0x7F
                  02621 			;
                  02622 			;#ifndef FpFlags_defined
                  02623 			; #define FpFlags_defined
                  02624 			;
                  02625 			; char FpFlags;
                  02626 			; //bit IOV         @ FpFlags.0; // integer overflow flag: NOT USED
                  02627 			; bit FpOverflow    @ FpFlags.1; // floating point overflow flag
                  02628 			; bit FpUnderFlow   @ FpFlags.2; // floating point underflow flag
                  02629 			; bit FpDiv0        @ FpFlags.3; // floating point divide by zero flag
                  02630 			; //bit FpNAN       @ FpFlags.4; // not-a-number exception flag: NOT USED
                  02631 			; bit FpDomainError @ FpFlags.5; // domain error exception flag
                  02632 			; bit FpRounding    @ FpFlags.6; // floating point rounding flag, 0=truncation
                  02633 			;                                // 1 = unbiased rounding to nearest LSB
                  02634 			; //bit FpSaturate  @ FpFlags.7; // floating point saturate flag: NOT USED
                  02635 			;
                  02636 			; #pragma floatOverflow FpOverflow
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 45

ADDR   CODE       LINE  SOURCE

                  02637 			; #pragma floatUnderflow FpUnderFlow
                  02638 			;
                  02639 			; #define InitFpFlags()  FpFlags = 0x40 /* enable rounding as default */
                  02640 			;#endif
                  02641 			;
                  02642 			;#ifdef DISABLE_ROUNDING
                  02643 			; #pragma floatRounding 0
                  02644 			;#endif
                  02645 			;
                  02646 			;
                  02647 			;#if __CoreSet__ < 1600
                  02648 			; #define genAdd(r,a) W=a; btsc(Carry); W=incsz(a); r+=W
                  02649 			; #define genSub(r,a) W=a; btss(Carry); W=incsz(a); r-=W
                  02650 			; #define genAddW(r,a) W=a; btsc(Carry); W=incsz(a); W=r+W
                  02651 			; #define genSubW(r,a) W=a; btss(Carry); W=incsz(a); W=r-W
                  02652 			;#else
                  02653 			; #define genAdd(r,a) W=a; r=addWFC(r)
                  02654 			; #define genSub(r,a) W=a; r=subWFB(r)
                  02655 			; #define genAddW(r,a) W=a; W=addWFC(r)
                  02656 			; #define genSubW(r,a) W=a; W=subWFB(r)
                  02657 			;#endif
                  02658 			;
                  02659 			;#if __CoreSet__ == 1700 || __CoreSet__ == 1800
                  02660 			; #define hw_mult8x8(a,b)  W = a; multiply(b)
                  02661 			; #define loRES PRODL
                  02662 			; #define hiRES PRODH
                  02663 			;#endif
                  02664 			;
                  02665 			;#if __CoreSet__ == 2000
                  02666 			; #define hw_mult8x8(a,b)  W = a; multiply(b)
                  02667 			; #define loRES W
                  02668 			; #define hiRES MULH
                  02669 			;#endif
                  02670 			;
                  02671 			;
                  02672 			;float24 operator* _fmul24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  02673 			;{
                  02674 _fmul24
                  02675 			;    uns16 aarg;
                  02676 			;    W = arg1f24.mid8;
000D2E 0100       02677 	MOVLB 0
000D30 51A0       02678 	MOVF  arg1f24+1,W,1
                  02679 			;    aarg.high8 = W;
000D32 6FA6       02680 	MOVWF aarg+1,1
                  02681 			;
                  02682 			;    // save sign
                  02683 			;    char sign = arg2f24.mid8 ^ W;  // before first overflow test
000D34 19A3       02684 	XORWF arg2f24+1,W,1
000D36 6FA7       02685 	MOVWF sign,1
                  02686 			;
                  02687 			;    W = arg1f24.high8;
000D38 51A1       02688 	MOVF  arg1f24+2,W,1
                  02689 			;   #if __CoreSet__ / 100 == 17
                  02690 			;    if (W != 0)
                  02691 			;        W = arg2f24.high8;
                  02692 			;    if (W == 0)
                  02693 			;        goto RES0;
                  02694 			;   #else
                  02695 			;    if (!Zero_)
000D3A A4D8       02696 	BTFSS 0xFD8,Zero_,0
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 46

ADDR   CODE       LINE  SOURCE

                  02697 			;        W = arg2f24.high8;
000D3C 51A4       02698 	MOVF  arg2f24+2,W,1
                  02699 			;    if (Zero_)
000D3E B4D8       02700 	BTFSC 0xFD8,Zero_,0
                  02701 			;        goto RES0;
000D40 D04A       02702 	BRA   m180
                  02703 			;   #endif
                  02704 			;
                  02705 			;    arg1f24.high8 += W /* arg2f24.high8 */;
000D42 0100       02706 	MOVLB 0
000D44 27A1       02707 	ADDWF arg1f24+2,1,1
                  02708 			;    W = FpBIAS-1;
000D46 0E7E       02709 	MOVLW 126
                  02710 			;    if (Carry)  {
000D48 A0D8       02711 	BTFSS 0xFD8,Carry,0
000D4A D004       02712 	BRA   m176
                  02713 			;        arg1f24.high8 -= W;
000D4C 5FA1       02714 	SUBWF arg1f24+2,1,1
                  02715 			;        if (Carry)
000D4E A0D8       02716 	BTFSS 0xFD8,Carry,0
000D50 D005       02717 	BRA   m177
                  02718 			;            goto OVERFLOW;
000D52 D044       02719 	BRA   m181
                  02720 			;    }
                  02721 			;    else  {
                  02722 			;        arg1f24.high8 -= W;
000D54 0100       02723 m176	MOVLB 0
000D56 5FA1       02724 	SUBWF arg1f24+2,1,1
                  02725 			;        if (!Carry)
000D58 A0D8       02726 	BTFSS 0xFD8,Carry,0
                  02727 			;            goto UNDERFLOW;
000D5A D03B       02728 	BRA   m179
                  02729 			;    }
                  02730 			;    aarg.low8 = arg1f24.low8;
000D5C C09F F0A5  02731 m177	MOVFF arg1f24,aarg
                  02732 			;
                  02733 			;    aarg.15 = 1;
000D60 0100       02734 	MOVLB 0
000D62 8FA6       02735 	BSF   aarg+1,7,1
                  02736 			;    arg2f24.15 = 1;
000D64 8FA3       02737 	BSF   arg2f24+1,7,1
                  02738 			;
                  02739 			;   #if defined hw_mult8x8  &&  !defined FP_OPTIM_SIZE
                  02740 			;
                  02741 			;    char tmpL;
                  02742 			;    arg1f24.low16 = 0;
000D66 6B9F       02743 	CLRF  arg1f24,1
000D68 6BA0       02744 	CLRF  arg1f24+1,1
                  02745 			;
                  02746 			;    hw_mult8x8( arg2f24.low8, aarg.low8);   // p1
000D6A 51A2       02747 	MOVF  arg2f24,W,1
000D6C 03A5       02748 	MULWF aarg,1
                  02749 			;    tmpL = hiRES;
000D6E CFF4 F0A8  02750 	MOVFF PRODH,tmpL
                  02751 			;
                  02752 			;    hw_mult8x8( arg2f24.mid8, aarg.low8);  // p2
000D72 51A3       02753 	MOVF  arg2f24+1,W,1
000D74 03A5       02754 	MULWF aarg,1
                  02755 			;    tmpL += loRES;
000D76 50F3       02756 	MOVF  PRODL,W,0
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 47

ADDR   CODE       LINE  SOURCE

000D78 27A8       02757 	ADDWF tmpL,1,1
                  02758 			;    genAdd( arg1f24.low8, hiRES);
000D7A 50F4       02759 	MOVF  PRODH,W,0
000D7C 239F       02760 	ADDWFC arg1f24,1,1
                  02761 			;    genAdd( arg1f24.mid8, 0);
000D7E 0E00       02762 	MOVLW 0
000D80 23A0       02763 	ADDWFC arg1f24+1,1,1
                  02764 			;
                  02765 			;    hw_mult8x8( arg2f24.low8, aarg.mid8);  // p2
000D82 51A2       02766 	MOVF  arg2f24,W,1
000D84 03A6       02767 	MULWF aarg+1,1
                  02768 			;    tmpL += loRES;
000D86 50F3       02769 	MOVF  PRODL,W,0
000D88 27A8       02770 	ADDWF tmpL,1,1
                  02771 			;    genAdd( arg1f24.low8, hiRES);
000D8A 50F4       02772 	MOVF  PRODH,W,0
000D8C 239F       02773 	ADDWFC arg1f24,1,1
                  02774 			;    genAdd( arg1f24.mid8, 0);
000D8E 0E00       02775 	MOVLW 0
000D90 23A0       02776 	ADDWFC arg1f24+1,1,1
                  02777 			;
                  02778 			;    hw_mult8x8( arg2f24.mid8, aarg.mid8);  // p3
000D92 51A3       02779 	MOVF  arg2f24+1,W,1
000D94 03A6       02780 	MULWF aarg+1,1
                  02781 			;    arg1f24.low8 += loRES;
000D96 50F3       02782 	MOVF  PRODL,W,0
000D98 279F       02783 	ADDWF arg1f24,1,1
                  02784 			;    genAdd( arg1f24.mid8, hiRES);
000D9A 50F4       02785 	MOVF  PRODH,W,0
000D9C 23A0       02786 	ADDWFC arg1f24+1,1,1
                  02787 			;
                  02788 			;   #undef hw_mult8x8
                  02789 			;   #undef loRES
                  02790 			;   #undef hiRES
                  02791 			;
                  02792 			;    if (!arg1f24.15)  {
000D9E BFA0       02793 	BTFSC arg1f24+1,7,1
000DA0 D009       02794 	BRA   m178
                  02795 			;        tmpL = rl( tmpL);
000DA2 37A8       02796 	RLCF  tmpL,1,1
                  02797 			;        arg1f24.low16 = rl( arg1f24.low16);
000DA4 379F       02798 	RLCF  arg1f24,1,1
000DA6 37A0       02799 	RLCF  arg1f24+1,1,1
                  02800 			;        if (arg1f24.high8 == 0)
000DA8 53A1       02801 	MOVF  arg1f24+2,1,1
000DAA B4D8       02802 	BTFSC 0xFD8,Zero_,0
                  02803 			;            goto UNDERFLOW;
000DAC D012       02804 	BRA   m179
                  02805 			;        arg1f24.high8 -= 1;
000DAE 0100       02806 	MOVLB 0
000DB0 07A1       02807 	DECF  arg1f24+2,1,1
                  02808 			;        W = rl( tmpL);  // restore bit behind LSB in Carry
000DB2 35A8       02809 	RLCF  tmpL,W,1
                  02810 			;    }
                  02811 			;
                  02812 			;   #else
                  02813 			;
                  02814 			;    arg1f24.low16 = 0;
                  02815 			;
                  02816 			;    char counter = sizeof(aarg)*8;
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 48

ADDR   CODE       LINE  SOURCE

                  02817 			;
                  02818 			;    do  {
                  02819 			;        aarg = rr( aarg);
                  02820 			;        if (Carry)  {
                  02821 			;            arg1f24.low8 += arg2f24.low8;
                  02822 			;            genAdd( arg1f24.mid8, arg2f24.mid8);
                  02823 			;        }
                  02824 			;        arg1f24.low16 = rr( arg1f24.low16);
                  02825 			;        counter = decsz(counter);
                  02826 			;    } while (1);
                  02827 			;
                  02828 			;    if (!arg1f24.15)  {
                  02829 			;        // catch Carry bit that was shifted out previously
                  02830 			;        arg1f24.low16 = rl( arg1f24.low16);
                  02831 			;        if (arg1f24.high8 == 0)
                  02832 			;            goto UNDERFLOW;
                  02833 			;        arg1f24.high8 -= 1;
                  02834 			;        W = rl( aarg.high8);
                  02835 			;        // restore bit behind LSB in Carry
                  02836 			;    }
                  02837 			;
                  02838 			;   #endif
                  02839 			;
                  02840 			;   #ifndef DISABLE_ROUNDING
                  02841 			;    if (FpRounding  &&  Carry)  {
000DB4 0100       02842 m178	MOVLB 0
000DB6 ADC5       02843 	BTFSS 0xC5,FpRounding,1
000DB8 D018       02844 	BRA   m183
000DBA A0D8       02845 	BTFSS 0xFD8,Carry,0
000DBC D016       02846 	BRA   m183
                  02847 			;        arg1f24.low8 += 1;
000DBE 3F9F       02848 	INCFSZ arg1f24,1,1
                  02849 			;        if (!arg1f24.low8)  {
000DC0 D014       02850 	BRA   m183
                  02851 			;            arg1f24.mid8 += 1;
000DC2 3FA0       02852 	INCFSZ arg1f24+1,1,1
                  02853 			;            if (!arg1f24.mid8)  {
000DC4 D012       02854 	BRA   m183
                  02855 			;               #if __CoreSet__ >= 1700 && __CoreSet__ <= 1800
                  02856 			;                Carry = 1; // previous INCF changes Carry
000DC6 80D8       02857 	BSF   0xFD8,Carry,0
                  02858 			;               #else
                  02859 			;                // Carry = 1; //OK
                  02860 			;               #endif
                  02861 			;                arg1f24.low16 = rr( arg1f24.low16);
000DC8 33A0       02862 	RRCF  arg1f24+1,1,1
000DCA 339F       02863 	RRCF  arg1f24,1,1
                  02864 			;                arg1f24.high8 += 1;
000DCC 3FA1       02865 	INCFSZ arg1f24+2,1,1
                  02866 			;                if (Zero_)
000DCE D00D       02867 	BRA   m183
                  02868 			;                    goto OVERFLOW;
000DD0 D005       02869 	BRA   m181
                  02870 			;            }
                  02871 			;        }
                  02872 			;    }
                  02873 			;   #endif
                  02874 			;    goto SET_SIGN;
                  02875 			;
                  02876 			;  UNDERFLOW:
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 49

ADDR   CODE       LINE  SOURCE

                  02877 			;    FpUnderFlow = 1;
000DD2 0100       02878 m179	MOVLB 0
000DD4 85C5       02879 	BSF   0xC5,FpUnderFlow,1
                  02880 			;  RES0:
                  02881 			;    arg1f24.high8 = 0;
000DD6 0100       02882 m180	MOVLB 0
000DD8 6BA1       02883 	CLRF  arg1f24+2,1
                  02884 			;    goto MANTISSA;
000DDA D003       02885 	BRA   m182
                  02886 			;
                  02887 			;  OVERFLOW:
                  02888 			;    FpOverflow = 1;
000DDC 0100       02889 m181	MOVLB 0
000DDE 83C5       02890 	BSF   0xC5,FpOverflow,1
                  02891 			;    arg1f24.high8 = 0xFF;
000DE0 69A1       02892 	SETF  arg1f24+2,1
                  02893 			;  MANTISSA:
                  02894 			;    arg1f24.low16 = 0x8000;
000DE2 0100       02895 m182	MOVLB 0
000DE4 6B9F       02896 	CLRF  arg1f24,1
000DE6 0E80       02897 	MOVLW 128
000DE8 6FA0       02898 	MOVWF arg1f24+1,1
                  02899 			;
                  02900 			;  SET_SIGN:
                  02901 			;    if (!(sign & 0x80))
000DEA 0100       02902 m183	MOVLB 0
000DEC AFA7       02903 	BTFSS sign,7,1
                  02904 			;        arg1f24.15 = 0;
000DEE 9FA0       02905 	BCF   arg1f24+1,7,1
                  02906 			;    return arg1f24;
000DF0 0100       02907 	MOVLB 0
000DF2 519F       02908 	MOVF  arg1f24,W,1
000DF4 0012       02909 	RETURN
                  02910 			;}
                  02911 			;
                  02912 			;
                  02913 			;
                  02914 			;float24 operator/ _fdiv24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  02915 			;{
                  02916 _fdiv24
                  02917 			;    uns16 aarg;
                  02918 			;    W = arg1f24.mid8;
000DF6 0100       02919 	MOVLB 0
000DF8 51A0       02920 	MOVF  arg1f24+1,W,1
                  02921 			;    aarg.high8 = W;
000DFA 6FA6       02922 	MOVWF aarg_2+1,1
                  02923 			;
                  02924 			;    // save sign
                  02925 			;    char sign = arg2f24.mid8 ^ W;  // before first overflow test
000DFC 19A3       02926 	XORWF arg2f24+1,W,1
000DFE 6FA7       02927 	MOVWF sign_2,1
                  02928 			;
                  02929 			;   #if __CoreSet__ / 100 == 17
                  02930 			;    if (!arg2f24.high8)
                  02931 			;        goto Div0;
                  02932 			;   #else
                  02933 			;    W = arg2f24.high8;
000E00 51A4       02934 	MOVF  arg2f24+2,W,1
                  02935 			;    if (Zero_)
000E02 B4D8       02936 	BTFSC 0xFD8,Zero_,0
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 50

ADDR   CODE       LINE  SOURCE

                  02937 			;        goto Div0;
000E04 D05C       02938 	BRA   m194
                  02939 			;   #endif
                  02940 			;    if (!arg1f24.high8)
000E06 0100       02941 	MOVLB 0
000E08 53A1       02942 	MOVF  arg1f24+2,1,1
000E0A B4D8       02943 	BTFSC 0xFD8,Zero_,0
                  02944 			;        goto RES0;
000E0C D05D       02945 	BRA   m196
                  02946 			;
                  02947 			;    arg1f24.high8 -= arg2f24.high8;
000E0E 0100       02948 	MOVLB 0
000E10 51A4       02949 	MOVF  arg2f24+2,W,1
000E12 5FA1       02950 	SUBWF arg1f24+2,1,1
                  02951 			;    W = FpBIAS;
000E14 0E7F       02952 	MOVLW 127
                  02953 			;    if (!Carry)  {
000E16 B0D8       02954 	BTFSC 0xFD8,Carry,0
000E18 D004       02955 	BRA   m184
                  02956 			;        arg1f24.high8 += W;
000E1A 27A1       02957 	ADDWF arg1f24+2,1,1
                  02958 			;        if (!Carry)
000E1C B0D8       02959 	BTFSC 0xFD8,Carry,0
000E1E D005       02960 	BRA   m185
                  02961 			;            goto UNDERFLOW;
000E20 D051       02962 	BRA   m195
                  02963 			;    }
                  02964 			;    else  {
                  02965 			;        arg1f24.high8 += W;
000E22 0100       02966 m184	MOVLB 0
000E24 27A1       02967 	ADDWF arg1f24+2,1,1
                  02968 			;        if (Carry)
000E26 B0D8       02969 	BTFSC 0xFD8,Carry,0
                  02970 			;            goto OVERFLOW;
000E28 D052       02971 	BRA   m197
                  02972 			;    }
                  02973 			;
                  02974 			;    aarg.low8 = arg1f24.low8;
000E2A C09F F0A5  02975 m185	MOVFF arg1f24,aarg_2
                  02976 			;    aarg.15 = 1;
000E2E 0100       02977 	MOVLB 0
000E30 8FA6       02978 	BSF   aarg_2+1,7,1
                  02979 			;    arg2f24.15 = 1;
000E32 8FA3       02980 	BSF   arg2f24+1,7,1
                  02981 			;
                  02982 			;    // division: shift & add
                  02983 			;    char counter = 16;
000E34 0E10       02984 	MOVLW 16
000E36 6FA8       02985 	MOVWF counter,1
                  02986 			;    arg1f24.low16 = 0;  // speedup
000E38 6B9F       02987 	CLRF  arg1f24,1
000E3A 6BA0       02988 	CLRF  arg1f24+1,1
                  02989 			;
                  02990 			;#if defined FP_OPTIM_SPEED || !defined FP_OPTIM_SIZE  // SPEED
                  02991 			;
                  02992 			;    goto START_ML;
000E3C D00B       02993 	BRA   m188
                  02994 			;
                  02995 			;  TEST_ZERO_L:
                  02996 			;    W = aarg.low8 - arg2f24.low8;
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 51

ADDR   CODE       LINE  SOURCE

000E3E 0100       02997 m186	MOVLB 0
000E40 51A2       02998 	MOVF  arg2f24,W,1
000E42 5DA5       02999 	SUBWF aarg_2,W,1
                  03000 			;    if (!Carry)
000E44 A0D8       03001 	BTFSS 0xFD8,Carry,0
                  03002 			;        goto SHIFT_IN_CARRY;
000E46 D013       03003 	BRA   m191
                  03004 			;    aarg.low8 = W;
000E48 0100       03005 	MOVLB 0
000E4A 6FA5       03006 	MOVWF aarg_2,1
                  03007 			;    aarg.high8 = 0;
000E4C 6BA6       03008 	CLRF  aarg_2+1,1
                  03009 			;    goto SET_AND_SHIFT_IN_CARRY;
000E4E D00E       03010 	BRA   m190
                  03011 			;
                  03012 			;// MAIN LOOP
                  03013 			;    do  {
                  03014 			;      LOOP_ML:
                  03015 			;        if (!Carry)  {
000E50 B0D8       03016 m187	BTFSC 0xFD8,Carry,0
000E52 D007       03017 	BRA   m189
                  03018 			;           START_ML:
                  03019 			;            W = aarg.high8 - arg2f24.mid8;
000E54 0100       03020 m188	MOVLB 0
000E56 51A3       03021 	MOVF  arg2f24+1,W,1
000E58 5DA6       03022 	SUBWF aarg_2+1,W,1
                  03023 			;            if (Zero_)
000E5A B4D8       03024 	BTFSC 0xFD8,Zero_,0
                  03025 			;                goto TEST_ZERO_L;
000E5C D7F0       03026 	BRA   m186
                  03027 			;            if (!Carry)
000E5E A0D8       03028 	BTFSS 0xFD8,Carry,0
                  03029 			;                goto SHIFT_IN_CARRY;
000E60 D006       03030 	BRA   m191
                  03031 			;        }
                  03032 			;        aarg.low8 -= arg2f24.low8;
000E62 0100       03033 m189	MOVLB 0
000E64 51A2       03034 	MOVF  arg2f24,W,1
000E66 5FA5       03035 	SUBWF aarg_2,1,1
                  03036 			;        genSub( aarg.high8, arg2f24.mid8);
000E68 51A3       03037 	MOVF  arg2f24+1,W,1
000E6A 5BA6       03038 	SUBWFB aarg_2+1,1,1
                  03039 			;      SET_AND_SHIFT_IN_CARRY:
                  03040 			;        Carry = 1;
000E6C 80D8       03041 m190	BSF   0xFD8,Carry,0
                  03042 			;      SHIFT_IN_CARRY:
                  03043 			;        arg1f24.low16 = rl( arg1f24.low16);
000E6E 0100       03044 m191	MOVLB 0
000E70 379F       03045 	RLCF  arg1f24,1,1
000E72 37A0       03046 	RLCF  arg1f24+1,1,1
                  03047 			;        // Carry = 0;  // ok, speedup
                  03048 			;        aarg = rl( aarg);
000E74 37A5       03049 	RLCF  aarg_2,1,1
000E76 37A6       03050 	RLCF  aarg_2+1,1,1
                  03051 			;        counter = decsz(counter);
000E78 2FA8       03052 	DECFSZ counter,1,1
                  03053 			;    } while (1);
000E7A D7EA       03054 	BRA   m187
                  03055 			;
                  03056 			;
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 52

ADDR   CODE       LINE  SOURCE

                  03057 			;
                  03058 			;#else  // SIZE
                  03059 			;
                  03060 			;    goto START_ML;
                  03061 			;
                  03062 			;// MAIN LOOP
                  03063 			;    do  {
                  03064 			;      LOOP_ML:
                  03065 			;        if (Carry)
                  03066 			;            goto SUBTRACT;
                  03067 			;      START_ML:
                  03068 			;        W = aarg.low8 - arg2f24.low8;
                  03069 			;        genSubW( aarg.high8, arg2f24.mid8);
                  03070 			;        if (!Carry)
                  03071 			;            goto SKIP_SUB;
                  03072 			;       SUBTRACT:
                  03073 			;        aarg.low8 -= arg2f24.low8;
                  03074 			;        genSub( aarg.high8, arg2f24.mid8);
                  03075 			;        Carry = 1;
                  03076 			;       SKIP_SUB:
                  03077 			;        arg1f24.low16 = rl( arg1f24.low16);
                  03078 			;        // Carry = 0;  // ok
                  03079 			;        aarg = rl( aarg);
                  03080 			;        counter = decsz(counter);
                  03081 			;    } while (1);
                  03082 			;
                  03083 			;#endif
                  03084 			;
                  03085 			;    if (!arg1f24.15)  {
000E7C BFA0       03086 	BTFSC arg1f24+1,7,1
000E7E D009       03087 	BRA   m192
                  03088 			;        if (!arg1f24.high8)
000E80 53A1       03089 	MOVF  arg1f24+2,1,1
000E82 B4D8       03090 	BTFSC 0xFD8,Zero_,0
                  03091 			;            goto UNDERFLOW;
000E84 D01F       03092 	BRA   m195
                  03093 			;       #if __CoreSet__ >= 1700 && __CoreSet__ <= 1800
                  03094 			;        sign = rr( sign);   // Save Carry
000E86 0100       03095 	MOVLB 0
000E88 33A7       03096 	RRCF  sign_2,1,1
                  03097 			;       #endif
                  03098 			;        arg1f24.high8 --;
000E8A 07A1       03099 	DECF  arg1f24+2,1,1
                  03100 			;        counter ++;
000E8C 2BA8       03101 	INCF  counter,1,1
                  03102 			;       #if __CoreSet__ >= 1700 && __CoreSet__ <= 1800
                  03103 			;        sign = rl( sign);   // Restore Carry, changed by INCF/DECF
000E8E 37A7       03104 	RLCF  sign_2,1,1
                  03105 			;       #endif
                  03106 			;        goto LOOP_ML;
000E90 D7DF       03107 	BRA   m187
                  03108 			;    }
                  03109 			;
                  03110 			;   #ifndef DISABLE_ROUNDING
                  03111 			;    if (FpRounding)  {
000E92 0100       03112 m192	MOVLB 0
000E94 ADC5       03113 	BTFSS 0xC5,FpRounding,1
000E96 D023       03114 	BRA   m200
                  03115 			;        if (Carry)
000E98 B0D8       03116 	BTFSC 0xFD8,Carry,0
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 53

ADDR   CODE       LINE  SOURCE

                  03117 			;            goto ADD_1;
000E9A D007       03118 	BRA   m193
                  03119 			;        aarg.low8 -= arg2f24.low8;
000E9C 0100       03120 	MOVLB 0
000E9E 51A2       03121 	MOVF  arg2f24,W,1
000EA0 5FA5       03122 	SUBWF aarg_2,1,1
                  03123 			;        genSub( aarg.high8, arg2f24.mid8);
000EA2 51A3       03124 	MOVF  arg2f24+1,W,1
000EA4 5BA6       03125 	SUBWFB aarg_2+1,1,1
                  03126 			;        if (Carry)  {
000EA6 A0D8       03127 	BTFSS 0xFD8,Carry,0
000EA8 D01A       03128 	BRA   m200
                  03129 			;          ADD_1:
                  03130 			;            arg1f24.low8 += 1;
000EAA 0100       03131 m193	MOVLB 0
000EAC 3F9F       03132 	INCFSZ arg1f24,1,1
                  03133 			;            if (!arg1f24.low8)  {
000EAE D017       03134 	BRA   m200
                  03135 			;                arg1f24.mid8 ++;
000EB0 3FA0       03136 	INCFSZ arg1f24+1,1,1
                  03137 			;                if (!arg1f24.mid8)  {
000EB2 D015       03138 	BRA   m200
                  03139 			;                    arg1f24.low16 = rr( arg1f24.low16);
000EB4 33A0       03140 	RRCF  arg1f24+1,1,1
000EB6 339F       03141 	RRCF  arg1f24,1,1
                  03142 			;                    arg1f24.high8 ++;
000EB8 3FA1       03143 	INCFSZ arg1f24+2,1,1
                  03144 			;                    if (!arg1f24.high8)
000EBA D011       03145 	BRA   m200
                  03146 			;                        goto OVERFLOW;
000EBC D008       03147 	BRA   m197
                  03148 			;                }
                  03149 			;            }
                  03150 			;        }
                  03151 			;    }
                  03152 			;   #endif
                  03153 			;    goto SET_SIGN;
                  03154 			;
                  03155 			;  Div0:
                  03156 			;    FpDiv0 = 1;
000EBE 0100       03157 m194	MOVLB 0
000EC0 87C5       03158 	BSF   0xC5,FpDiv0,1
                  03159 			;    goto SATURATE;
000EC2 D007       03160 	BRA   m198
                  03161 			;
                  03162 			;  UNDERFLOW:
                  03163 			;    FpUnderFlow = 1;
000EC4 0100       03164 m195	MOVLB 0
000EC6 85C5       03165 	BSF   0xC5,FpUnderFlow,1
                  03166 			;  RES0:
                  03167 			;    arg1f24.high8 = 0;
000EC8 0100       03168 m196	MOVLB 0
000ECA 6BA1       03169 	CLRF  arg1f24+2,1
                  03170 			;    goto MANTISSA;
000ECC D004       03171 	BRA   m199
                  03172 			;
                  03173 			;  OVERFLOW:
                  03174 			;    FpOverflow = 1;
000ECE 0100       03175 m197	MOVLB 0
000ED0 83C5       03176 	BSF   0xC5,FpOverflow,1
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 54

ADDR   CODE       LINE  SOURCE

                  03177 			;  SATURATE:
                  03178 			;    arg1f24.high8 = 0xFF;
000ED2 0100       03179 m198	MOVLB 0
000ED4 69A1       03180 	SETF  arg1f24+2,1
                  03181 			;  MANTISSA:
                  03182 			;    arg1f24.low16 = 0x8000;
000ED6 0100       03183 m199	MOVLB 0
000ED8 6B9F       03184 	CLRF  arg1f24,1
000EDA 0E80       03185 	MOVLW 128
000EDC 6FA0       03186 	MOVWF arg1f24+1,1
                  03187 			;
                  03188 			;  SET_SIGN:
                  03189 			;    if (!(sign & 0x80))
000EDE 0100       03190 m200	MOVLB 0
000EE0 AFA7       03191 	BTFSS sign_2,7,1
                  03192 			;        arg1f24.15 = 0;
000EE2 9FA0       03193 	BCF   arg1f24+1,7,1
                  03194 			;    return arg1f24;
000EE4 0100       03195 	MOVLB 0
000EE6 519F       03196 	MOVF  arg1f24,W,1
000EE8 0012       03197 	RETURN
                  03198 			;}
                  03199 			;
                  03200 			;
                  03201 			;float24 operator+ _fadd24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  03202 			;{
                  03203 _fadd24
                  03204 			;    char xtra, temp;
                  03205 			;    char expo = arg1f24.high8 - arg2f24.high8;
000EEA 0100       03206 	MOVLB 0
000EEC 51A4       03207 	MOVF  arg2f24+2,W,1
000EEE 5DA1       03208 	SUBWF arg1f24+2,W,1
000EF0 6FA7       03209 	MOVWF expo,1
                  03210 			;    if (!Carry)  {
000EF2 B0D8       03211 	BTFSC 0xFD8,Carry,0
000EF4 D013       03212 	BRA   m201
                  03213 			;        expo = -expo;
000EF6 6DA7       03214 	NEGF  expo,1
                  03215 			;        temp = arg1f24.high8;
000EF8 C0A1 F0A6  03216 	MOVFF arg1f24+2,temp
                  03217 			;        arg1f24.high8 = arg2f24.high8;
000EFC C0A4 F0A1  03218 	MOVFF arg2f24+2,arg1f24+2
                  03219 			;        arg2f24.high8 = temp;
000F00 C0A6 F0A4  03220 	MOVFF temp,arg2f24+2
                  03221 			;        temp = arg1f24.mid8;
000F04 C0A0 F0A6  03222 	MOVFF arg1f24+1,temp
                  03223 			;        arg1f24.mid8 = arg2f24.mid8;
000F08 C0A3 F0A0  03224 	MOVFF arg2f24+1,arg1f24+1
                  03225 			;        arg2f24.mid8 = temp;
000F0C C0A6 F0A3  03226 	MOVFF temp,arg2f24+1
                  03227 			;        temp = arg1f24.low8;
000F10 C09F F0A6  03228 	MOVFF arg1f24,temp
                  03229 			;        arg1f24.low8 = arg2f24.low8;
000F14 C0A2 F09F  03230 	MOVFF arg2f24,arg1f24
                  03231 			;        arg2f24.low8 = temp;
000F18 C0A6 F0A2  03232 	MOVFF temp,arg2f24
                  03233 			;    }
                  03234 			;    if (expo > sizeof(arg1f24)*8-7)
000F1C 0E11       03235 m201	MOVLW 17
000F1E 0100       03236 	MOVLB 0
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 55

ADDR   CODE       LINE  SOURCE

000F20 65A7       03237 	CPFSGT expo,1
000F22 D001       03238 	BRA   m202
                  03239 			;        goto _RETURN_MF;
000F24 D086       03240 	BRA   m220
                  03241 			;    if (!arg2f24.high8)
000F26 0100       03242 m202	MOVLB 0
000F28 53A4       03243 	MOVF  arg2f24+2,1,1
000F2A B4D8       03244 	BTFSC 0xFD8,Zero_,0
                  03245 			;        goto _RETURN_MF;   // result is arg1f24
000F2C D082       03246 	BRA   m220
                  03247 			;
                  03248 			;    xtra = 0;
000F2E 0100       03249 	MOVLB 0
000F30 6BA5       03250 	CLRF  xtra,1
                  03251 			;
                  03252 			;    W = arg1f24.mid8;
000F32 51A0       03253 	MOVF  arg1f24+1,W,1
                  03254 			;    temp = W;
000F34 6FA6       03255 	MOVWF temp,1
                  03256 			;    char sign = arg2f24.mid8 ^ W;
000F36 19A3       03257 	XORWF arg2f24+1,W,1
000F38 6FA8       03258 	MOVWF sign_3,1
                  03259 			;    arg1f24.15 = 1;
000F3A 8FA0       03260 	BSF   arg1f24+1,7,1
                  03261 			;    arg2f24.15 = 1;
000F3C 8FA3       03262 	BSF   arg2f24+1,7,1
                  03263 			;
                  03264 			;    while (1)  {
                  03265 			;        W = 8;
000F3E 0E08       03266 m203	MOVLW 8
                  03267 			;        expo -= W;
000F40 0100       03268 	MOVLB 0
000F42 5FA7       03269 	SUBWF expo,1,1
                  03270 			;        if (!Carry)
000F44 A0D8       03271 	BTFSS 0xFD8,Carry,0
                  03272 			;            break;
000F46 D007       03273 	BRA   m204
                  03274 			;        xtra = arg2f24.low8;
000F48 C0A2 F0A5  03275 	MOVFF arg2f24,xtra
                  03276 			;        arg2f24.low8 = arg2f24.mid8;
000F4C C0A3 F0A2  03277 	MOVFF arg2f24+1,arg2f24
                  03278 			;        arg2f24.mid8 = 0;
000F50 0100       03279 	MOVLB 0
000F52 6BA3       03280 	CLRF  arg2f24+1,1
                  03281 			;    }
000F54 D7F4       03282 	BRA   m203
                  03283 			;    expo += W;
000F56 0100       03284 m204	MOVLB 0
000F58 27A7       03285 	ADDWF expo,1,1
                  03286 			;    if (expo)  {
000F5A B4D8       03287 	BTFSC 0xFD8,Zero_,0
000F5C D007       03288 	BRA   m206
                  03289 			;        do  {
                  03290 			;            Carry = 0;
000F5E 90D8       03291 m205	BCF   0xFD8,Carry,0
                  03292 			;            arg2f24.low16 = rr( arg2f24.low16);
000F60 0100       03293 	MOVLB 0
000F62 33A3       03294 	RRCF  arg2f24+1,1,1
000F64 33A2       03295 	RRCF  arg2f24,1,1
                  03296 			;            xtra = rr( xtra);
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 56

ADDR   CODE       LINE  SOURCE

000F66 33A5       03297 	RRCF  xtra,1,1
                  03298 			;        } while (--expo > 0);
000F68 2FA7       03299 	DECFSZ expo,1,1
000F6A D7F9       03300 	BRA   m205
                  03301 			;    }
                  03302 			;
                  03303 			;
                  03304 			;    if (sign & 0x80)  {
000F6C 0100       03305 m206	MOVLB 0
000F6E AFA8       03306 	BTFSS sign_3,7,1
000F70 D039       03307 	BRA   m212
                  03308 			;        // SUBTRACT
                  03309 			;        arg1f24.low8 -= arg2f24.low8;
000F72 51A2       03310 	MOVF  arg2f24,W,1
000F74 5F9F       03311 	SUBWF arg1f24,1,1
                  03312 			;        genSub( arg1f24.mid8, arg2f24.mid8);
000F76 51A3       03313 	MOVF  arg2f24+1,W,1
000F78 5BA0       03314 	SUBWFB arg1f24+1,1,1
                  03315 			;        if (!Carry)  {  // arg2f24 > arg1f24
000F7A B0D8       03316 	BTFSC 0xFD8,Carry,0
000F7C D007       03317 	BRA   m207
                  03318 			;            arg1f24.low16 = -arg1f24.low16;
000F7E 80D8       03319 	BSF   0xFD8,Carry,0
000F80 0E00       03320 	MOVLW 0
000F82 579F       03321 	SUBFWB arg1f24,1,1
000F84 0E00       03322 	MOVLW 0
000F86 57A0       03323 	SUBFWB arg1f24+1,1,1
                  03324 			;            // xtra == 0 because arg1f24.exp == arg2f24.exp
                  03325 			;            temp ^= 0x80;  // invert sign
000F88 0E80       03326 	MOVLW 128
000F8A 1BA6       03327 	XORWF temp,1,1
                  03328 			;        }
                  03329 			;        xtra = -xtra;
000F8C 0100       03330 m207	MOVLB 0
000F8E 6DA5       03331 	NEGF  xtra,1
                  03332 			;        if (xtra)
000F90 B4D8       03333 	BTFSC 0xFD8,Zero_,0
000F92 D003       03334 	BRA   m208
                  03335 			;            arg1f24.low16 --;
000F94 079F       03336 	DECF  arg1f24,1,1
000F96 0E00       03337 	MOVLW 0
000F98 5BA0       03338 	SUBWFB arg1f24+1,1,1
                  03339 			;        // adjust result left
                  03340 			;       #define counter expo
                  03341 			;        counter = 3;
000F9A 0E03       03342 m208	MOVLW 3
000F9C 0100       03343 	MOVLB 0
000F9E 6FA7       03344 	MOVWF expo,1
                  03345 			;        while (!arg1f24.mid8)  {
000FA0 0100       03346 m209	MOVLB 0
000FA2 53A0       03347 	MOVF  arg1f24+1,1,1
000FA4 A4D8       03348 	BTFSS 0xFD8,Zero_,0
000FA6 D00D       03349 	BRA   m210
                  03350 			;            arg1f24.mid8 = arg1f24.low8;
000FA8 C09F F0A0  03351 	MOVFF arg1f24,arg1f24+1
                  03352 			;            arg1f24.low8 = xtra;
000FAC C0A5 F09F  03353 	MOVFF xtra,arg1f24
                  03354 			;            xtra = 0;
000FB0 6BA5       03355 	CLRF  xtra,1
                  03356 			;            arg1f24.high8 -= 8;
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 57

ADDR   CODE       LINE  SOURCE

000FB2 0E08       03357 	MOVLW 8
000FB4 5FA1       03358 	SUBWF arg1f24+2,1,1
                  03359 			;            if (!Carry)
000FB6 A0D8       03360 	BTFSS 0xFD8,Carry,0
                  03361 			;                goto RES0;
000FB8 D02F       03362 	BRA   m216
                  03363 			;            if (--counter == 0)  // max 2 iterations
000FBA 0100       03364 	MOVLB 0
000FBC 2FA7       03365 	DECFSZ expo,1,1
000FBE D7F0       03366 	BRA   m209
                  03367 			;                goto RES0;
000FC0 D02B       03368 	BRA   m216
                  03369 			;        }
                  03370 			;       #undef counter
                  03371 			;        while (!arg1f24.15)  {
000FC2 0100       03372 m210	MOVLB 0
000FC4 BFA0       03373 	BTFSC arg1f24+1,7,1
000FC6 D007       03374 	BRA   m211
                  03375 			;            Carry = 0;
000FC8 90D8       03376 	BCF   0xFD8,Carry,0
                  03377 			;            xtra = rl( xtra);
000FCA 37A5       03378 	RLCF  xtra,1,1
                  03379 			;            arg1f24.low16 = rl( arg1f24.low16);
000FCC 379F       03380 	RLCF  arg1f24,1,1
000FCE 37A0       03381 	RLCF  arg1f24+1,1,1
                  03382 			;            arg1f24.high8 --;
000FD0 2FA1       03383 	DECFSZ arg1f24+2,1,1
                  03384 			;            if (!arg1f24.high8)
000FD2 D7F7       03385 	BRA   m210
                  03386 			;                goto RES0;   // UNDERFLOW?
000FD4 D021       03387 	BRA   m216
                  03388 			;        }
                  03389 			;       #ifndef DISABLE_ROUNDING
                  03390 			;        if (FpRounding  &&  (xtra & 0x80))  {
000FD6 0100       03391 m211	MOVLB 0
000FD8 ADC5       03392 	BTFSS 0xC5,FpRounding,1
000FDA D028       03393 	BRA   m219
000FDC AFA5       03394 	BTFSS xtra,7,1
000FDE D026       03395 	BRA   m219
                  03396 			;            xtra = 0; // disable recursion
000FE0 6BA5       03397 	CLRF  xtra,1
                  03398 			;            goto INCREMENT;
000FE2 D012       03399 	BRA   m215
                  03400 			;        }
                  03401 			;       #endif
                  03402 			;    }
                  03403 			;    else  {
                  03404 			;        // ADD arg1f24 and arg2f24
                  03405 			;        arg1f24.low8 += arg2f24.low8;
000FE4 0100       03406 m212	MOVLB 0
000FE6 51A2       03407 	MOVF  arg2f24,W,1
000FE8 279F       03408 	ADDWF arg1f24,1,1
                  03409 			;        genAdd( arg1f24.mid8, arg2f24.mid8);
000FEA 51A3       03410 	MOVF  arg2f24+1,W,1
000FEC 23A0       03411 	ADDWFC arg1f24+1,1,1
                  03412 			;        if (Carry)  {
000FEE A0D8       03413 	BTFSS 0xFD8,Carry,0
000FF0 D006       03414 	BRA   m214
                  03415 			;          ADJUST_RIGHT:
                  03416 			;            arg1f24.low16 = rr( arg1f24.low16);
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 58

ADDR   CODE       LINE  SOURCE

000FF2 0100       03417 m213	MOVLB 0
000FF4 33A0       03418 	RRCF  arg1f24+1,1,1
000FF6 339F       03419 	RRCF  arg1f24,1,1
                  03420 			;            xtra = rr( xtra);
000FF8 33A5       03421 	RRCF  xtra,1,1
                  03422 			;            arg1f24.high8 += 1;  // exp
000FFA 4BA1       03423 	INFSNZ arg1f24+2,1,1
                  03424 			;            if (!arg1f24.high8)
                  03425 			;                goto OVERFLOW;
000FFC D010       03426 	BRA   m217
                  03427 			;        }
                  03428 			;       #ifndef DISABLE_ROUNDING
                  03429 			;        if (FpRounding  &&  (xtra & 0x80))  {
000FFE 0100       03430 m214	MOVLB 0
001000 ADC5       03431 	BTFSS 0xC5,FpRounding,1
001002 D014       03432 	BRA   m219
001004 AFA5       03433 	BTFSS xtra,7,1
001006 D012       03434 	BRA   m219
                  03435 			;          INCREMENT:
                  03436 			;            arg1f24.low8 += 1;
001008 0100       03437 m215	MOVLB 0
00100A 3F9F       03438 	INCFSZ arg1f24,1,1
                  03439 			;            if (!arg1f24.low8)  {
00100C D00F       03440 	BRA   m219
                  03441 			;                arg1f24.mid8 += 1;
00100E 3FA0       03442 	INCFSZ arg1f24+1,1,1
                  03443 			;                if (!arg1f24.mid8)  {
001010 D00D       03444 	BRA   m219
                  03445 			;                    Carry = 1; // prepare for shift
001012 80D8       03446 	BSF   0xFD8,Carry,0
                  03447 			;                    arg1f24.0 = 0;  // disable recursion
001014 919F       03448 	BCF   arg1f24,0,1
                  03449 			;                    goto ADJUST_RIGHT;
001016 D7ED       03450 	BRA   m213
                  03451 			;                }
                  03452 			;            }
                  03453 			;        }
                  03454 			;       #endif
                  03455 			;    }
                  03456 			;    goto SET_SIGN;
                  03457 			;
                  03458 			;//  UNDERFLOW:
                  03459 			;//    FpUnderFlow = 1;
                  03460 			;  RES0:
                  03461 			;    arg1f24.high8 = 0;
001018 0100       03462 m216	MOVLB 0
00101A 6BA1       03463 	CLRF  arg1f24+2,1
                  03464 			;    goto MANTISSA;
00101C D003       03465 	BRA   m218
                  03466 			;
                  03467 			;  OVERFLOW:
                  03468 			;    FpOverflow = 1;
00101E 0100       03469 m217	MOVLB 0
001020 83C5       03470 	BSF   0xC5,FpOverflow,1
                  03471 			;    arg1f24.high8 = 0xFF;
001022 69A1       03472 	SETF  arg1f24+2,1
                  03473 			;  MANTISSA:
                  03474 			;    arg1f24.low16 = 0x8000;
001024 0100       03475 m218	MOVLB 0
001026 6B9F       03476 	CLRF  arg1f24,1
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 59

ADDR   CODE       LINE  SOURCE

001028 0E80       03477 	MOVLW 128
00102A 6FA0       03478 	MOVWF arg1f24+1,1
                  03479 			;
                  03480 			;  SET_SIGN:
                  03481 			;    if (!(temp & 0x80))
00102C 0100       03482 m219	MOVLB 0
00102E AFA6       03483 	BTFSS temp,7,1
                  03484 			;        arg1f24.15 = 0;
001030 9FA0       03485 	BCF   arg1f24+1,7,1
                  03486 			;
                  03487 			;  _RETURN_MF:
                  03488 			;    return arg1f24;
001032 0100       03489 m220	MOVLB 0
001034 519F       03490 	MOVF  arg1f24,W,1
001036 0012       03491 	RETURN
                  03492 			;}
                  03493 			;
                  03494 			;
                  03495 			;// SUBTRACTION
                  03496 			;
                  03497 			;float24 operator- _fsub24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  03498 			;{
                  03499 _fsub24
                  03500 			;    arg2f24.mid8 ^= 0x80;
001038 0E80       03501 	MOVLW 128
00103A 0100       03502 	MOVLB 0
00103C 1BA3       03503 	XORWF arg2f24+1,1,1
                  03504 			;    arg1f24 += arg2f24;
00103E DF55       03505 	RCALL _fadd24
                  03506 			;    return arg1f24;
001040 0100       03507 	MOVLB 0
001042 519F       03508 	MOVF  arg1f24,W,1
001044 0012       03509 	RETURN
                  03510 			;}
                  03511 			;
                  03512 			;
                  03513 			;float24 operator=( int8 arg) @
                  03514 			;float24 operator=( uns8 arg) @
                  03515 			;float24 operator=( int16 arg) @
                  03516 			;float24 operator=( uns16 arg) @
                  03517 			;float24 operator= _int24ToFloat24( sharedM int24 arg1f24)
                  03518 			;{
                  03519 _int24ToFloat24
                  03520 			;    sharedM float24 arg2f24;   // unused, but required
                  03521 			;    char expo = FpBIAS + 16 - 1;
001046 0E8E       03522 	MOVLW 142
001048 0100       03523 	MOVLB 0
00104A 6FA5       03524 	MOVWF expo_2,1
                  03525 			;    char xtra = 0;
00104C 6BA6       03526 	CLRF  xtra_2,1
                  03527 			;    char sign = 0;
00104E 6BA7       03528 	CLRF  sign_4,1
                  03529 			;    if (arg1f24 < 0)  {
001050 AFA1       03530 	BTFSS arg1f24+2,7,1
001052 D008       03531 	BRA   m221
                  03532 			;        arg1f24 = -arg1f24;
001054 80D8       03533 	BSF   0xFD8,Carry,0
001056 0E00       03534 	MOVLW 0
001058 579F       03535 	SUBFWB arg1f24,1,1
00105A 0E00       03536 	MOVLW 0
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 60

ADDR   CODE       LINE  SOURCE

00105C 57A0       03537 	SUBFWB arg1f24+1,1,1
00105E 0E00       03538 	MOVLW 0
001060 57A1       03539 	SUBFWB arg1f24+2,1,1
                  03540 			;        sign |= 0x80;
001062 8FA7       03541 	BSF   sign_4,7,1
                  03542 			;    }
                  03543 			;    if (arg1f24.high8)  {
001064 0100       03544 m221	MOVLB 0
001066 53A1       03545 	MOVF  arg1f24+2,1,1
001068 B4D8       03546 	BTFSC 0xFD8,Zero_,0
00106A D009       03547 	BRA   m222
                  03548 			;        expo += 8;
00106C 0E08       03549 	MOVLW 8
00106E 27A5       03550 	ADDWF expo_2,1,1
                  03551 			;        xtra = arg1f24.low8;
001070 C09F F0A6  03552 	MOVFF arg1f24,xtra_2
                  03553 			;        arg1f24.low8 = arg1f24.mid8;
001074 C0A0 F09F  03554 	MOVFF arg1f24+1,arg1f24
                  03555 			;        arg1f24.mid8 = arg1f24.high8;
001078 C0A1 F0A0  03556 	MOVFF arg1f24+2,arg1f24+1
                  03557 			;    }
                  03558 			;    else if (!arg1f24.mid8)  {
00107C D012       03559 	BRA   m224
00107E 0100       03560 m222	MOVLB 0
001080 53A0       03561 	MOVF  arg1f24+1,1,1
001082 A4D8       03562 	BTFSS 0xFD8,Zero_,0
001084 D00E       03563 	BRA   m224
                  03564 			;        expo -= 8;
001086 0E08       03565 	MOVLW 8
001088 5FA5       03566 	SUBWF expo_2,1,1
                  03567 			;        W = arg1f24.low8;
00108A 519F       03568 	MOVF  arg1f24,W,1
                  03569 			;        if (!W)
00108C B4D8       03570 	BTFSC 0xFD8,Zero_,0
                  03571 			;            goto _RETURN_MF;
00108E D01D       03572 	BRA   m226
                  03573 			;        arg1f24.mid8 = W;
001090 0100       03574 	MOVLB 0
001092 6FA0       03575 	MOVWF arg1f24+1,1
                  03576 			;        arg1f24.low8 = 0;
001094 6B9F       03577 	CLRF  arg1f24,1
                  03578 			;    }
                  03579 			;
                  03580 			;    // arg1f24.mid8 != 0
                  03581 			;    goto TEST_ARG1_B15;
001096 D005       03582 	BRA   m224
                  03583 			;    do  {
                  03584 			;        xtra = rl( xtra);
001098 0100       03585 m223	MOVLB 0
00109A 37A6       03586 	RLCF  xtra_2,1,1
                  03587 			;        arg1f24.low16 = rl( arg1f24.low16);
00109C 379F       03588 	RLCF  arg1f24,1,1
00109E 37A0       03589 	RLCF  arg1f24+1,1,1
                  03590 			;        expo --;
0010A0 07A5       03591 	DECF  expo_2,1,1
                  03592 			;      TEST_ARG1_B15:
                  03593 			;    } while (!arg1f24.15);
0010A2 0100       03594 m224	MOVLB 0
0010A4 AFA0       03595 	BTFSS arg1f24+1,7,1
0010A6 D7F8       03596 	BRA   m223
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 61

ADDR   CODE       LINE  SOURCE

                  03597 			;
                  03598 			;   #ifndef DISABLE_ROUNDING
                  03599 			;    if (FpRounding && (xtra & 0x80))  {
0010A8 ADC5       03600 	BTFSS 0xC5,FpRounding,1
0010AA D00A       03601 	BRA   m225
0010AC AFA6       03602 	BTFSS xtra_2,7,1
0010AE D008       03603 	BRA   m225
                  03604 			;        arg1f24.low8 += 1;
0010B0 3F9F       03605 	INCFSZ arg1f24,1,1
                  03606 			;        if (!arg1f24.low8)  {
0010B2 D006       03607 	BRA   m225
                  03608 			;            arg1f24.mid8 += 1;
0010B4 3FA0       03609 	INCFSZ arg1f24+1,1,1
                  03610 			;            if (!arg1f24.mid8)  {
0010B6 D004       03611 	BRA   m225
                  03612 			;                Carry = 1;
0010B8 80D8       03613 	BSF   0xFD8,Carry,0
                  03614 			;                arg1f24.low16 = rr( arg1f24.low16);
0010BA 33A0       03615 	RRCF  arg1f24+1,1,1
0010BC 339F       03616 	RRCF  arg1f24,1,1
                  03617 			;                expo ++;
0010BE 2BA5       03618 	INCF  expo_2,1,1
                  03619 			;            }
                  03620 			;        }
                  03621 			;    }
                  03622 			;   #endif
                  03623 			;
                  03624 			;    arg1f24.high8 = expo;
0010C0 C0A5 F0A1  03625 m225	MOVFF expo_2,arg1f24+2
                  03626 			;    if (!(sign & 0x80))
0010C4 0100       03627 	MOVLB 0
0010C6 AFA7       03628 	BTFSS sign_4,7,1
                  03629 			;        arg1f24.15 = 0;
0010C8 9FA0       03630 	BCF   arg1f24+1,7,1
                  03631 			;
                  03632 			;  _RETURN_MF:
                  03633 			;    float24 rval @ arg1f24;
                  03634 			;    rval.low24 = arg1f24.low24;
                  03635 			;    return rval;
0010CA 0100       03636 m226	MOVLB 0
0010CC 519F       03637 	MOVF  rval,W,1
0010CE 0012       03638 	RETURN
                  03639 			;}
                  03640 			;
                  03641 			;
                  03642 			;float24 operator=( uns24 arg) @
                  03643 			;float24 operator= _int32ToFloat24( int32 arg32)
                  03644 			;{
                  03645 _int32ToFloat24
                  03646 			;    char expo = FpBIAS + 16 - 1;
                  03647 			;    char xtra @ arg32.high8;
                  03648 			;    char sign = 0;
                  03649 			;    if (arg32 < 0)  {
                  03650 			;        arg32 = -arg32;
                  03651 			;        sign |= 0x80;
                  03652 			;    }
                  03653 			;    if (arg32.high8)  {
                  03654 			;        expo += 8;
                  03655 			;        arg32.low8 = arg32.midL8;
                  03656 			;        arg32.midL8 = arg32.midH8;
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 62

ADDR   CODE       LINE  SOURCE

                  03657 			;        arg32.midH8 = arg32.high8;
                  03658 			;        arg32.high8 = 0;
                  03659 			;    }
                  03660 			;    if (arg32.midH8)  {
                  03661 			;        expo += 8;
                  03662 			;        xtra = arg32.low8;
                  03663 			;        arg32.low8 = arg32.midL8;
                  03664 			;        arg32.midL8 = arg32.midH8;
                  03665 			;    }
                  03666 			;    else if (!arg32.midL8)  {
                  03667 			;        expo -= 8;
                  03668 			;        W = arg32.low8;
                  03669 			;        if (!W)
                  03670 			;            goto _RETURN_MF;
                  03671 			;        arg32.midL8 = W;
                  03672 			;        arg32.low8 = 0;
                  03673 			;    }
                  03674 			;
                  03675 			;    // arg32.midL8 != 0
                  03676 			;    goto TEST_ARG_B15;
                  03677 			;    do  {
                  03678 			;        xtra = rl( xtra);
                  03679 			;        arg32.low16 = rl( arg32.low16);
                  03680 			;        expo --;
                  03681 			;      TEST_ARG_B15:
                  03682 			;    } while (!arg32.15);
                  03683 			;
                  03684 			;   #ifndef DISABLE_ROUNDING
                  03685 			;    if (FpRounding && (xtra & 0x80))  {
                  03686 			;        arg32.low8 += 1;
                  03687 			;        if (!arg32.low8)  {
                  03688 			;            arg32.midL8 += 1;
                  03689 			;            if (!arg32.midL8)  {
                  03690 			;                Carry = 1;
                  03691 			;                arg32.low16 = rr( arg32.low16);
                  03692 			;                expo ++;
                  03693 			;            }
                  03694 			;        }
                  03695 			;    }
                  03696 			;   #endif
                  03697 			;
                  03698 			;    arg32.midH8 = expo;
                  03699 			;    if (!(sign & 0x80))
                  03700 			;        arg32.15 = 0;
                  03701 			;
                  03702 			;  _RETURN_MF:
                  03703 			;    float24 rval @ arg32;
                  03704 			;    rval.low24 = arg32.low24;
                  03705 			;    return rval;
                  03706 			;}
                  03707 			;
                  03708 			;
                  03709 			;uns8 operator=( sharedM float24 arg1f24) @
                  03710 			;int8 operator=( sharedM float24 arg1f24) @
                  03711 			;uns16 operator=( sharedM float24 arg1f24) @
                  03712 			;int16 operator=( sharedM float24 arg1f24) @
                  03713 			;int24 operator= _float24ToInt24( sharedM float24 arg1f24)
                  03714 			;{
                  03715 _float24ToInt24
                  03716 			;    sharedM float24 arg2f24;   // unused, but required
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 63

ADDR   CODE       LINE  SOURCE

                  03717 			;    char sign = arg1f24.mid8;
0010D0 C0A0 F0A5  03718 	MOVFF arg1f24+1,sign_6
                  03719 			;    char expo = arg1f24.high8 - (FpBIAS-1);
0010D4 0E7E       03720 	MOVLW 126
0010D6 0100       03721 	MOVLB 0
0010D8 5DA1       03722 	SUBWF arg1f24+2,W,1
0010DA 6FA6       03723 	MOVWF expo_4,1
                  03724 			;    if (!Carry)
0010DC A0D8       03725 	BTFSS 0xFD8,Carry,0
                  03726 			;        goto RES0;
0010DE D032       03727 	BRA   m232
                  03728 			;    arg1f24.15 = 1;
0010E0 0100       03729 	MOVLB 0
0010E2 8FA0       03730 	BSF   arg1f24+1,7,1
                  03731 			;
                  03732 			;    arg1f24.high8 = 0;
0010E4 6BA1       03733 	CLRF  arg1f24+2,1
                  03734 			;   #ifndef DISABLE_ROUNDING
                  03735 			;    char xtra = 0;
0010E6 6BA7       03736 	CLRF  xtra_4,1
                  03737 			;   #endif
                  03738 			;
                  03739 			;    // (a): expo = 0..8 : shift 1 byte to the right
                  03740 			;    // (b): expo = 9..16: shift 0 byte
                  03741 			;    // (c): expo = 17..24: shift 1 byte to the left
                  03742 			;   #if __CoreSet__ / 100 == 12
                  03743 			;    expo -= 17;
                  03744 			;    expo = 0xFF - expo;  // COMF (Carry unchanged)
                  03745 			;    if (Carry)  {  // (c)
                  03746 			;   #else
                  03747 			;    expo = 16 - expo;
0010E8 51A6       03748 	MOVF  expo_4,W,1
0010EA 0810       03749 	SUBLW 16
0010EC 6FA6       03750 	MOVWF expo_4,1
                  03751 			;    if (!Carry)  {  // (c)
0010EE B0D8       03752 	BTFSC 0xFD8,Carry,0
0010F0 D00B       03753 	BRA   m227
                  03754 			;   #endif
                  03755 			;        expo += 8;
0010F2 0E08       03756 	MOVLW 8
0010F4 27A6       03757 	ADDWF expo_4,1,1
                  03758 			;        if (!Carry)
0010F6 A0D8       03759 	BTFSS 0xFD8,Carry,0
                  03760 			;            goto OVERFLOW;
0010F8 D021       03761 	BRA   m231
                  03762 			;        arg1f24.high8 = arg1f24.mid8;
0010FA C0A0 F0A1  03763 	MOVFF arg1f24+1,arg1f24+2
                  03764 			;        arg1f24.mid8 = arg1f24.low8;
0010FE C09F F0A0  03765 	MOVFF arg1f24,arg1f24+1
                  03766 			;        arg1f24.low8 = 0;
001102 0100       03767 	MOVLB 0
001104 6B9F       03768 	CLRF  arg1f24,1
                  03769 			;    }
                  03770 			;    else  {  // (a) (b)
001106 D00B       03771 	BRA   m228
                  03772 			;        // expo = 0 .. 16
                  03773 			;        W = expo - 8;
001108 0E08       03774 m227	MOVLW 8
00110A 0100       03775 	MOVLB 0
00110C 5DA6       03776 	SUBWF expo_4,W,1
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 64

ADDR   CODE       LINE  SOURCE

                  03777 			;        if (Carry)  {  // (a)
00110E A0D8       03778 	BTFSS 0xFD8,Carry,0
001110 D006       03779 	BRA   m228
                  03780 			;            expo = W;
001112 6FA6       03781 	MOVWF expo_4,1
                  03782 			;           #ifndef DISABLE_ROUNDING
                  03783 			;            xtra = arg1f24.low8;
001114 C09F F0A7  03784 	MOVFF arg1f24,xtra_4
                  03785 			;           #endif
                  03786 			;            arg1f24.low8 = arg1f24.mid8;
001118 C0A0 F09F  03787 	MOVFF arg1f24+1,arg1f24
                  03788 			;            arg1f24.mid8 = 0;
00111C 6BA0       03789 	CLRF  arg1f24+1,1
                  03790 			;        }
                  03791 			;    }
                  03792 			;    if (expo)  {
00111E 0100       03793 m228	MOVLB 0
001120 53A6       03794 	MOVF  expo_4,1,1
001122 B4D8       03795 	BTFSC 0xFD8,Zero_,0
001124 D008       03796 	BRA   m230
                  03797 			;        do  {
                  03798 			;            Carry = 0;
001126 90D8       03799 m229	BCF   0xFD8,Carry,0
                  03800 			;            arg1f24.high8 = rr( arg1f24.high8);
001128 0100       03801 	MOVLB 0
00112A 33A1       03802 	RRCF  arg1f24+2,1,1
                  03803 			;            arg1f24.low16 = rr( arg1f24.low16);
00112C 33A0       03804 	RRCF  arg1f24+1,1,1
00112E 339F       03805 	RRCF  arg1f24,1,1
                  03806 			;           #ifndef DISABLE_ROUNDING
                  03807 			;            xtra = rr( xtra);
001130 33A7       03808 	RRCF  xtra_4,1,1
                  03809 			;           #endif
                  03810 			;        } while (--expo);
001132 2FA6       03811 	DECFSZ expo_4,1,1
001134 D7F8       03812 	BRA   m229
                  03813 			;    }
                  03814 			;    if (arg1f24.23)  {
001136 0100       03815 m230	MOVLB 0
001138 AFA1       03816 	BTFSS arg1f24+2,7,1
00113A D00B       03817 	BRA   m234
                  03818 			;       OVERFLOW:
                  03819 			;        FpOverflow = 1;
00113C 0100       03820 m231	MOVLB 0
00113E 83C5       03821 	BSF   0xC5,FpOverflow,1
                  03822 			;        W = 0xFF;
001140 0EFF       03823 	MOVLW 255
                  03824 			;        goto ASSIGNW;
001142 D001       03825 	BRA   m233
                  03826 			;       RES0:
                  03827 			;        W = 0;
001144 0E00       03828 m232	MOVLW 0
                  03829 			;       ASSIGNW:
                  03830 			;        arg1f24.low8 = W;
001146 0100       03831 m233	MOVLB 0
001148 6F9F       03832 	MOVWF arg1f24,1
                  03833 			;        arg1f24.mid8 = W;
00114A 6FA0       03834 	MOVWF arg1f24+1,1
                  03835 			;        arg1f24.high8 = W;
00114C 6FA1       03836 	MOVWF arg1f24+2,1
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 65

ADDR   CODE       LINE  SOURCE

                  03837 			;        arg1f24.23 = 0;
00114E 9FA1       03838 	BCF   arg1f24+2,7,1
                  03839 			;    }
                  03840 			;    else  {
001150 D011       03841 	BRA   m236
                  03842 			;       #ifndef DISABLE_ROUNDING
                  03843 			;        if (FpRounding && (xtra & 0x80))  {
001152 0100       03844 m234	MOVLB 0
001154 ADC5       03845 	BTFSS 0xC5,FpRounding,1
001156 D004       03846 	BRA   m235
001158 AFA7       03847 	BTFSS xtra_4,7,1
00115A D002       03848 	BRA   m235
                  03849 			;            arg1f24.low8 += 1;
00115C 4B9F       03850 	INFSNZ arg1f24,1,1
                  03851 			;            if (!arg1f24.low8)
                  03852 			;                arg1f24.mid8 += 1;
00115E 2BA0       03853 	INCF  arg1f24+1,1,1
                  03854 			;        }
                  03855 			;       #endif
                  03856 			;        if (sign & 0x80)
001160 0100       03857 m235	MOVLB 0
001162 AFA5       03858 	BTFSS sign_6,7,1
001164 D007       03859 	BRA   m236
                  03860 			;            arg1f24.low24 = -arg1f24.low24;
001166 80D8       03861 	BSF   0xFD8,Carry,0
001168 0E00       03862 	MOVLW 0
00116A 579F       03863 	SUBFWB arg1f24,1,1
00116C 0E00       03864 	MOVLW 0
00116E 57A0       03865 	SUBFWB arg1f24+1,1,1
001170 0E00       03866 	MOVLW 0
001172 57A1       03867 	SUBFWB arg1f24+2,1,1
                  03868 			;    }
                  03869 			;    int24 rval @ arg1f24;
                  03870 			;    rval = arg1f24.low24;
                  03871 			;    return rval;
001174 0100       03872 m236	MOVLB 0
001176 519F       03873 	MOVF  rval_3,W,1
001178 0012       03874 	RETURN
                  03875 			;}
                  03876 			;
                  03877 			;
                  03878 			;bit operator< _f24_LT_f24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  03879 			;{
                  03880 _f24_LT_f24
                  03881 			;    Carry = 0;
                  03882 			;    if (!(arg1f24.high8 | arg2f24.high8))
                  03883 			;        return Carry;
                  03884 			;    if (!arg1f24.15)  {
                  03885 			;        if (arg2f24.15)
                  03886 			;            return Carry;
                  03887 			;        W = arg1f24.low8 - arg2f24.low8;
                  03888 			;        genSubW( arg1f24.mid8, arg2f24.mid8);
                  03889 			;        genSubW( arg1f24.high8, arg2f24.high8);
                  03890 			;        goto _RETURN_MF;
                  03891 			;    }
                  03892 			;    if (!arg2f24.15)
                  03893 			;        goto _RETURN_MF;
                  03894 			;    W = arg2f24.low8 - arg1f24.low8;
                  03895 			;    genSubW( arg2f24.mid8, arg1f24.mid8);
                  03896 			;    genSubW( arg2f24.high8, arg1f24.high8);
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 66

ADDR   CODE       LINE  SOURCE

                  03897 			;  _RETURN_MF:
                  03898 			;    if (Carry)
                  03899 			;        return 0;
                  03900 			;    return 1;
                  03901 			;}
                  03902 			;
                  03903 			;
                  03904 			;bit operator>= _f24_GE_f24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  03905 			;{
                  03906 _f24_GE_f24
                  03907 			;    Carry = 1;
                  03908 			;    if (!(arg1f24.high8 | arg2f24.high8))
                  03909 			;        return Carry;
                  03910 			;    if (!arg1f24.15)  {
                  03911 			;        if (arg2f24.15)
                  03912 			;            return Carry;
                  03913 			;        W = arg1f24.low8 - arg2f24.low8;
                  03914 			;        genSubW( arg1f24.mid8, arg2f24.mid8);
                  03915 			;        genSubW( arg1f24.high8, arg2f24.high8);
                  03916 			;        return Carry;
                  03917 			;    }
                  03918 			;    Carry = 0;
                  03919 			;    if (!arg2f24.15)
                  03920 			;        return Carry;
                  03921 			;    W = arg2f24.low8 - arg1f24.low8;
                  03922 			;    genSubW( arg2f24.mid8, arg1f24.mid8);
                  03923 			;    genSubW( arg2f24.high8, arg1f24.high8);
                  03924 			;    return Carry;
                  03925 			;}
                  03926 			;
                  03927 			;
                  03928 			;
                  03929 			;bit operator> _f24_GT_f24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  03930 			;{
                  03931 _f24_GT_f24
                  03932 			;    Carry = 0;
                  03933 			;    if (!(arg1f24.high8 | arg2f24.high8))
                  03934 			;        return Carry;
                  03935 			;    if (!arg1f24.15)  {
                  03936 			;        if (arg2f24.15)
                  03937 			;            goto _RETURN_MF;
                  03938 			;        W = arg2f24.low8 - arg1f24.low8;
                  03939 			;        genSubW( arg2f24.mid8, arg1f24.mid8);
                  03940 			;        genSubW( arg2f24.high8, arg1f24.high8);
                  03941 			;        goto _RETURN_MF;
                  03942 			;    }
                  03943 			;    if (!arg2f24.15)
                  03944 			;        return Carry;
                  03945 			;    W = arg1f24.low8 - arg2f24.low8;
                  03946 			;    genSubW( arg1f24.mid8, arg2f24.mid8);
                  03947 			;    genSubW( arg1f24.high8, arg2f24.high8);
                  03948 			;  _RETURN_MF:
                  03949 			;    if (Carry)
                  03950 			;        return 0;
                  03951 			;    return 1;
                  03952 			;}
                  03953 			;
                  03954 			;
                  03955 			;
                  03956 			;bit operator<= _f24_LE_f24( sharedM float24 arg1f24, sharedM float24 arg2f24)
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 67

ADDR   CODE       LINE  SOURCE

                  03957 			;{
                  03958 _f24_LE_f24
                  03959 			;    Carry = 1;
                  03960 			;    if (!(arg1f24.high8 | arg2f24.high8))
                  03961 			;        return Carry;
                  03962 			;    if (!arg1f24.15)  {
                  03963 			;        Carry = 0;
                  03964 			;        if (arg2f24.15)
                  03965 			;            return Carry;
                  03966 			;        W = arg2f24.low8 - arg1f24.low8;
                  03967 			;        genSubW( arg2f24.mid8, arg1f24.mid8);
                  03968 			;        genSubW( arg2f24.high8, arg1f24.high8);
                  03969 			;        return Carry;
                  03970 			;    }
                  03971 			;    if (!arg2f24.15)
                  03972 			;        return Carry;
                  03973 			;    W = arg1f24.low8 - arg2f24.low8;
                  03974 			;    genSubW( arg1f24.mid8, arg2f24.mid8);
                  03975 			;    genSubW( arg1f24.high8, arg2f24.high8);
                  03976 			;    return Carry;
                  03977 
                  03978   ; FILE ondulador_float.c
                  03979 			;
                  03980 			;//==============================================================================================
                  03981 			;#include "Temporiz_64Mhz.h"
                  03982 			;void configuraPic (void);
                  03983 			;void configura1_PWM (void); 				// Configura todos los pr√°metros excepto M.
                  03984 			;uns8 lectura_VAC (void);
                  03985 			;	
                  03986 			;#include "LCD_4bit.h"
                  03987 			;#include "medir_18F4XK20.h"
                  03988 			;#include "MATH24F.H"
                  03989 			;
                  03990 			;
                  03991 			;static const char mensaje1[19] ="ONDULADOR 50HZ  by ";
                  03992 			;static const char mensaje2[3] ="VAC";
                  03993 			;static const char mensaje3[5] ="VMAX:";
                  03994 			;static const char mensaje4[4] ="DIFF";
                  03995 			;static const uns16 refAC [6] = {567,624,725,781,736,561};
                  03996 			;
                  03997 			;static const uns16 refIC [6] = {600,750,900,900,750,600};
                  03998 			;//==============================================================================================
                  03999 			;//==============================================================================================
                  04000 			;
                  04001 			;void main (void)
                  04002 			;{
                  04003 main
                  04004 			;
                  04005 			;	GIE = 0;								// Desactivamos inicialmente todas las interrupciones.
00117A 9EF2       04006 	BCF   0xFF2,GIE,0
                  04007 			;	configuraPic (); 						// Configuramos todos los puertos y PWM
00117C DB8B       04008 	RCALL configuraPic
                  04009 			;
                  04010 			;
                  04011 			;	char p,h=0;
00117E 0100       04012 	MOVLB 0
001180 6B6E       04013 	CLRF  h,1
                  04014 			;
                  04015 			;	OSCTUNE=0b.01.000000; //PLL enable 
001182 0E40       04016 	MOVLW 64
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 68

ADDR   CODE       LINE  SOURCE

001184 6E9B       04017 	MOVWF OSCTUNE,0
                  04018 			;	
                  04019 			;	RCON = 0b.01111111; //C18 pag 80 i 167  Causes del RESET i IPEN (priority Enabled o no)
001186 0E7F       04020 	MOVLW 127
001188 6ED0       04021 	MOVWF RCON,0
                  04022 			;	OSCCON    = 0b.0.111.0.0.00;
00118A 0E70       04023 	MOVLW 112
00118C 6ED3       04024 	MOVWF OSCCON,0
                  04025 			;
                  04026 			;	inicializar_lcd(); 
00118E ECE1 F001  04027 	CALL  inicializar_lcd
                  04028 			;	borrar_lcd();
001192 EC68 F002  04029 	CALL  borrar_lcd
                  04030 			;//	retardo_100m();
                  04031 			;	RAM_LCD();
001196 DCBA       04032 	RCALL RAM_LCD
                  04033 			;
                  04034 			;	borrar_lcd();
001198 EC68 F002  04035 	CALL  borrar_lcd
                  04036 			;	escribir_posicion (1, 1);
00119C 0E01       04037 	MOVLW 1
00119E 0100       04038 	MOVLB 0
0011A0 6F98       04039 	MOVWF linea,1
0011A2 0E01       04040 	MOVLW 1
0011A4 EC1C F002  04041 	CALL  escribir_posicion
                  04042 			;	
                  04043 			;	for(p=0;p<19;p++ )enviar_literal(mensaje1[p]);
0011A8 0100       04044 	MOVLB 0
0011AA 6B6D       04045 	CLRF  p,1
0011AC 0E13       04046 m237	MOVLW 19
0011AE 0100       04047 	MOVLB 0
0011B0 616D       04048 	CPFSLT p,1
0011B2 D008       04049 	BRA   m238
0011B4 0E5A       04050 	MOVLW 90
0011B6 256D       04051 	ADDWF p,W,1
0011B8 DB85       04052 	RCALL _const1
0011BA EC4A F001  04053 	CALL  enviar_literal
0011BE 0100       04054 	MOVLB 0
0011C0 2B6D       04055 	INCF  p,1,1
0011C2 D7F4       04056 	BRA   m237
                  04057 			;	enviar_literal(LOGO_SC);
0011C4 0E00       04058 m238	MOVLW 0
0011C6 EC4A F001  04059 	CALL  enviar_literal
                  04060 			;
                  04061 			;	T0CON   = 0b.01000.001; //(PIC 18F4550)	// Equivale junto con INTCON2 al OPTION_REG del 16F88x).							
                           	
0011CA 0E41       04062 	MOVLW 65
0011CC 6ED5       04063 	MOVWF T0CON,0
                  04064 			;	INTCON2 = 0b.0000.0100; //(PIC 18F4550)	// Equivale junto con T0CON al OPTION_REG del 16F88x).	
0011CE 0E04       04065 	MOVLW 4
0011D0 6EF1       04066 	MOVWF INTCON2,0
                  04067 			;	TMR0IF = 0;   //T0IF = 0; (PIC 16F88x)	// Ponemos el flanco de interrupciones a cero (aun no se ha efectuado ninguna).
0011D2 94F2       04068 	BCF   0xFF2,TMR0IF,0
                  04069 			;   // w1   =   0;								// Reseteamos la variable √≠ndice de la tabla.
                  04070 			;	LATD.0 =0;           
0011D4 908C       04071 	BCF   LATD,0,0
                  04072 			;
                  04073 			;	Vmax = 3.0; //2 el pwm maximo en 
0011D6 0100       04074 	MOVLB 0
0011D8 6BBD       04075 	CLRF  Vmax,1
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 69

ADDR   CODE       LINE  SOURCE

0011DA 0E40       04076 	MOVLW 64
0011DC 6FBE       04077 	MOVWF Vmax+1,1
0011DE 0E80       04078 	MOVLW 128
0011E0 6FBF       04079 	MOVWF Vmax+2,1
                  04080 			;
                  04081 			;	INTCON = 0b.0100.0000;				// Interrupciones globales (bit 7) e interrupci√≥n por Timer0 (bit 5) activadas.
0011E2 0E40       04082 	MOVLW 64
0011E4 6EF2       04083 	MOVWF INTCON,0
                  04084 			;
                  04085 			;	// COMEN√áO AL PAS PER 0, AMB 2 CICLES DE PWM A Ton=0 --> SON 100uS
                  04086 			;	T=0;
0011E6 6BC2       04087 	CLRF  T,1
                  04088 			;	ancho_pwm =0; 
0011E8 6BB9       04089 	CLRF  ancho_pwm,1
0011EA 6BBA       04090 	CLRF  ancho_pwm+1,1
                  04091 			;	bUdw=1;	// Comen√ßo carregant 0
0011EC 81B8       04092 	BSF   0xB8,bUdw,1
                  04093 			;	for (i = 1; i <= 6; i ++)  ancho_pwm = rl (ancho_pwm);
0011EE 0E01       04094 	MOVLW 1
0011F0 6FC3       04095 	MOVWF i,1
0011F2 0E07       04096 m239	MOVLW 7
0011F4 0100       04097 	MOVLB 0
0011F6 61C3       04098 	CPFSLT i,1
0011F8 D004       04099 	BRA   m240
0011FA 37B9       04100 	RLCF  ancho_pwm,1,1
0011FC 37BA       04101 	RLCF  ancho_pwm+1,1,1
0011FE 2BC3       04102 	INCF  i,1,1
001200 D7F8       04103 	BRA   m239
                  04104 			;	CCPR1L = ancho_pwm.high8;
001202 C0BA FFBE  04105 m240	MOVFF ancho_pwm+1,CCPR1L
                  04106 			;	CCP1CON.5 = ancho_pwm.7;
001206 0100       04107 	MOVLB 0
001208 AFB9       04108 	BTFSS ancho_pwm,7,1
00120A 9ABD       04109 	BCF   CCP1CON,5,0
00120C BFB9       04110 	BTFSC ancho_pwm,7,1
00120E 8ABD       04111 	BSF   CCP1CON,5,0
                  04112 			;	CCP1CON.4 = ancho_pwm.6; // PWM carregat a 0
001210 ADB9       04113 	BTFSS ancho_pwm,6,1
001212 98BD       04114 	BCF   CCP1CON,4,0
001214 BDB9       04115 	BTFSC ancho_pwm,6,1
001216 88BD       04116 	BSF   CCP1CON,4,0
                  04117 			;	TMR2IF=0;	
001218 929E       04118 	BCF   0xF9E,TMR2IF,0
                  04119 			;	TMR2IE=1; 
00121A 829D       04120 	BSF   0xF9D,TMR2IE,0
                  04121 			;	TMR2ON  = 1;
00121C 84CA       04122 	BSF   0xFCA,TMR2ON,0
                  04123 			;	T++; SENO = sen[T];		
00121E 2BC2       04124 	INCF  T,1,1
001220 51C2       04125 	MOVF  T,W,1
001222 DB50       04126 	RCALL _const1
001224 0100       04127 	MOVLB 0
001226 6FC0       04128 	MOVWF SENO,1
001228 6BC1       04129 	CLRF  SENO+1,1
                  04130 			;	ancho_pwm = (uns16)SENO*Vmax; // PREPARO SEGUENT VALOR
00122A C0C0 F09F  04131 	MOVFF SENO,arg1f24
00122E C0C1 F0A0  04132 	MOVFF SENO+1,arg1f24+1
001232 6BA1       04133 	CLRF  arg1f24+2,1
001234 DF08       04134 	RCALL _int24ToFloat24
001236 C0BD F0A2  04135 	MOVFF Vmax,arg2f24
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 70

ADDR   CODE       LINE  SOURCE

00123A C0BE F0A3  04136 	MOVFF Vmax+1,arg2f24+1
00123E C0BF F0A4  04137 	MOVFF Vmax+2,arg2f24+2
001242 DD75       04138 	RCALL _fmul24
001244 DF45       04139 	RCALL _float24ToInt24
001246 C09F F0B9  04140 	MOVFF rval_3,ancho_pwm
00124A C0A0 F0BA  04141 	MOVFF rval_3+1,ancho_pwm+1
                  04142 			; //**************************************************************************************//
                  04143 			; //*******************  V A R I A B L E S   L O C A L E L E S ***************************//
                  04144 			; //**************************************************************************************//
                  04145 			;	estado=0; //empieza por estado 0
00124E 0100       04146 	MOVLB 0
001250 6BC4       04147 	CLRF  estado,1
                  04148 			;	uns8 x;
                  04149 			;	uns16 vac[6],ac;    //variables para guardar temporalmente las arrays
                  04150 			;	uns16 iac[6],ic,rf;
                  04151 			;	uns16 dif,difMediaAC,difMediaIC;
                  04152 			;	char vbat,o=0,BP=10; //Banda proporcional 10% 
001252 6B95       04153 	CLRF  o,1
001254 0E0A       04154 	MOVLW 10
001256 6F96       04155 	MOVWF BP,1
                  04156 			;	bit a,b,c,vuelta=0,flancoVAC,flancoIAC;
001258 9797       04157 	BCF   0x97,vuelta,1
                  04158 			;	
                  04159 			;	escribir_posicion (2, 1);
00125A 0E02       04160 	MOVLW 2
00125C 6F98       04161 	MOVWF linea,1
00125E 0E01       04162 	MOVLW 1
001260 EC1C F002  04163 	CALL  escribir_posicion
                  04164 			; 	for(p=0;p<3;p++ )enviar_literal(mensaje2[p]);
001264 0100       04165 	MOVLB 0
001266 6B6D       04166 	CLRF  p,1
001268 0E03       04167 m241	MOVLW 3
00126A 0100       04168 	MOVLB 0
00126C 616D       04169 	CPFSLT p,1
00126E D008       04170 	BRA   m242
001270 0E6D       04171 	MOVLW 109
001272 256D       04172 	ADDWF p,W,1
001274 DB27       04173 	RCALL _const1
001276 EC4A F001  04174 	CALL  enviar_literal
00127A 0100       04175 	MOVLB 0
00127C 2B6D       04176 	INCF  p,1,1
00127E D7F4       04177 	BRA   m241
                  04178 			; 	escribir_posicion (4, 1);
001280 0E04       04179 m242	MOVLW 4
001282 0100       04180 	MOVLB 0
001284 6F98       04181 	MOVWF linea,1
001286 0E01       04182 	MOVLW 1
001288 EC1C F002  04183 	CALL  escribir_posicion
                  04184 			; 	for(p=0;p<5;p++ )enviar_literal(mensaje3[p]);
00128C 0100       04185 	MOVLB 0
00128E 6B6D       04186 	CLRF  p,1
001290 0E05       04187 m243	MOVLW 5
001292 0100       04188 	MOVLB 0
001294 616D       04189 	CPFSLT p,1
001296 D008       04190 	BRA   m244
001298 0E70       04191 	MOVLW 112
00129A 256D       04192 	ADDWF p,W,1
00129C DB13       04193 	RCALL _const1
00129E EC4A F001  04194 	CALL  enviar_literal
0012A2 0100       04195 	MOVLB 0
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 71

ADDR   CODE       LINE  SOURCE

0012A4 2B6D       04196 	INCF  p,1,1
0012A6 D7F4       04197 	BRA   m243
                  04198 			; 	escribir_posicion (4, 12);
0012A8 0E04       04199 m244	MOVLW 4
0012AA 0100       04200 	MOVLB 0
0012AC 6F98       04201 	MOVWF linea,1
0012AE 0E0C       04202 	MOVLW 12
0012B0 EC1C F002  04203 	CALL  escribir_posicion
                  04204 			;	for(p=0;p<4;p++ )enviar_literal(mensaje4[p]);
0012B4 0100       04205 	MOVLB 0
0012B6 6B6D       04206 	CLRF  p,1
0012B8 0E04       04207 m245	MOVLW 4
0012BA 0100       04208 	MOVLB 0
0012BC 616D       04209 	CPFSLT p,1
0012BE D008       04210 	BRA   m246
0012C0 0E75       04211 	MOVLW 117
0012C2 256D       04212 	ADDWF p,W,1
0012C4 DAFF       04213 	RCALL _const1
0012C6 EC4A F001  04214 	CALL  enviar_literal
0012CA 0100       04215 	MOVLB 0
0012CC 2B6D       04216 	INCF  p,1,1
0012CE D7F4       04217 	BRA   m245
                  04218 			; 	GIE=1;
0012D0 8EF2       04219 m246	BSF   0xFF2,GIE,0
                  04220 			;	ADCON1=0b.0000.0000;
0012D2 6AC1       04221 	CLRF  ADCON1,0
                  04222 			;	ADCON2=0b.10.001.110;
0012D4 0E8E       04223 	MOVLW 142
0012D6 6EC0       04224 	MOVWF ADCON2,0
                  04225 			;
                  04226 			; //**************************************************************************************//
                  04227 			; //**************************  B U C L E   I N F I N I T O  *****************************//
                  04228 			; //**************************************************************************************//
                  04229 			;	while (1)       					
                  04230 			;	{
                  04231 			;				
                  04232 			;		switch(estado){
0012D8 0100       04233 m247	MOVLB 0
0012DA 51C4       04234 	MOVF  estado,W,1
0012DC B4D8       04235 	BTFSC 0xFD8,Zero_,0
0012DE D010       04236 	BRA   m248
0012E0 0A01       04237 	XORLW 1
0012E2 B4D8       04238 	BTFSC 0xFD8,Zero_,0
0012E4 D065       04239 	BRA   m254
0012E6 0A03       04240 	XORLW 3
0012E8 B4D8       04241 	BTFSC 0xFD8,Zero_,0
0012EA D142       04242 	BRA   m268
0012EC 0A01       04243 	XORLW 1
0012EE B4D8       04244 	BTFSC 0xFD8,Zero_,0
0012F0 D19A       04245 	BRA   m274
0012F2 0A07       04246 	XORLW 7
0012F4 B4D8       04247 	BTFSC 0xFD8,Zero_,0
0012F6 D1EC       04248 	BRA   m282
0012F8 0A01       04249 	XORLW 1
0012FA B4D8       04250 	BTFSC 0xFD8,Zero_,0
0012FC D259       04251 	BRA   m291
0012FE D7EC       04252 	BRA   m247
                  04253 			;			case LECTURA_VAC:
                  04254 			;				x=0;
001300 0100       04255 m248	MOVLB 0
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 72

ADDR   CODE       LINE  SOURCE

001302 6B6F       04256 	CLRF  x,1
                  04257 			;				while(LATD.0==1){   //vmax en LEO_VAC 18V 22k serie 8k2
001304 A08C       04258 m249	BTFSS LATD,0,0
001306 D04C       04259 	BRA   m253
                  04260 			;						if (((T == 6)&&((x==0)||(x==5))) || ((T == 12 )&&((x==1)||(x==4))) || ((T == 20)&&((x==2)||(x==3)))) {
001308 0E06       04261 	MOVLW 6
00130A 0100       04262 	MOVLB 0
00130C 63C2       04263 	CPFSEQ T,1
00130E D007       04264 	BRA   m250
001310 536F       04265 	MOVF  x,1,1
001312 B4D8       04266 	BTFSC 0xFD8,Zero_,0
001314 D019       04267 	BRA   m252
001316 516F       04268 	MOVF  x,W,1
001318 0A05       04269 	XORLW 5
00131A B4D8       04270 	BTFSC 0xFD8,Zero_,0
00131C D015       04271 	BRA   m252
00131E 0E0C       04272 m250	MOVLW 12
001320 0100       04273 	MOVLB 0
001322 63C2       04274 	CPFSEQ T,1
001324 D006       04275 	BRA   m251
001326 4D6F       04276 	DCFSNZ x,W,1
001328 D00F       04277 	BRA   m252
00132A 516F       04278 	MOVF  x,W,1
00132C 0A04       04279 	XORLW 4
00132E B4D8       04280 	BTFSC 0xFD8,Zero_,0
001330 D00B       04281 	BRA   m252
001332 0E14       04282 m251	MOVLW 20
001334 0100       04283 	MOVLB 0
001336 63C2       04284 	CPFSEQ T,1
001338 D7E5       04285 	BRA   m249
00133A 516F       04286 	MOVF  x,W,1
00133C 0A02       04287 	XORLW 2
00133E B4D8       04288 	BTFSC 0xFD8,Zero_,0
001340 D003       04289 	BRA   m252
001342 0E03       04290 	MOVLW 3
001344 636F       04291 	CPFSEQ x,1
001346 D7DE       04292 	BRA   m249
                  04293 			;						ac=medir(LEO_VAC,10);
001348 0100       04294 m252	MOVLB 0
00134A 6B9D       04295 	CLRF  canal,1
00134C 0E0A       04296 	MOVLW 10
00134E DC7E       04297 	RCALL medir
001350 C09F F07C  04298 	MOVFF resultado,ac
001354 C0A0 F07D  04299 	MOVFF resultado+1,ac+1
                  04300 			;						vac[x]=ac;
001358 6AEA       04301 	CLRF  FSR0+1,0
00135A 90D8       04302 	BCF   0xFD8,Carry,0
00135C 0100       04303 	MOVLB 0
00135E 356F       04304 	RLCF  x,W,1
001360 0F70       04305 	ADDLW 112
001362 6EE9       04306 	MOVWF FSR0,0
001364 C07C FFEE  04307 	MOVFF ac,POSTINC0
001368 C07D FFEE  04308 	MOVFF ac+1,POSTINC0
                  04309 			;						x++;
00136C 2B6F       04310 	INCF  x,1,1
                  04311 			;						
                  04312 			;						if ((T==20&&x==3)) {retardo_20u();retardo_20u();retardo_20u();retardo_20u();
00136E 0E14       04313 	MOVLW 20
001370 63C2       04314 	CPFSEQ T,1
001372 D7C8       04315 	BRA   m249
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 73

ADDR   CODE       LINE  SOURCE

001374 0E03       04316 	MOVLW 3
001376 636F       04317 	CPFSEQ x,1
001378 D7C5       04318 	BRA   m249
00137A EC9C F000  04319 	CALL  retardo_20u
00137E EC9C F000  04320 	CALL  retardo_20u
001382 EC9C F000  04321 	CALL  retardo_20u
001386 EC9C F000  04322 	CALL  retardo_20u
                  04323 			;							retardo_20u();retardo_20u();retardo_20u();retardo_20u();retardo_20u();}
00138A EC9C F000  04324 	CALL  retardo_20u
00138E EC9C F000  04325 	CALL  retardo_20u
001392 EC9C F000  04326 	CALL  retardo_20u
001396 EC9C F000  04327 	CALL  retardo_20u
00139A EC9C F000  04328 	CALL  retardo_20u
                  04329 			;					}		
                  04330 			;				}
00139E D7B2       04331 	BRA   m249
                  04332 			;				estado = CALCULOS_VAC;
0013A0 0E01       04333 m253	MOVLW 1
0013A2 0100       04334 	MOVLB 0
0013A4 6FC4       04335 	MOVWF estado,1
                  04336 			;				if(x<=4) estado = LECTURA_VAC;
0013A6 0E05       04337 	MOVLW 5
0013A8 616F       04338 	CPFSLT x,1
0013AA D796       04339 	BRA   m247
0013AC 6BC4       04340 	CLRF  estado,1
                  04341 			;			break;
0013AE D794       04342 	BRA   m247
                  04343 			;
                  04344 			;			case CALCULOS_VAC:
                  04345 			;				difMediaAC=0;
0013B0 0100       04346 m254	MOVLB 0
0013B2 6B90       04347 	CLRF  difMediaAC,1
0013B4 6B91       04348 	CLRF  difMediaAC+1,1
                  04349 			;				for(p=0;p<=5;p++){
0013B6 6B6D       04350 	CLRF  p,1
0013B8 0E06       04351 m255	MOVLW 6
0013BA 0100       04352 	MOVLB 0
0013BC 616D       04353 	CPFSLT p,1
0013BE D02F       04354 	BRA   m258
                  04355 			;					ac= vac[p];
0013C0 6AEA       04356 	CLRF  FSR0+1,0
0013C2 90D8       04357 	BCF   0xFD8,Carry,0
0013C4 356D       04358 	RLCF  p,W,1
0013C6 0F70       04359 	ADDLW 112
0013C8 6EE9       04360 	MOVWF FSR0,0
0013CA CFEE F07C  04361 	MOVFF POSTINC0,ac
0013CE CFEE F07D  04362 	MOVFF POSTINC0,ac+1
                  04363 			;					rf= refAC[p];
0013D2 90D8       04364 	BCF   0xFD8,Carry,0
0013D4 356D       04365 	RLCF  p,W,1
0013D6 0F79       04366 	ADDLW 121
0013D8 DA75       04367 	RCALL _const1
0013DA 0100       04368 	MOVLB 0
0013DC 6F8C       04369 	MOVWF rf,1
0013DE 000B       04370 	TBLRD +*
0013E0 50F5       04371 	MOVF  TABLAT,W,0
0013E2 6F8D       04372 	MOVWF rf+1,1
                  04373 			;					if(ac>=rf){
0013E4 518C       04374 	MOVF  rf,W,1
0013E6 5D7C       04375 	SUBWF ac,W,1
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 74

ADDR   CODE       LINE  SOURCE

0013E8 518D       04376 	MOVF  rf+1,W,1
0013EA 597D       04377 	SUBWFB ac+1,W,1
0013EC A0D8       04378 	BTFSS 0xFD8,Carry,0
0013EE D008       04379 	BRA   m256
                  04380 			;						dif=ac-rf;
0013F0 518C       04381 	MOVF  rf,W,1
0013F2 5D7C       04382 	SUBWF ac,W,1
0013F4 6F8E       04383 	MOVWF dif,1
0013F6 518D       04384 	MOVF  rf+1,W,1
0013F8 597D       04385 	SUBWFB ac+1,W,1
0013FA 6F8F       04386 	MOVWF dif+1,1
                  04387 			;						flancoVAC=PORENCIMA;
0013FC 8997       04388 	BSF   0x97,flancoVAC,1
                  04389 			;					}
                  04390 			;					else {
0013FE D008       04391 	BRA   m257
                  04392 			;						dif= rf-ac;
001400 0100       04393 m256	MOVLB 0
001402 517C       04394 	MOVF  ac,W,1
001404 5D8C       04395 	SUBWF rf,W,1
001406 6F8E       04396 	MOVWF dif,1
001408 517D       04397 	MOVF  ac+1,W,1
00140A 598D       04398 	SUBWFB rf+1,W,1
00140C 6F8F       04399 	MOVWF dif+1,1
                  04400 			;						flancoVAC=PORDEBAJO;
00140E 9997       04401 	BCF   0x97,flancoVAC,1
                  04402 			;					}
                  04403 			;					difMediaAC+=dif; 
001410 0100       04404 m257	MOVLB 0
001412 518E       04405 	MOVF  dif,W,1
001414 2790       04406 	ADDWF difMediaAC,1,1
001416 518F       04407 	MOVF  dif+1,W,1
001418 2391       04408 	ADDWFC difMediaAC+1,1,1
                  04409 			;				}
00141A 2B6D       04410 	INCF  p,1,1
00141C D7CD       04411 	BRA   m255
                  04412 			;
                  04413 			;				difMediaAC/=6;
00141E 0100       04414 m258	MOVLB 0
001420 5190       04415 	MOVF  difMediaAC,W,1
001422 6F9E       04416 	MOVWF C42tmp,1
001424 5191       04417 	MOVF  difMediaAC+1,W,1
001426 6F9F       04418 	MOVWF C42tmp+1,1
001428 6BA0       04419 	CLRF  C43rem,1
00142A 0E10       04420 	MOVLW 16
00142C 6F9D       04421 	MOVWF C41cnt,1
00142E 0100       04422 m259	MOVLB 0
001430 379E       04423 	RLCF  C42tmp,1,1
001432 379F       04424 	RLCF  C42tmp+1,1,1
001434 37A0       04425 	RLCF  C43rem,1,1
001436 B0D8       04426 	BTFSC 0xFD8,Carry,0
001438 D004       04427 	BRA   m260
00143A 0E06       04428 	MOVLW 6
00143C 5DA0       04429 	SUBWF C43rem,W,1
00143E A0D8       04430 	BTFSS 0xFD8,Carry,0
001440 D004       04431 	BRA   m261
001442 0E06       04432 m260	MOVLW 6
001444 0100       04433 	MOVLB 0
001446 5FA0       04434 	SUBWF C43rem,1,1
001448 80D8       04435 	BSF   0xFD8,Carry,0
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 75

ADDR   CODE       LINE  SOURCE

00144A 0100       04436 m261	MOVLB 0
00144C 3790       04437 	RLCF  difMediaAC,1,1
00144E 3791       04438 	RLCF  difMediaAC+1,1,1
001450 2F9D       04439 	DECFSZ C41cnt,1,1
001452 D7ED       04440 	BRA   m259
                  04441 			;				
                  04442 			;				//intento de PID	
                  04443 			;				Vmax=3.0; //reset Vmax
001454 6BBD       04444 	CLRF  Vmax,1
001456 0E40       04445 	MOVLW 64
001458 6FBE       04446 	MOVWF Vmax+1,1
00145A 0E80       04447 	MOVLW 128
00145C 6FBF       04448 	MOVWF Vmax+2,1
                  04449 			;				float variacion= 3.0*difMediaAC;
00145E C090 F09F  04450 	MOVFF difMediaAC,arg1f24
001462 C091 F0A0  04451 	MOVFF difMediaAC+1,arg1f24+1
001466 6BA1       04452 	CLRF  arg1f24+2,1
001468 DDEE       04453 	RCALL _int24ToFloat24
00146A 0100       04454 	MOVLB 0
00146C 6BA2       04455 	CLRF  arg2f24,1
00146E 0E40       04456 	MOVLW 64
001470 6FA3       04457 	MOVWF arg2f24+1,1
001472 0E80       04458 	MOVLW 128
001474 6FA4       04459 	MOVWF arg2f24+2,1
001476 DC5B       04460 	RCALL _fmul24
001478 C09F F098  04461 	MOVFF arg1f24,variacion
00147C C0A0 F099  04462 	MOVFF arg1f24+1,variacion+1
001480 C0A1 F09A  04463 	MOVFF arg1f24+2,variacion+2
                  04464 			;				variacion/=240.0;
001484 C098 F09F  04465 	MOVFF variacion,arg1f24
001488 C099 F0A0  04466 	MOVFF variacion+1,arg1f24+1
00148C C09A F0A1  04467 	MOVFF variacion+2,arg1f24+2
001490 0100       04468 	MOVLB 0
001492 6BA2       04469 	CLRF  arg2f24,1
001494 0E70       04470 	MOVLW 112
001496 6FA3       04471 	MOVWF arg2f24+1,1
001498 0E86       04472 	MOVLW 134
00149A 6FA4       04473 	MOVWF arg2f24+2,1
00149C DCAC       04474 	RCALL _fdiv24
00149E C09F F098  04475 	MOVFF arg1f24,variacion
0014A2 C0A0 F099  04476 	MOVFF arg1f24+1,variacion+1
0014A6 C0A1 F09A  04477 	MOVFF arg1f24+2,variacion+2
                  04478 			;				
                  04479 			;				if(flancoVAC==PORENCIMA){	
0014AA 0100       04480 	MOVLB 0
0014AC A997       04481 	BTFSS 0x97,flancoVAC,1
0014AE D025       04482 	BRA   m264
                  04483 			;					if(variacion<=3.0) Vmax+=variacion;
0014B0 BF99       04484 	BTFSC variacion+1,7,1
0014B2 D008       04485 	BRA   m262
0014B4 0E01       04486 	MOVLW 1
0014B6 5D98       04487 	SUBWF variacion,W,1
0014B8 0E40       04488 	MOVLW 64
0014BA 5999       04489 	SUBWFB variacion+1,W,1
0014BC 0E80       04490 	MOVLW 128
0014BE 599A       04491 	SUBWFB variacion+2,W,1
0014C0 B0D8       04492 	BTFSC 0xFD8,Carry,0
0014C2 D014       04493 	BRA   m263
0014C4 C0BD F09F  04494 m262	MOVFF Vmax,arg1f24
0014C8 C0BE F0A0  04495 	MOVFF Vmax+1,arg1f24+1
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 76

ADDR   CODE       LINE  SOURCE

0014CC C0BF F0A1  04496 	MOVFF Vmax+2,arg1f24+2
0014D0 C098 F0A2  04497 	MOVFF variacion,arg2f24
0014D4 C099 F0A3  04498 	MOVFF variacion+1,arg2f24+1
0014D8 C09A F0A4  04499 	MOVFF variacion+2,arg2f24+2
0014DC DD06       04500 	RCALL _fadd24
0014DE C09F F0BD  04501 	MOVFF arg1f24,Vmax
0014E2 C0A0 F0BE  04502 	MOVFF arg1f24+1,Vmax+1
0014E6 C0A1 F0BF  04503 	MOVFF arg1f24+2,Vmax+2
                  04504 			;					else Vmax=6.0;
0014EA D02B       04505 	BRA   m267
0014EC 0100       04506 m263	MOVLB 0
0014EE 6BBD       04507 	CLRF  Vmax,1
0014F0 0E40       04508 	MOVLW 64
0014F2 6FBE       04509 	MOVWF Vmax+1,1
0014F4 0E81       04510 	MOVLW 129
0014F6 6FBF       04511 	MOVWF Vmax+2,1
                  04512 			;				}
                  04513 			;				else{
0014F8 D024       04514 	BRA   m267
                  04515 			;					if(variacion<=3.0) Vmax-=variacion;
0014FA 0100       04516 m264	MOVLB 0
0014FC BF99       04517 	BTFSC variacion+1,7,1
0014FE D008       04518 	BRA   m265
001500 0E01       04519 	MOVLW 1
001502 5D98       04520 	SUBWF variacion,W,1
001504 0E40       04521 	MOVLW 64
001506 5999       04522 	SUBWFB variacion+1,W,1
001508 0E80       04523 	MOVLW 128
00150A 599A       04524 	SUBWFB variacion+2,W,1
00150C B0D8       04525 	BTFSC 0xFD8,Carry,0
00150E D014       04526 	BRA   m266
001510 C0BD F09F  04527 m265	MOVFF Vmax,arg1f24
001514 C0BE F0A0  04528 	MOVFF Vmax+1,arg1f24+1
001518 C0BF F0A1  04529 	MOVFF Vmax+2,arg1f24+2
00151C C098 F0A2  04530 	MOVFF variacion,arg2f24
001520 C099 F0A3  04531 	MOVFF variacion+1,arg2f24+1
001524 C09A F0A4  04532 	MOVFF variacion+2,arg2f24+2
001528 DD87       04533 	RCALL _fsub24
00152A C09F F0BD  04534 	MOVFF arg1f24,Vmax
00152E C0A0 F0BE  04535 	MOVFF arg1f24+1,Vmax+1
001532 C0A1 F0BF  04536 	MOVFF arg1f24+2,Vmax+2
                  04537 			;					else Vmax=1.0;
001536 D005       04538 	BRA   m267
001538 0100       04539 m266	MOVLB 0
00153A 6BBD       04540 	CLRF  Vmax,1
00153C 6BBE       04541 	CLRF  Vmax+1,1
00153E 0E7F       04542 	MOVLW 127
001540 6FBF       04543 	MOVWF Vmax+2,1
                  04544 			;				}
                  04545 			;				
                  04546 			;				r= Vmax*10;
001542 C0BD F09F  04547 m267	MOVFF Vmax,arg1f24
001546 C0BE F0A0  04548 	MOVFF Vmax+1,arg1f24+1
00154A C0BF F0A1  04549 	MOVFF Vmax+2,arg1f24+2
00154E 0100       04550 	MOVLB 0
001550 6BA2       04551 	CLRF  arg2f24,1
001552 0E20       04552 	MOVLW 32
001554 6FA3       04553 	MOVWF arg2f24+1,1
001556 0E82       04554 	MOVLW 130
001558 6FA4       04555 	MOVWF arg2f24+2,1
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 77

ADDR   CODE       LINE  SOURCE

00155A EC97 F006  04556 	CALL  _fmul24
00155E DDB8       04557 	RCALL _float24ToInt24
001560 C09F F0BB  04558 	MOVFF rval_3,r
001564 C0A0 F0BC  04559 	MOVFF rval_3+1,r+1
                  04560 			;				estado = LECTURA_IAC;
001568 0E02       04561 	MOVLW 2
00156A 0100       04562 	MOVLB 0
00156C 6FC4       04563 	MOVWF estado,1
                  04564 			;				break;
00156E D6B4       04565 	BRA   m247
                  04566 			;
                  04567 			;			case LECTURA_IAC:
                  04568 			;				x=0;
001570 0100       04569 m268	MOVLB 0
001572 6B6F       04570 	CLRF  x,1
                  04571 			;				while(LATD.0==1){
001574 A08C       04572 m269	BTFSS LATD,0,0
001576 D04E       04573 	BRA   m273
                  04574 			;					if (((T == 6)&&((x==0)||(x==5))) || ((T == 12 )&&((x==1)||(x==4))) || ((T == 20)&&((x==2)||(x==3)))) {
001578 0E06       04575 	MOVLW 6
00157A 0100       04576 	MOVLB 0
00157C 63C2       04577 	CPFSEQ T,1
00157E D007       04578 	BRA   m270
001580 536F       04579 	MOVF  x,1,1
001582 B4D8       04580 	BTFSC 0xFD8,Zero_,0
001584 D019       04581 	BRA   m272
001586 516F       04582 	MOVF  x,W,1
001588 0A05       04583 	XORLW 5
00158A B4D8       04584 	BTFSC 0xFD8,Zero_,0
00158C D015       04585 	BRA   m272
00158E 0E0C       04586 m270	MOVLW 12
001590 0100       04587 	MOVLB 0
001592 63C2       04588 	CPFSEQ T,1
001594 D006       04589 	BRA   m271
001596 4D6F       04590 	DCFSNZ x,W,1
001598 D00F       04591 	BRA   m272
00159A 516F       04592 	MOVF  x,W,1
00159C 0A04       04593 	XORLW 4
00159E B4D8       04594 	BTFSC 0xFD8,Zero_,0
0015A0 D00B       04595 	BRA   m272
0015A2 0E14       04596 m271	MOVLW 20
0015A4 0100       04597 	MOVLB 0
0015A6 63C2       04598 	CPFSEQ T,1
0015A8 D7E5       04599 	BRA   m269
0015AA 516F       04600 	MOVF  x,W,1
0015AC 0A02       04601 	XORLW 2
0015AE B4D8       04602 	BTFSC 0xFD8,Zero_,0
0015B0 D003       04603 	BRA   m272
0015B2 0E03       04604 	MOVLW 3
0015B4 636F       04605 	CPFSEQ x,1
0015B6 D7DE       04606 	BRA   m269
                  04607 			;
                  04608 			;						ic=medir(LEO_IAC,10);	
0015B8 0E02       04609 m272	MOVLW 2
0015BA 0100       04610 	MOVLB 0
0015BC 6F9D       04611 	MOVWF canal,1
0015BE 0E0A       04612 	MOVLW 10
0015C0 EC26 F006  04613 	CALL  medir
0015C4 C09F F08A  04614 	MOVFF resultado,ic
0015C8 C0A0 F08B  04615 	MOVFF resultado+1,ic+1
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 78

ADDR   CODE       LINE  SOURCE

                  04616 			;						iac[x]=ic;
0015CC 6AEA       04617 	CLRF  FSR0+1,0
0015CE 90D8       04618 	BCF   0xFD8,Carry,0
0015D0 0100       04619 	MOVLB 0
0015D2 356F       04620 	RLCF  x,W,1
0015D4 0F7E       04621 	ADDLW 126
0015D6 6EE9       04622 	MOVWF FSR0,0
0015D8 C08A FFEE  04623 	MOVFF ic,POSTINC0
0015DC C08B FFEE  04624 	MOVFF ic+1,POSTINC0
                  04625 			;						x++;
0015E0 2B6F       04626 	INCF  x,1,1
                  04627 			;						
                  04628 			;						if ((T==20&&x==3)) {retardo_20u();retardo_20u();retardo_20u();retardo_20u();
0015E2 0E14       04629 	MOVLW 20
0015E4 63C2       04630 	CPFSEQ T,1
0015E6 D7C6       04631 	BRA   m269
0015E8 0E03       04632 	MOVLW 3
0015EA 636F       04633 	CPFSEQ x,1
0015EC D7C3       04634 	BRA   m269
0015EE EC9C F000  04635 	CALL  retardo_20u
0015F2 EC9C F000  04636 	CALL  retardo_20u
0015F6 EC9C F000  04637 	CALL  retardo_20u
0015FA EC9C F000  04638 	CALL  retardo_20u
                  04639 			;							retardo_20u();retardo_20u();retardo_20u();retardo_20u();retardo_20u();}
0015FE EC9C F000  04640 	CALL  retardo_20u
001602 EC9C F000  04641 	CALL  retardo_20u
001606 EC9C F000  04642 	CALL  retardo_20u
00160A EC9C F000  04643 	CALL  retardo_20u
00160E EC9C F000  04644 	CALL  retardo_20u
                  04645 			;					}		
                  04646 			;				}
001612 D7B0       04647 	BRA   m269
                  04648 			;				estado = CALCULOS_IAC;// cambiar para cacular corriente!!
001614 0E03       04649 m273	MOVLW 3
001616 0100       04650 	MOVLB 0
001618 6FC4       04651 	MOVWF estado,1
                  04652 			;				if(x<=4) estado = LECTURA_IAC;
00161A 0E05       04653 	MOVLW 5
00161C 616F       04654 	CPFSLT x,1
00161E D65C       04655 	BRA   m247
001620 0E02       04656 	MOVLW 2
001622 6FC4       04657 	MOVWF estado,1
                  04658 			;			break;
001624 D659       04659 	BRA   m247
                  04660 			;
                  04661 			;			case CALCULOS_IAC:
                  04662 			;				difMediaIC=0;
001626 0100       04663 m274	MOVLB 0
001628 6B92       04664 	CLRF  difMediaIC,1
00162A 6B93       04665 	CLRF  difMediaIC+1,1
                  04666 			;				for(p=0;p<=5;p++){
00162C 6B6D       04667 	CLRF  p,1
00162E 0E06       04668 m275	MOVLW 6
001630 0100       04669 	MOVLB 0
001632 616D       04670 	CPFSLT p,1
001634 D02F       04671 	BRA   m278
                  04672 			;					ic= iac[p];
001636 6AEA       04673 	CLRF  FSR0+1,0
001638 90D8       04674 	BCF   0xFD8,Carry,0
00163A 356D       04675 	RLCF  p,W,1
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 79

ADDR   CODE       LINE  SOURCE

00163C 0F7E       04676 	ADDLW 126
00163E 6EE9       04677 	MOVWF FSR0,0
001640 CFEE F08A  04678 	MOVFF POSTINC0,ic
001644 CFEE F08B  04679 	MOVFF POSTINC0,ic+1
                  04680 			;					rf= refIC[p];
001648 90D8       04681 	BCF   0xFD8,Carry,0
00164A 356D       04682 	RLCF  p,W,1
00164C 0F85       04683 	ADDLW 133
00164E D93A       04684 	RCALL _const1
001650 0100       04685 	MOVLB 0
001652 6F8C       04686 	MOVWF rf,1
001654 000B       04687 	TBLRD +*
001656 50F5       04688 	MOVF  TABLAT,W,0
001658 6F8D       04689 	MOVWF rf+1,1
                  04690 			;
                  04691 			;					if(ic>rf){
00165A 518A       04692 	MOVF  ic,W,1
00165C 5D8C       04693 	SUBWF rf,W,1
00165E 518B       04694 	MOVF  ic+1,W,1
001660 598D       04695 	SUBWFB rf+1,W,1
001662 B0D8       04696 	BTFSC 0xFD8,Carry,0
001664 D008       04697 	BRA   m276
                  04698 			;						dif=ic-rf;
001666 518C       04699 	MOVF  rf,W,1
001668 5D8A       04700 	SUBWF ic,W,1
00166A 6F8E       04701 	MOVWF dif,1
00166C 518D       04702 	MOVF  rf+1,W,1
00166E 598B       04703 	SUBWFB ic+1,W,1
001670 6F8F       04704 	MOVWF dif+1,1
                  04705 			;						flancoIAC=PORENCIMA;
001672 8B97       04706 	BSF   0x97,flancoIAC,1
                  04707 			;					}
                  04708 			;					else{
001674 D008       04709 	BRA   m277
                  04710 			;						dif = rf - ic;
001676 0100       04711 m276	MOVLB 0
001678 518A       04712 	MOVF  ic,W,1
00167A 5D8C       04713 	SUBWF rf,W,1
00167C 6F8E       04714 	MOVWF dif,1
00167E 518B       04715 	MOVF  ic+1,W,1
001680 598D       04716 	SUBWFB rf+1,W,1
001682 6F8F       04717 	MOVWF dif+1,1
                  04718 			;						flancoIAC=PORDEBAJO;
001684 9B97       04719 	BCF   0x97,flancoIAC,1
                  04720 			;					}
                  04721 			;					difMediaIC+=dif; 
001686 0100       04722 m277	MOVLB 0
001688 518E       04723 	MOVF  dif,W,1
00168A 2792       04724 	ADDWF difMediaIC,1,1
00168C 518F       04725 	MOVF  dif+1,W,1
00168E 2393       04726 	ADDWFC difMediaIC+1,1,1
                  04727 			;				}
001690 2B6D       04728 	INCF  p,1,1
001692 D7CD       04729 	BRA   m275
                  04730 			;				difMediaIC/=6;
001694 0100       04731 m278	MOVLB 0
001696 5192       04732 	MOVF  difMediaIC,W,1
001698 6F9E       04733 	MOVWF C45tmp,1
00169A 5193       04734 	MOVF  difMediaIC+1,W,1
00169C 6F9F       04735 	MOVWF C45tmp+1,1
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 80

ADDR   CODE       LINE  SOURCE

00169E 6BA0       04736 	CLRF  C46rem,1
0016A0 0E10       04737 	MOVLW 16
0016A2 6F9D       04738 	MOVWF C44cnt,1
0016A4 0100       04739 m279	MOVLB 0
0016A6 379E       04740 	RLCF  C45tmp,1,1
0016A8 379F       04741 	RLCF  C45tmp+1,1,1
0016AA 37A0       04742 	RLCF  C46rem,1,1
0016AC B0D8       04743 	BTFSC 0xFD8,Carry,0
0016AE D004       04744 	BRA   m280
0016B0 0E06       04745 	MOVLW 6
0016B2 5DA0       04746 	SUBWF C46rem,W,1
0016B4 A0D8       04747 	BTFSS 0xFD8,Carry,0
0016B6 D004       04748 	BRA   m281
0016B8 0E06       04749 m280	MOVLW 6
0016BA 0100       04750 	MOVLB 0
0016BC 5FA0       04751 	SUBWF C46rem,1,1
0016BE 80D8       04752 	BSF   0xFD8,Carry,0
0016C0 0100       04753 m281	MOVLB 0
0016C2 3792       04754 	RLCF  difMediaIC,1,1
0016C4 3793       04755 	RLCF  difMediaIC+1,1,1
0016C6 2F9D       04756 	DECFSZ C44cnt,1,1
0016C8 D7ED       04757 	BRA   m279
                  04758 			;			
                  04759 			;				estado = LECTURAS_VARIAS;
0016CA 0E04       04760 	MOVLW 4
0016CC 6FC4       04761 	MOVWF estado,1
                  04762 			;			break;
0016CE D604       04763 	BRA   m247
                  04764 			;																///11,5v-->700
                  04765 			;			case LECTURAS_VARIAS:								///11,8v-->728
                  04766 			;				uns16 bat = medir(LEO_BAT,10);				 	///12,0v-->730
0016D0 0E01       04767 m282	MOVLW 1
0016D2 0100       04768 	MOVLB 0
0016D4 6F9D       04769 	MOVWF canal,1
0016D6 0E0A       04770 	MOVLW 10
0016D8 EC26 F006  04771 	CALL  medir
0016DC C09F F09B  04772 	MOVFF resultado,bat
0016E0 C0A0 F09C  04773 	MOVFF resultado+1,bat+1
                  04774 			;				if (bat>785)				vbat=BATT_FULL;  	///12,3v-->763
0016E4 0E12       04775 	MOVLW 18
0016E6 0100       04776 	MOVLB 0
0016E8 5D9B       04777 	SUBWF bat,W,1
0016EA 0E03       04778 	MOVLW 3
0016EC 599C       04779 	SUBWFB bat+1,W,1
0016EE A0D8       04780 	BTFSS 0xFD8,Carry,0
0016F0 D003       04781 	BRA   m283
0016F2 0E01       04782 	MOVLW 1
0016F4 6F94       04783 	MOVWF vbat,1
                  04784 			;				else if((bat>762&&bat<775))	vbat=BATT_75;		///12,5v-->774
0016F6 D058       04785 	BRA   m290
0016F8 0EFB       04786 m283	MOVLW 251
0016FA 0100       04787 	MOVLB 0
0016FC 5D9B       04788 	SUBWF bat,W,1
0016FE 0E02       04789 	MOVLW 2
001700 599C       04790 	SUBWFB bat+1,W,1
001702 A0D8       04791 	BTFSS 0xFD8,Carry,0
001704 D009       04792 	BRA   m284
001706 0E07       04793 	MOVLW 7
001708 5D9B       04794 	SUBWF bat,W,1
00170A 0E03       04795 	MOVLW 3
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 81

ADDR   CODE       LINE  SOURCE

00170C 599C       04796 	SUBWFB bat+1,W,1
00170E B0D8       04797 	BTFSC 0xFD8,Carry,0
001710 D003       04798 	BRA   m284
001712 0E02       04799 	MOVLW 2
001714 6F94       04800 	MOVWF vbat,1
                  04801 			;				else if((bat>742&&bat<760)) vbat=BATT_50;		///12,8v-->794
001716 D048       04802 	BRA   m290
001718 0EE7       04803 m284	MOVLW 231
00171A 0100       04804 	MOVLB 0
00171C 5D9B       04805 	SUBWF bat,W,1
00171E 0E02       04806 	MOVLW 2
001720 599C       04807 	SUBWFB bat+1,W,1
001722 A0D8       04808 	BTFSS 0xFD8,Carry,0
001724 D009       04809 	BRA   m285
001726 0EF8       04810 	MOVLW 248
001728 5D9B       04811 	SUBWF bat,W,1
00172A 0E02       04812 	MOVLW 2
00172C 599C       04813 	SUBWFB bat+1,W,1
00172E B0D8       04814 	BTFSC 0xFD8,Carry,0
001730 D003       04815 	BRA   m285
001732 0E03       04816 	MOVLW 3
001734 6F94       04817 	MOVWF vbat,1
                  04818 			;				else if((bat>722&&bat<740)) vbat=BATT_25;		///13,0v-->804
001736 D038       04819 	BRA   m290
001738 0ED3       04820 m285	MOVLW 211
00173A 0100       04821 	MOVLB 0
00173C 5D9B       04822 	SUBWF bat,W,1
00173E 0E02       04823 	MOVLW 2
001740 599C       04824 	SUBWFB bat+1,W,1
001742 A0D8       04825 	BTFSS 0xFD8,Carry,0
001744 D009       04826 	BRA   m286
001746 0EE4       04827 	MOVLW 228
001748 5D9B       04828 	SUBWF bat,W,1
00174A 0E02       04829 	MOVLW 2
00174C 599C       04830 	SUBWFB bat+1,W,1
00174E B0D8       04831 	BTFSC 0xFD8,Carry,0
001750 D003       04832 	BRA   m286
001752 0E04       04833 	MOVLW 4
001754 6F94       04834 	MOVWF vbat,1
                  04835 			;				else if((bat>710&&bat<720)) vbat=BATT_10;		///13,5v-->837
001756 D028       04836 	BRA   m290
001758 0EC7       04837 m286	MOVLW 199
00175A 0100       04838 	MOVLB 0
00175C 5D9B       04839 	SUBWF bat,W,1
00175E 0E02       04840 	MOVLW 2
001760 599C       04841 	SUBWFB bat+1,W,1
001762 A0D8       04842 	BTFSS 0xFD8,Carry,0
001764 D009       04843 	BRA   m287
001766 0ED0       04844 	MOVLW 208
001768 5D9B       04845 	SUBWF bat,W,1
00176A 0E02       04846 	MOVLW 2
00176C 599C       04847 	SUBWFB bat+1,W,1
00176E B0D8       04848 	BTFSC 0xFD8,Carry,0
001770 D003       04849 	BRA   m287
001772 0E05       04850 	MOVLW 5
001774 6F94       04851 	MOVWF vbat,1
                  04852 			;				else if(bat<=708){								///14,0v-->872
001776 D018       04853 	BRA   m290
001778 0EC5       04854 m287	MOVLW 197
00177A 0100       04855 	MOVLB 0
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 82

ADDR   CODE       LINE  SOURCE

00177C 5D9B       04856 	SUBWF bat,W,1
00177E 0E02       04857 	MOVLW 2
001780 599C       04858 	SUBWFB bat+1,W,1
001782 B0D8       04859 	BTFSC 0xFD8,Carry,0
001784 D011       04860 	BRA   m290
                  04861 			;					o++;										///14,5v-->895
001786 2B95       04862 	INCF  o,1,1
                  04863 			;					if(o<=5)vbat=BATT_LW;						///15,0v-->946
001788 0E06       04864 	MOVLW 6
00178A 6195       04865 	CPFSLT o,1
00178C D002       04866 	BRA   m288
00178E 0E06       04867 	MOVLW 6
001790 6F94       04868 	MOVWF vbat,1
                  04869 			;					if(o>6)vbat=BATT_CLEAR;
001792 0E06       04870 m288	MOVLW 6
001794 0100       04871 	MOVLB 0
001796 6595       04872 	CPFSGT o,1
001798 D002       04873 	BRA   m289
00179A 0E07       04874 	MOVLW 7
00179C 6F94       04875 	MOVWF vbat,1
                  04876 			;					if(o==10)o=0;
00179E 0E0A       04877 m289	MOVLW 10
0017A0 0100       04878 	MOVLB 0
0017A2 6395       04879 	CPFSEQ o,1
0017A4 D001       04880 	BRA   m290
0017A6 6B95       04881 	CLRF  o,1
                  04882 			;				} 			
                  04883 			;				estado= ENVIO_LCD;
0017A8 0E05       04884 m290	MOVLW 5
0017AA 0100       04885 	MOVLB 0
0017AC 6FC4       04886 	MOVWF estado,1
                  04887 			;			break;
0017AE D594       04888 	BRA   m247
                  04889 			;
                  04890 			;			case ENVIO_LCD:
                  04891 			;
                  04892 			;				if(vuelta){
0017B0 0100       04893 m291	MOVLB 0
0017B2 A797       04894 	BTFSS 0x97,vuelta,1
0017B4 D02C       04895 	BRA   m292
                  04896 			;
                  04897 			;					Enviar_uns16(3,1,vac[3]);
0017B6 0E03       04898 	MOVLW 3
0017B8 6F9F       04899 	MOVWF linea_4,1
0017BA 0E01       04900 	MOVLW 1
0017BC 6FA0       04901 	MOVWF columna_3,1
0017BE C076 F0A1  04902 	MOVFF vac+6,dato_4
0017C2 C077 F0A2  04903 	MOVFF vac+7,dato_4+1
0017C6 ECD9 F003  04904 	CALL  Enviar_uns16
                  04905 			;					Enviar_uns16(3,6,vac[4]);
0017CA 0E03       04906 	MOVLW 3
0017CC 0100       04907 	MOVLB 0
0017CE 6F9F       04908 	MOVWF linea_4,1
0017D0 0E06       04909 	MOVLW 6
0017D2 6FA0       04910 	MOVWF columna_3,1
0017D4 C078 F0A1  04911 	MOVFF vac+8,dato_4
0017D8 C079 F0A2  04912 	MOVFF vac+9,dato_4+1
0017DC ECD9 F003  04913 	CALL  Enviar_uns16
                  04914 			;					Enviar_uns16(3,11,vac[5]);
0017E0 0E03       04915 	MOVLW 3
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 83

ADDR   CODE       LINE  SOURCE

0017E2 0100       04916 	MOVLB 0
0017E4 6F9F       04917 	MOVWF linea_4,1
0017E6 0E0B       04918 	MOVLW 11
0017E8 6FA0       04919 	MOVWF columna_3,1
0017EA C07A F0A1  04920 	MOVFF vac+10,dato_4
0017EE C07B F0A2  04921 	MOVFF vac+11,dato_4+1
0017F2 ECD9 F003  04922 	CALL  Enviar_uns16
                  04923 			;					Enviar_uns16(4,16, difMediaAC);
0017F6 0E04       04924 	MOVLW 4
0017F8 0100       04925 	MOVLB 0
0017FA 6F9F       04926 	MOVWF linea_4,1
0017FC 0E10       04927 	MOVLW 16
0017FE 6FA0       04928 	MOVWF columna_3,1
001800 C090 F0A1  04929 	MOVFF difMediaAC,dato_4
001804 C091 F0A2  04930 	MOVFF difMediaAC+1,dato_4+1
001808 ECD9 F003  04931 	CALL  Enviar_uns16
                  04932 			;	/*				//escribir_posicion(4,6);
                  04933 			;					uns16 g =Vmax*10;
                  04934 			;					Enviar_uns16(4,6,g);
                  04935 			;					Enviar_uns16(3,4,iac[h]);
                  04936 			;					Enviar_uns16(3,9,iac[h+1]);
                  04937 			;					Enviar_uns16(3,14, difMediaIC);
                  04938 			;					escribir_posicion(3,20);
                  04939 			;					enviar_cifra(flancoIAC);
                  04940 			;					h++;
                  04941 			;					if(h==6)h=0;	
                  04942 			;	*/				
                  04943 			;				}
                  04944 			;				else{
00180C D03F       04945 	BRA   m293
                  04946 			;					uns16 g =Vmax*10;
00180E C0BD F09F  04947 m292	MOVFF Vmax,arg1f24
001812 C0BE F0A0  04948 	MOVFF Vmax+1,arg1f24+1
001816 C0BF F0A1  04949 	MOVFF Vmax+2,arg1f24+2
00181A 0100       04950 	MOVLB 0
00181C 6BA2       04951 	CLRF  arg2f24,1
00181E 0E20       04952 	MOVLW 32
001820 6FA3       04953 	MOVWF arg2f24+1,1
001822 0E82       04954 	MOVLW 130
001824 6FA4       04955 	MOVWF arg2f24+2,1
001826 EC97 F006  04956 	CALL  _fmul24
00182A DC52       04957 	RCALL _float24ToInt24
00182C C09F F09D  04958 	MOVFF rval_3,g
001830 C0A0 F09E  04959 	MOVFF rval_3+1,g+1
                  04960 			;					Enviar_uns16(4,6,g);
001834 0E04       04961 	MOVLW 4
001836 0100       04962 	MOVLB 0
001838 6F9F       04963 	MOVWF linea_4,1
00183A 0E06       04964 	MOVLW 6
00183C 6FA0       04965 	MOVWF columna_3,1
00183E C09D F0A1  04966 	MOVFF g,dato_4
001842 C09E F0A2  04967 	MOVFF g+1,dato_4+1
001846 ECD9 F003  04968 	CALL  Enviar_uns16
                  04969 			;					Enviar_uns16(2,1,vac[0]);
00184A 0E02       04970 	MOVLW 2
00184C 0100       04971 	MOVLB 0
00184E 6F9F       04972 	MOVWF linea_4,1
001850 0E01       04973 	MOVLW 1
001852 6FA0       04974 	MOVWF columna_3,1
001854 C070 F0A1  04975 	MOVFF vac,dato_4
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 84

ADDR   CODE       LINE  SOURCE

001858 C071 F0A2  04976 	MOVFF vac+1,dato_4+1
00185C ECD9 F003  04977 	CALL  Enviar_uns16
                  04978 			;					Enviar_uns16(2,6,vac[1]);
001860 0E02       04979 	MOVLW 2
001862 0100       04980 	MOVLB 0
001864 6F9F       04981 	MOVWF linea_4,1
001866 0E06       04982 	MOVLW 6
001868 6FA0       04983 	MOVWF columna_3,1
00186A C072 F0A1  04984 	MOVFF vac+2,dato_4
00186E C073 F0A2  04985 	MOVFF vac+3,dato_4+1
001872 ECD9 F003  04986 	CALL  Enviar_uns16
                  04987 			;					Enviar_uns16(2,11,vac[2]);
001876 0E02       04988 	MOVLW 2
001878 0100       04989 	MOVLB 0
00187A 6F9F       04990 	MOVWF linea_4,1
00187C 0E0B       04991 	MOVLW 11
00187E 6FA0       04992 	MOVWF columna_3,1
001880 C074 F0A1  04993 	MOVFF vac+4,dato_4
001884 C075 F0A2  04994 	MOVFF vac+5,dato_4+1
001888 ECD9 F003  04995 	CALL  Enviar_uns16
                  04996 			;					//Enviar_uns16(3,1,vac[3]);
                  04997 			;					
                  04998 			;	/*				
                  04999 			;					escribir_posicion(4,20);
                  05000 			;					enviar_literal(vbat);
                  05001 			;					uns16 j = sen[26]*r;
                  05002 			;					Enviar_uns16(4,14,j);
                  05003 			;					Enviar_uns16(2,4,vac[h]);
                  05004 			;					Enviar_uns16(2,9,vac[h+1]);
                  05005 			;					Enviar_uns16(2,14, difMediaAC);
                  05006 			;					escribir_posicion(2,20);
                  05007 			;					enviar_cifra(flancoVAC);
                  05008 			;	*/			}
                  05009 			;				vuelta^=1;
00188C 0100       05010 m293	MOVLB 0
00188E 7797       05011 	BTG   0x97,vuelta,1
                  05012 			;				estado = LECTURA_VAC;
001890 6BC4       05013 	CLRF  estado,1
                  05014 			;			break;
001892 D522       05015 	BRA   m247
                  05016 			;
                  05017 			;		}
                  05018 			;	}	
                  05019 			;}
                  05020 			;
                  05021 			;//=============================================================================================================
                  05022 			;			
                  05023 			;void configuraPic (void)					
                  05024 			;{
                  05025 configuraPic
                  05026 			;
                  05027 			;	OSCTUNE=0b.01.000000; //PLL enable 
001894 0E40       05028 	MOVLW 64
001896 6E9B       05029 	MOVWF OSCTUNE,0
                  05030 			;	
                  05031 			;	RCON = 0b.01111111; //C18 pag 80 i 167  Causes del RESET i IPEN (priority Enabled o no)
001898 0E7F       05032 	MOVLW 127
00189A 6ED0       05033 	MOVWF RCON,0
                  05034 			;	OSCCON    = 0b.0.111.0.0.00;//C18 pag 53  //=============== ULL b3 abans 0 
00189C 0E70       05035 	MOVLW 112
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 85

ADDR   CODE       LINE  SOURCE

00189E 6ED3       05036 	MOVWF OSCCON,0
                  05037 			;	
                  05038 			;	ANSEL  = 0b.0000.0111;					// Solo el canal AN0 ser√° entrada anal√≥gica, el resto ser√°n entradas/salidas digitales.(PIC 8
                           16F87)
0018A0 0E07       05039 	MOVLW 7
0018A2 6E7E       05040 	MOVWF ANSEL,0
                  05041 			;	//ANSELH = 0b.0000.0000;					// Solo el canal AN0 ser√° entrada anal√≥gica, el resto ser√°n entradas/salidas digitale
                           s.(PIC 816F87)
                  05042 			;	
                  05043 			;	TRISA  = 0b.0000.1111;					// PORTA.0 es entrada, el resto son salidas.
0018A4 0E0F       05044 	MOVLW 15
0018A6 6E92       05045 	MOVWF TRISA,0
                  05046 			;	TRISB  = 0b.0000.0000;					// PORTB todo salidas.
0018A8 6A93       05047 	CLRF  TRISB,0
                  05048 			;	TRISC  = 0b.0000.0000;					// PORTC todo salidas adem√°s de la salida del PWM.
0018AA 6A94       05049 	CLRF  TRISC,0
                  05050 			;	TRISD  = 0b.0000.0000;					// PORTD todo salidas.				
0018AC 6A95       05051 	CLRF  TRISD,0
                  05052 			;	LATB  = 0x00;							// Inicializa las salidas de PORTB a 0.
0018AE 6A8A       05053 	CLRF  LATB,0
                  05054 			;	PORTC  = 0x00;							// Inicializa las salidas de PORTC a 0.
0018B0 6A82       05055 	CLRF  PORTC,0
                  05056 			;	PORTD  = 0x00;							// Inicializa las salidas de PORTD a 0.
0018B2 6A83       05057 	CLRF  PORTD,0
                  05058 			;
                  05059 			;	//configuro ccp y pwm
                  05060 			;
                  05061 			;
                  05062 			;	T2CON   = 0b.0.0001.0.01;				// Prescaler P1 = 4, TMR2ON = 1 cuenta;	
0018B4 0E09       05063 	MOVLW 9
0018B6 6ECA       05064 	MOVWF T2CON,0
                  05065 			;	PR2     = 199;
0018B8 0EC7       05066 	MOVLW 199
0018BA 6ECB       05067 	MOVWF PR2,0
                  05068 			;	CCP1CON = 0b.1000.1100;					// CCP1: modo PWM half bridge con bits de CCPR1L a 00 inicialmente.
0018BC 0E8C       05069 	MOVLW 140
0018BE 6EBD       05070 	MOVWF CCP1CON,0
                  05071 			;
                  05072 			;	PWM1CON =0b.0000.0000; //tiempo muerto entre P1A y P1B
0018C0 6AB7       05073 	CLRF  PWM1CON,0
0018C2 0012       05074 	RETURN
                  05075 _const1
0018C4 0100       05076 	MOVLB 0
0018C6 6F69       05077 	MOVWF ci,1
0018C8 5169       05078 	MOVF  ci,W,1
0018CA 0FDC       05079 	ADDLW 220
0018CC 6EF6       05080 	MOVWF TBLPTR,0
0018CE 0E18       05081 	MOVLW 24
0018D0 6AF7       05082 	CLRF  TBLPTR+1,0
0018D2 22F7       05083 	ADDWFC TBLPTR+1,1,0
0018D4 6AF8       05084 	CLRF  TBLPTR+2,0
0018D6 0008       05085 	TBLRD *
0018D8 50F5       05086 	MOVF  TABLAT,W,0
0018DA 0012       05087 	RETURN
0018DC 0800       05088 	DW    0x800
0018DE 1710       05089 	DW    0x1710
0018E0 271F       05090 	DW    0x271F
0018E2 362F       05091 	DW    0x362F
0018E4 443D       05092 	DW    0x443D
0018E6 514B       05093 	DW    0x514B
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 86

ADDR   CODE       LINE  SOURCE

0018E8 5D57       05094 	DW    0x5D57
0018EA 6762       05095 	DW    0x6762
0018EC 706C       05096 	DW    0x706C
0018EE 7773       05097 	DW    0x7773
0018F0 7B79       05098 	DW    0x7B79
0018F2 7E7D       05099 	DW    0x7E7D
0018F4 807F       05100 	DW    0x807F
0018F6 100C       05101 	DW    0x100C
0018F8 0408       05102 	DW    0x408
0018FA 041B       05103 	DW    0x41B
0018FC 0304       05104 	DW    0x304
0018FE FFEE       05105 	DW    0xFFEE
001900 FFFF       05106 	DW    0xFFFF
001902 FFFF       05107 	DW    0xFFFF
001904 FFFF       05108 	DW    0xFFFF
001906 FFEE       05109 	DW    0xFFEE
001908 FFF1       05110 	DW    0xFFF1
00190A FFFF       05111 	DW    0xFFFF
00190C FFFF       05112 	DW    0xFFFF
00190E FFEE       05113 	DW    0xFFEE
001910 F1F1       05114 	DW    0xF1F1
001912 FFFF       05115 	DW    0xFFFF
001914 FFFF       05116 	DW    0xFFFF
001916 FFEE       05117 	DW    0xFFEE
001918 F1F1       05118 	DW    0xF1F1
00191A FFF1       05119 	DW    0xFFF1
00191C FFFF       05120 	DW    0xFFFF
00191E FFEE       05121 	DW    0xFFEE
001920 F1F1       05122 	DW    0xF1F1
001922 F1F1       05123 	DW    0xF1F1
001924 FFFF       05124 	DW    0xFFFF
001926 FFEE       05125 	DW    0xFFEE
001928 F1F1       05126 	DW    0xF1F1
00192A F1F1       05127 	DW    0xF1F1
00192C FFF1       05128 	DW    0xFFF1
00192E 0000       05129 	DW    0x0
001930 0000       05130 	DW    0x0
001932 0000       05131 	DW    0x0
001934 0000       05132 	DW    0x0
001936 4E4F       05133 	DW    0x4E4F
001938 5544       05134 	DW    0x5544
00193A 414C       05135 	DW    0x414C
00193C 4F44       05136 	DW    0x4F44
00193E 2052       05137 	DW    0x2052
001940 3035       05138 	DW    0x3035
001942 5A48       05139 	DW    0x5A48
001944 2020       05140 	DW    0x2020
001946 7962       05141 	DW    0x7962
001948 5620       05142 	DW    0x5620
00194A 4341       05143 	DW    0x4341
00194C 4D56       05144 	DW    0x4D56
00194E 5841       05145 	DW    0x5841
001950 443A       05146 	DW    0x443A
001952 4649       05147 	DW    0x4649
001954 3746       05148 	DW    0x3746
001956 7002       05149 	DW    0x7002
001958 D502       05150 	DW    0xD502
00195A 0D02       05151 	DW    0xD02
00195C E003       05152 	DW    0xE003
00195E 3102       05153 	DW    0x3102
CC8E Version 1.4,   File: ondulador_float.c   15. May 2015  20:58   Page 87

ADDR   CODE       LINE  SOURCE

001960 5802       05154 	DW    0x5802
001962 EE02       05155 	DW    0xEE02
001964 8402       05156 	DW    0x8402
001966 8403       05157 	DW    0x8403
001968 EE03       05158 	DW    0xEE03
00196A 5802       05159 	DW    0x5802
00196C 0002       05160 	DW    0x2
                  05161 
                  05162 	END
                  05163 
                  05164 
                  05165 ; *** KEY INFO ***
                  05166 
                  05167 ; 0x000008  152 word(s)  1 % : highPriorityTimer_0
                  05168 ; 0x0018C4   85 word(s)  1 % : _const1
                  05169 ; 0x000138   10 word(s)  0 % : retardo_20u
                  05170 ; 0x00014C   19 word(s)  0 % : retardo_1m
                  05171 ; 0x000172   20 word(s)  0 % : retardo_50m
                  05172 ; 0x00019A   18 word(s)  0 % : retardo_100m
                  05173 ; 0x0001BE   20 word(s)  0 % : retardo_500m
                  05174 ; 0x001894   24 word(s)  0 % : configuraPic
                  05175 ; 0x0001E6   28 word(s)  0 % : envia_codigo_inicial
                  05176 ; 0x00021E   59 word(s)  0 % : enviar_comando
                  05177 ; 0x000294   79 word(s)  0 % : enviar_literal
                  05178 ; 0x000332   72 word(s)  0 % : enviar_cifra
                  05179 ; 0x0003C2   59 word(s)  0 % : inicializar_lcd
                  05180 ; 0x000438   39 word(s)  0 % : escribir_posicion
                  05181 ; 0x000486   37 word(s)  0 % : borrar_linea
                  05182 ; 0x0004D0    2 word(s)  0 % : borrar_lcd
                  05183 ; 0x0004D4  367 word(s)  4 % : Enviar_lcd
                  05184 ; 0x0007B2  429 word(s)  5 % : Enviar_uns16
                  05185 ; 0x000B0C  160 word(s)  1 % : RAM_LCD
                  05186 ; 0x000C4C  113 word(s)  1 % : medir
                  05187 ; 0x000D2E  100 word(s)  1 % : _fmul24
                  05188 ; 0x000DF6  122 word(s)  1 % : _fdiv24
                  05189 ; 0x000EEA  167 word(s)  2 % : _fadd24
                  05190 ; 0x001038    7 word(s)  0 % : _fsub24
                  05191 ; 0x001046   69 word(s)  0 % : _int24ToFloat24
                  05192 ; 0x0010D0   85 word(s)  1 % : _float24ToInt24
                  05193 ; 0x00117A  909 word(s) 11 % : main
                  05194 
                  05195 ; RAM usage: 102 bytes (88 local), 666 bytes free
                  05196 ; Maximum call level: 3 (+2 for interrupt)
                  05197 ; Total of 3253 code words (39 %)
