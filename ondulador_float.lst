CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 1

ADDR   CODE       LINE  SOURCE

                  00001 
                  00002 ; CC8E Version 1.4, Copyright (c) B Knudsen Data
                  00003 ; C compiler for the PIC18 microcontrollers
                  00004 ; ************  21. May 2015  17:38  *************
                  00005 
                  00006 	processor  PIC18F44K20
                  00007 	radix  DEC
                  00008 
300000 08FF       00009 	__config 0x300001, 0x8
                  00010 	__config 0x300002, 0x1
300002 1601       00011 	__config 0x300003, 0x16
300004 88FF       00012 	__config 0x300005, 0x88
300006 FF81       00013 	__config 0x300006, 0x81
                  00014 
       0FF6       00015 TBLPTR      EQU   0xFF6
       0FF5       00016 TABLAT      EQU   0xFF5
       0FF4       00017 PRODH       EQU   0xFF4
       0FF3       00018 PRODL       EQU   0xFF3
       0FF2       00019 INTCON      EQU   0xFF2
       0FF1       00020 INTCON2     EQU   0xFF1
       0FEF       00021 INDF0       EQU   0xFEF
       0FE9       00022 FSR0        EQU   0xFE9
       0FE0       00023 BSR         EQU   0xFE0
       0FD8       00024 STATUS      EQU   0xFD8
       0000       00025 Carry       EQU   0
       0002       00026 Zero_       EQU   2
       0FD5       00027 T0CON       EQU   0xFD5
       0FD3       00028 OSCCON      EQU   0xFD3
       0FD0       00029 RCON        EQU   0xFD0
       0FCB       00030 PR2         EQU   0xFCB
       0FCA       00031 T2CON       EQU   0xFCA
       0FC4       00032 ADRESH      EQU   0xFC4
       0FC3       00033 ADRESL      EQU   0xFC3
       0FC2       00034 ADCON0      EQU   0xFC2
       0FC1       00035 ADCON1      EQU   0xFC1
       0FC0       00036 ADCON2      EQU   0xFC0
       0FBE       00037 CCPR1L      EQU   0xFBE
       0FBD       00038 CCP1CON     EQU   0xFBD
       0FB7       00039 PWM1CON     EQU   0xFB7
       0F9B       00040 OSCTUNE     EQU   0xF9B
       0F95       00041 TRISD       EQU   0xF95
       0F94       00042 TRISC       EQU   0xF94
       0F93       00043 TRISB       EQU   0xF93
       0F92       00044 TRISA       EQU   0xF92
       0F8C       00045 LATD        EQU   0xF8C
       0F8A       00046 LATB        EQU   0xF8A
       0F83       00047 PORTD       EQU   0xF83
       0F82       00048 PORTC       EQU   0xF82
       0F81       00049 PORTB       EQU   0xF81
       0F7E       00050 ANSEL       EQU   0xF7E
       0002       00051 TMR0IF      EQU   2
       0007       00052 GIE         EQU   7
       0002       00053 TMR2ON      EQU   2
       0001       00054 GO          EQU   1
       0007       00055 ADFM        EQU   7
       0001       00056 TMR2IF      EQU   1
       0001       00057 TMR2IE      EQU   1
       0000       00058 bUdw        EQU   0
       00CC       00059 ancho_pwm   EQU   0xCC
       00CE       00060 r           EQU   0xCE
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 2

ADDR   CODE       LINE  SOURCE

       00D0       00061 Vmax        EQU   0xD0
       00D3       00062 SENO        EQU   0xD3
       00D5       00063 T           EQU   0xD5
       00D6       00064 i           EQU   0xD6
       00D7       00065 estado      EQU   0xD7
       0060       00066 svrSTATUS   EQU   0x60
       0061       00067 svrBSR      EQU   0x61
       0062       00068 svrWREG     EQU   0x62
       0063       00069 sv_PRODL    EQU   0x63
       0064       00070 sv_PRODH    EQU   0x64
       0065       00071 sv_TBLPTR   EQU   0x65
       0068       00072 sv_TABLAT   EQU   0x68
       0069       00073 C3cnt       EQU   0x69
       006A       00074 C4tmp       EQU   0x6A
       006C       00075 C5rem       EQU   0x6C
       00D8       00076 FpFlags     EQU   0xD8
       0001       00077 FpOverflow  EQU   1
       0002       00078 FpUnderFlow EQU   2
       0005       00079 FpDomainError EQU   5
       0006       00080 FpRounding  EQU   6
       00B0       00081 arg1f24     EQU   0xB0
       00B3       00082 arg2f24     EQU   0xB3
       00BB       00083 aarg        EQU   0xBB
       00BD       00084 sign        EQU   0xBD
       00BE       00085 tmpL        EQU   0xBE
       00BB       00086 xtra        EQU   0xBB
       00BC       00087 temp        EQU   0xBC
       00BD       00088 expo        EQU   0xBD
       00BE       00089 sign_3      EQU   0xBE
       00B6       00090 expo_2      EQU   0xB6
       00B7       00091 xtra_2      EQU   0xB7
       00B8       00092 sign_4      EQU   0xB8
       00B0       00093 rval        EQU   0xB0
       00B6       00094 sign_6      EQU   0xB6
       00B7       00095 expo_4      EQU   0xB7
       00B8       00096 xtra_4      EQU   0xB8
       00B0       00097 rval_3      EQU   0xB0
       00C4       00098 arg1        EQU   0xC4
       00C6       00099 arg2        EQU   0xC6
       00C7       00100 rm          EQU   0xC7
       00C8       00101 counter_2   EQU   0xC8
       00C9       00102 tmp         EQU   0xC9
       00C4       00103 arg1_2      EQU   0xC4
       00C6       00104 arg2_2      EQU   0xC6
       00C8       00105 rm_2        EQU   0xC8
       00CA       00106 counter_3   EQU   0xCA
       00C4       00107 arg1_5      EQU   0xC4
       00C6       00108 arg2_5      EQU   0xC6
       00C7       00109 rm_5        EQU   0xC7
       00C8       00110 counter_6   EQU   0xC8
       00C9       00111 tmp_2       EQU   0xC9
       00C4       00112 arg1_6      EQU   0xC4
       00C6       00113 arg2_6      EQU   0xC6
       00C8       00114 rm_6        EQU   0xC8
       00CA       00115 counter_7   EQU   0xCA
       00B6       00116 cexp        EQU   0xB6
       00B7       00117 savedFLAGS  EQU   0xB7
       00B8       00118 d_5         EQU   0xB8
       00C5       00119 PDel0       EQU   0xC5
       00C5       00120 PDel0_2     EQU   0xC5
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 3

ADDR   CODE       LINE  SOURCE

       00C6       00121 PDel1       EQU   0xC6
       0F7F       00122 PDel0_3     EQU   0xF7F
       0F7F       00123 PDel1_2     EQU   0xF7F
       0F7F       00124 PDel2       EQU   0xF7F
       0F7F       00125 PDel0_4     EQU   0xF7F
       0F7F       00126 PDel1_3     EQU   0xF7F
       0F7F       00127 PDel2_2     EQU   0xF7F
       0F7F       00128 PDel0_5     EQU   0xF7F
       0F7F       00129 PDel1_4     EQU   0xF7F
       0F7F       00130 PDel2_3     EQU   0xF7F
       00A8       00131 codigo      EQU   0xA8
       00C4       00132 comando     EQU   0xC4
       00A8       00133 dato        EQU   0xA8
       00A9       00134 i_3         EQU   0xA9
       0F7F       00135 dato_2      EQU   0xF7F
       0F7F       00136 i_4         EQU   0xF7F
       00A7       00137 i_5         EQU   0xA7
       00A7       00138 linea       EQU   0xA7
       00A8       00139 columna     EQU   0xA8
       0F7F       00140 linea_2     EQU   0xF7F
       0F7F       00141 i_6         EQU   0xF7F
       0F7F       00142 linea_3     EQU   0xF7F
       0F7F       00143 columna_2   EQU   0xF7F
       0F7F       00144 dato_3      EQU   0xF7F
       0000       00145 bd          EQU   0
       0000       00146 dp          EQU   0
       0000       00147 xi          EQU   0
       0000       00148 ndp         EQU   0
       0F7F       00149 num         EQU   0xF7F
       0F7F       00150 u_milers    EQU   0xF7F
       0F7F       00151 cent        EQU   0xF7F
       0F7F       00152 dec         EQU   0xF7F
       0F7F       00153 unid        EQU   0xF7F
       0F7F       00154 resto1      EQU   0xF7F
       0F7F       00155 i_7         EQU   0xF7F
       0F7F       00156 xx          EQU   0xF7F
       0F7F       00157 dat         EQU   0xF7F
       0F7F       00158 xy          EQU   0xF7F
       00B0       00159 linea_4     EQU   0xB0
       00B1       00160 columna_3   EQU   0xB1
       00B2       00161 dato_4      EQU   0xB2
       00B4       00162 num_2       EQU   0xB4
       00B6       00163 u_milers_2  EQU   0xB6
       00B8       00164 cent_2      EQU   0xB8
       00BA       00165 d_milers    EQU   0xBA
       00BC       00166 dec_2       EQU   0xBC
       00BD       00167 unid_2      EQU   0xBD
       00BE       00168 resto1_2    EQU   0xBE
       00BF       00169 i_8         EQU   0xBF
       00C0       00170 xx_2        EQU   0xC0
       00C2       00171 dat_2       EQU   0xC2
       00B0       00172 linea_5     EQU   0xB0
       00B1       00173 columna_4   EQU   0xB1
       00B2       00174 dato_5      EQU   0xB2
       00B4       00175 cent_3      EQU   0xB4
       00B5       00176 dec_3       EQU   0xB5
       00B6       00177 unid_3      EQU   0xB6
       00B7       00178 resto1_3    EQU   0xB7
       00B8       00179 i_9         EQU   0xB8
       00B9       00180 xx_3        EQU   0xB9
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 4

ADDR   CODE       LINE  SOURCE

       00BB       00181 dat_3       EQU   0xBB
       00A7       00182 i_10        EQU   0xA7
       00AC       00183 canal       EQU   0xAC
       00AD       00184 bits        EQU   0xAD
       00AE       00185 resultado   EQU   0xAE
       006D       00186 p           EQU   0x6D
       006E       00187 h           EQU   0x6E
       006F       00188 x           EQU   0x6F
       0070       00189 vac         EQU   0x70
       0080       00190 ac          EQU   0x80
       0091       00191 ic          EQU   0x91
       0092       00192 vbat        EQU   0x92
       0093       00193 o           EQU   0x93
       0094       00194 vuelta      EQU   0x94
       0000       00195 lectura     EQU   0
       0095       00196 raiz        EQU   0x95
       009B       00197 Mac0        EQU   0x9B
       009D       00198 Mac1        EQU   0x9D
       009F       00199 q           EQU   0x9F
       00A1       00200 a           EQU   0xA1
       00A3       00201 ProbaVmax   EQU   0xA3
       00AC       00202 d_6         EQU   0xAC
       00A7       00203 banda       EQU   0xA7
       00AA       00204 bat         EQU   0xAA
       00AC       00205 w           EQU   0xAC
       00AE       00206 v           EQU   0xAE
       0069       00207 ci          EQU   0x69
                  00208 
000000 EF7B F009  00209 	GOTO main
                  00210 
                  00211   ; FILE ondulador_float.c
                  00212 			;/*
                  00213 			; * Autor: J_Sanchez
                  00214 			; * 
                  00215 			; * Fecha: 31-03-2015
                  00216 			; * Descripcion:Primera prueba con el 18F44K20 para el proyecto del ondulador v2.0
                  00217 			; *  Configuracion: 
                  00218 			; *		Modelo: 18F44K20
                  00219 			; *		Oscilador: Crystal 64Mhz
                  00220 			; *		Puente en H con PWM mejorado
                  00221 			; */
                  00222 			;
                  00223 			; //**************************************************************************************//
                  00224 			; //******************* C O N F I G  U R A C I O N    I N I C I A L  *********************//
                  00225 			; //**************************************************************************************//
                  00226 			; 
                  00227 			; #pragma chip PIC18F44K20
                  00228 			; #pragma config[1] = 0b.0000.1000//pagina 301 datasheet
                  00229 			; #pragma config[2] = 0b.0000.0001
                  00230 			; #pragma config[3] = 0b.0001.0110
                  00231 			; #pragma config[5] = 0b.1000.1000//Mirar CCP2 MUX bit 0 
                  00232 			; 				//-->1 = CCP2 input/output is multiplexed with RC1
                  00233 			;				//   -->0 = CCP2 input/output is multiplexed with RB3 
                  00234 			; #pragma config[6] = 0b.1000.0001
                  00235 			; // resto configs son para la proteccion del programa 
                  00236 			;
                  00237 			; #pragma sharedAllocation//evita error en las interrupciones
                  00238 			;
                  00239 			; //**************************************************************************************//
                  00240 			; //************************************  M A C R O S ************************************//
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 5

ADDR   CODE       LINE  SOURCE

                  00241 			; //**************************************************************************************//
                  00242 			;
                  00243 			;#define PORDEBAJO 0
                  00244 			;#define PORENCIMA 1
                  00245 			;//estados
                  00246 			;#define LECTURA_VAC  0
                  00247 			;#define CALCULOS_VAC 1
                  00248 			;#define CALCULOS_IAC 2
                  00249 			;#define LECTURAS_VARIAS 3
                  00250 			;#define ENVIO_LCD    4
                  00251 			;//lectura adc
                  00252 			;#define LEO_VAC		 0
                  00253 			;#define LEO_BAT		 1
                  00254 			;#define LEO_IAC		 2
                  00255 			;//envio caracter especial
                  00256 			;#define LOGO_SC		 0
                  00257 			;#define BATT_FULL	 1
                  00258 			;#define BATT_75		 2
                  00259 			;#define BATT_50		 3
                  00260 			;#define BATT_25		 4
                  00261 			;#define BATT_10		 5
                  00262 			;#define BATT_LW		 6 
                  00263 			;#define BATT_CLEAR	 7
                  00264 			;//valores PID
                  00265 			;#define REF_AC			  37
                  00266 			;#define BANDA_PROPORCIONAL 10 //50%
                  00267 			;
                  00268 			; //**************************************************************************************//
                  00269 			; //********************************  V A R I A B L E S  *********************************//
                  00270 			; //**************************************************************************************//
                  00271 			;#pragma rambank 0
                  00272 			;bit bUdw; // a 1 puja en la taula (incrementa) , a 0 decrementa
                  00273 			;uns16 ancho_pwm,r;
                  00274 			;float Vmax;
                  00275 			;uns16 SENO;
                  00276 			;char T,i,estado; // Index de la taula
                  00277 			;
                  00278 			;
                  00279 			;static const char sen [26] = 			
                  00280 			;{0,8,16,23,31,39,47,54,61,68,75,81,87,93,98,103,108,112,115,119,121,123,125,126,127,128};
                  00281 			;
                  00282 			;// PWM maximo 799 para ser 100% 
                  00283 			;// equivale a 6.24 pero no llegaremos para no quemar los mosfets
                  00284 			;
                  00285 			; //**************************************************************************************//
                  00286 			; //************************** I N T E R R U P C I O N E S *******************************//
                  00287 			; //**************************************************************************************//
                  00288 			;
                  00289 			;#include "int18XXX.h"	 // Capçalera de interrupcions.
                  00290 			;
                  00291 			;
                  00292 			;#pragma origin 0x08	//#pragma origin 0x18	(PIC 16F88x)
       0000       00293 	ORG 0x0008
                  00294 			;
                  00295 			;interrupt highPriorityTimer_0 (void)		// Interrupción por desbordamiento de Timer 0.			
                  00296 			;{
                  00297 highPriorityTimer_0
                  00298 			;	int_save_registers 
000008 CFD8 F060  00299 	MOVFF STATUS,svrSTATUS
00000C CFE0 F061  00300 	MOVFF BSR,svrBSR
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 6

ADDR   CODE       LINE  SOURCE

000010 0100       00301 	MOVLB 0
000012 6F62       00302 	MOVWF svrWREG,1
                  00303 			;
                  00304 			;	// save remaining registers on demand (error/warning)
                  00305 			;	//uns16 sv_FSR0 = FSR0;
                  00306 			;	//uns16 sv_FSR1 = FSR1;
                  00307 			;	//uns16 sv_FSR2 = FSR2;
                  00308 			;	//uns8 sv_PCLATH = PCLATH;
                  00309 			;	//uns8 sv_PCLATU = PCLATU;
                  00310 			;	uns8 sv_PRODL = PRODL;
000014 CFF3 F063  00311 	MOVFF PRODL,sv_PRODL
                  00312 			;	uns8 sv_PRODH = PRODH;
000018 CFF4 F064  00313 	MOVFF PRODH,sv_PRODH
                  00314 			;	uns24 sv_TBLPTR = TBLPTR;
00001C CFF6 F065  00315 	MOVFF TBLPTR,sv_TBLPTR
000020 CFF7 F066  00316 	MOVFF TBLPTR+1,sv_TBLPTR+1
000024 CFF8 F067  00317 	MOVFF TBLPTR+2,sv_TBLPTR+2
                  00318 			;	uns8 sv_TABLAT = TABLAT;
000028 CFF5 F068  00319 	MOVFF TABLAT,sv_TABLAT
                  00320 			;
                  00321 			;	if(TMR2IF) 
00002C A29E       00322 	BTFSS 0xF9E,TMR2IF,0
00002E D07B       00323 	BRA   m013
                  00324 			;	{ 
                  00325 			;		T2CON = 0b.0.0011.1.01; TMR2IF =0; //TMR2ON =1; // PostScaler per 4
000030 0E1D       00326 	MOVLW 29
000032 6ECA       00327 	MOVWF T2CON,0
000034 929E       00328 	BCF   0xF9E,TMR2IF,0
                  00329 			;		for (i = 1; i <= 6; i ++)  ancho_pwm = rl (ancho_pwm);
000036 0E01       00330 	MOVLW 1
000038 6FD6       00331 	MOVWF i,1
00003A 0E07       00332 m001	MOVLW 7
00003C 0100       00333 	MOVLB 0
00003E 61D6       00334 	CPFSLT i,1
000040 D004       00335 	BRA   m002
000042 37CC       00336 	RLCF  ancho_pwm,1,1
000044 37CD       00337 	RLCF  ancho_pwm+1,1,1
000046 2BD6       00338 	INCF  i,1,1
000048 D7F8       00339 	BRA   m001
                  00340 			;		CCPR1L = ancho_pwm.high8;
00004A C0CD FFBE  00341 m002	MOVFF ancho_pwm+1,CCPR1L
                  00342 			;		CCP1CON.5 = ancho_pwm.7;
00004E 0100       00343 	MOVLB 0
000050 AFCC       00344 	BTFSS ancho_pwm,7,1
000052 9ABD       00345 	BCF   CCP1CON,5,0
000054 BFCC       00346 	BTFSC ancho_pwm,7,1
000056 8ABD       00347 	BSF   CCP1CON,5,0
                  00348 			;		CCP1CON.4 = ancho_pwm.6;
000058 ADCC       00349 	BTFSS ancho_pwm,6,1
00005A 98BD       00350 	BCF   CCP1CON,4,0
00005C BDCC       00351 	BTFSC ancho_pwm,6,1
00005E 88BD       00352 	BSF   CCP1CON,4,0
                  00353 			;				  
                  00354 			;		if(bUdw){ 
000060 A1CB       00355 	BTFSS 0xCB,bUdw,1
000062 D007       00356 	BRA   m004
                  00357 			;			if(T>=25)  bUdw=0;      
000064 0E18       00358 	MOVLW 24
000066 65D5       00359 	CPFSGT T,1
000068 D002       00360 	BRA   m003
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 7

ADDR   CODE       LINE  SOURCE

00006A 91CB       00361 	BCF   0xCB,bUdw,1
                  00362 			;			else T++;
00006C D002       00363 	BRA   m004
00006E 0100       00364 m003	MOVLB 0
000070 2BD5       00365 	INCF  T,1,1
                  00366 			;		} 
                  00367 			;		if(!bUdw) T--;                       
000072 0100       00368 m004	MOVLB 0
000074 A1CB       00369 	BTFSS 0xCB,bUdw,1
000076 07D5       00370 	DECF  T,1,1
                  00371 			;		if(T==0) {
000078 0100       00372 	MOVLB 0
00007A 53D5       00373 	MOVF  T,1,1
00007C A4D8       00374 	BTFSS 0xFD8,Zero_,0
00007E D019       00375 	BRA   m007
                  00376 			;		  	while(!TMR2IF);TMR2IF =0; // ESPERO QUE ACABI  T=1
000080 A29E       00377 m005	BTFSS 0xF9E,TMR2IF,0
000082 D7FE       00378 	BRA   m005
000084 929E       00379 	BCF   0xF9E,TMR2IF,0
                  00380 			;			T2CON = 0b.0.0001.1.01;
000086 0E0D       00381 	MOVLW 13
000088 6ECA       00382 	MOVWF T2CON,0
                  00383 			;			CCPR1L = 0;
00008A 6ABE       00384 	CLRF  CCPR1L,0
                  00385 			;			CCP1CON.5 = 0;
00008C 9ABD       00386 	BCF   CCP1CON,5,0
                  00387 			;			CCP1CON.4 = 0;	 
00008E 98BD       00388 	BCF   CCP1CON,4,0
                  00389 			;			while(!TMR2IF); // espeor que acabi la 1era meitat del T=0, postsclaer =2
000090 A29E       00390 m006	BTFSS 0xF9E,TMR2IF,0
000092 D7FE       00391 	BRA   m006
                  00392 			;			TMR2IF =0;
000094 929E       00393 	BCF   0xF9E,TMR2IF,0
                  00394 			;			T2CON = 0b.0.0000.1.01;
000096 0E05       00395 	MOVLW 5
000098 6ECA       00396 	MOVWF T2CON,0
                  00397 			;			CCPR1L = 0;
00009A 6ABE       00398 	CLRF  CCPR1L,0
                  00399 			;			CCP1CON.5 = 0;
00009C 9ABD       00400 	BCF   CCP1CON,5,0
                  00401 			;			CCP1CON.4 = 0;
00009E 98BD       00402 	BCF   CCP1CON,4,0
                  00403 			;			LATD.0= !LATD.0;
0000A0 708C       00404 	BTG   LATD,0,0
                  00405 			;			bUdw=1;  
0000A2 0100       00406 	MOVLB 0
0000A4 81CB       00407 	BSF   0xCB,bUdw,1
                  00408 			;			T=1;
0000A6 0E01       00409 	MOVLW 1
0000A8 6FD5       00410 	MOVWF T,1
                  00411 			;			if(estado==ENVIO_LCD) estado = LECTURA_VAC;  // el deixo sortir
0000AA 0E04       00412 	MOVLW 4
0000AC 63D7       00413 	CPFSEQ estado,1
0000AE D001       00414 	BRA   m007
0000B0 6BD7       00415 	CLRF  estado,1
                  00416 			;		}			  
                  00417 			;		if(r>=60)r=60;		
0000B2 0100       00418 m007	MOVLB 0
0000B4 51CF       00419 	MOVF  r+1,W,1
0000B6 A4D8       00420 	BTFSS 0xFD8,Zero_,0
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 8

ADDR   CODE       LINE  SOURCE

0000B8 D003       00421 	BRA   m008
0000BA 0E3B       00422 	MOVLW 59
0000BC 65CE       00423 	CPFSGT r,1
0000BE D004       00424 	BRA   m009
0000C0 0E3C       00425 m008	MOVLW 60
0000C2 0100       00426 	MOVLB 0
0000C4 6FCE       00427 	MOVWF r,1
0000C6 6BCF       00428 	CLRF  r+1,1
                  00429 			;		//if(r<25)r=25;
                  00430 			;		SENO = sen[T];
0000C8 0100       00431 m009	MOVLB 0
0000CA 51D5       00432 	MOVF  T,W,1
0000CC EC62 F00D  00433 	CALL  _const1
0000D0 0100       00434 	MOVLB 0
0000D2 6FD3       00435 	MOVWF SENO,1
0000D4 6BD4       00436 	CLRF  SENO+1,1
                  00437 			;		ancho_pwm = (uns16)SENO*r;
0000D6 51D3       00438 	MOVF  SENO,W,1
0000D8 03CE       00439 	MULWF r,1
0000DA CFF3 F0CC  00440 	MOVFF PRODL,ancho_pwm
0000DE CFF4 F0CD  00441 	MOVFF PRODH,ancho_pwm+1
0000E2 51D4       00442 	MOVF  SENO+1,W,1
0000E4 03CE       00443 	MULWF r,1
0000E6 50F3       00444 	MOVF  PRODL,W,0
0000E8 27CD       00445 	ADDWF ancho_pwm+1,1,1
0000EA 51D3       00446 	MOVF  SENO,W,1
0000EC 03CF       00447 	MULWF r+1,1
0000EE 50F3       00448 	MOVF  PRODL,W,0
0000F0 27CD       00449 	ADDWF ancho_pwm+1,1,1
                  00450 			;		ancho_pwm=ancho_pwm/10;
0000F2 51CC       00451 	MOVF  ancho_pwm,W,1
0000F4 6F6A       00452 	MOVWF C4tmp,1
0000F6 51CD       00453 	MOVF  ancho_pwm+1,W,1
0000F8 6F6B       00454 	MOVWF C4tmp+1,1
0000FA 6B6C       00455 	CLRF  C5rem,1
0000FC 0E10       00456 	MOVLW 16
0000FE 6F69       00457 	MOVWF C3cnt,1
000100 0100       00458 m010	MOVLB 0
000102 376A       00459 	RLCF  C4tmp,1,1
000104 376B       00460 	RLCF  C4tmp+1,1,1
000106 376C       00461 	RLCF  C5rem,1,1
000108 B0D8       00462 	BTFSC 0xFD8,Carry,0
00010A D004       00463 	BRA   m011
00010C 0E0A       00464 	MOVLW 10
00010E 5D6C       00465 	SUBWF C5rem,W,1
000110 A0D8       00466 	BTFSS 0xFD8,Carry,0
000112 D004       00467 	BRA   m012
000114 0E0A       00468 m011	MOVLW 10
000116 0100       00469 	MOVLB 0
000118 5F6C       00470 	SUBWF C5rem,1,1
00011A 80D8       00471 	BSF   0xFD8,Carry,0
00011C 0100       00472 m012	MOVLB 0
00011E 37CC       00473 	RLCF  ancho_pwm,1,1
000120 37CD       00474 	RLCF  ancho_pwm+1,1,1
000122 2F69       00475 	DECFSZ C3cnt,1,1
000124 D7ED       00476 	BRA   m010
                  00477 			;		//Vmax=3.0;
                  00478 			;				  			  
                  00479 			;	} 
                  00480 			;			
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 9

ADDR   CODE       LINE  SOURCE

                  00481 			;	// restore registers that are saved
                  00482 			;	//FSR0 = sv_FSR0;
                  00483 			;	//FSR1 = sv_FSR1;
                  00484 			;	//FSR2 = sv_FSR2;
                  00485 			;	//PCLATH = sv_PCLATH;
                  00486 			;	//PCLATU = sv_PCLATU;
                  00487 			;	PRODL = sv_PRODL;
000126 C063 FFF3  00488 m013	MOVFF sv_PRODL,PRODL
                  00489 			;	PRODH = sv_PRODH;
00012A C064 FFF4  00490 	MOVFF sv_PRODH,PRODH
                  00491 			;	TBLPTR = sv_TBLPTR;
00012E C065 FFF6  00492 	MOVFF sv_TBLPTR,TBLPTR
000132 C066 FFF7  00493 	MOVFF sv_TBLPTR+1,TBLPTR+1
000136 C067 FFF8  00494 	MOVFF sv_TBLPTR+2,TBLPTR+2
                  00495 			;	TABLAT = sv_TABLAT;
00013A C068 FFF5  00496 	MOVFF sv_TABLAT,TABLAT
                  00497 			;
                  00498 			;    int_restore_registers 					// Devuelve W, STATUS y PCLATH.
00013E 0100       00499 	MOVLB 0
000140 5162       00500 	MOVF  svrWREG,W,1
000142 C061 FFE0  00501 	MOVFF svrBSR,BSR
000146 C060 FFD8  00502 	MOVFF svrSTATUS,STATUS
                  00503 			;}
00014A 0010       00504 	RETFIE
                  00505 
                  00506   ; FILE MATH24F.H
                  00507 			;// *************************************************
                  00508 			;// 24 bit basic floating point math operations
                  00509 			;// Copyright (c) B Knudsen Data, Norway, 2000 - 2005
                  00510 			;// *************************************************
                  00511 			;
                  00512 			;#pragma library 1
                  00513 			;/* PROTOTYPES for page definition in application header file:
                  00514 			;float24 operator* _fmul24( float24 arg1f24, float24 arg2f24);
                  00515 			;float24 operator/ _fdiv24( float24 arg1f24, float24 arg2f24);
                  00516 			;float24 operator+ _fadd24( float24 arg1f24, float24 arg2f24);
                  00517 			;float24 operator- _fsub24( float24 arg1f24, float24 arg2f24);
                  00518 			;float24 operator= _int24ToFloat24( int24 arg1f24);
                  00519 			;float24 operator= _int32ToFloat24( int32 arg32);
                  00520 			;int24 operator= _float24ToInt24( float24 arg1f24);
                  00521 			;bit operator< _f24_LT_f24( float24 arg1f24, float24 arg2f24);
                  00522 			;bit operator>= _f24_GE_f24( float24 arg1f24, float24 arg2f24);
                  00523 			;bit operator> _f24_GT_f24( float24 arg1f24, float24 arg2f24);
                  00524 			;bit operator<= _f24_LE_f24( float24 arg1f24, float24 arg2f24);
                  00525 			;*/
                  00526 			;
                  00527 			;// DEFINABLE SYMBOLS (in the application code):
                  00528 			;//#define FP_OPTIM_SPEED  // optimize for SPEED: default
                  00529 			;//#define FP_OPTIM_SIZE   // optimize for SIZE
                  00530 			;//#define DISABLE_ROUNDING   // disable rounding and save code space
                  00531 			;
                  00532 			;#define float24ToIEEE754(a) { a.mid8=rl(a.mid8); a.high8=rr(a.high8);\
                  00533 			;                              a.mid8=rr(a.mid8); }
                  00534 			;#define IEEE754ToFloat24(a) { a.mid8=rl(a.mid8); a.high8=rl(a.high8);\
                  00535 			;                              a.mid8=rr(a.mid8); }
                  00536 			;
                  00537 			;
                  00538 			;/*  24 bit floating point format:
                  00539 			;
                  00540 			;  address  ID
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 10

ADDR   CODE       LINE  SOURCE

                  00541 			;    X      a.low8  : LSB, bit 0-7 of mantissa
                  00542 			;    X+1    a.mid8  : bit 8-14 of mantissa, bit 15 is the sign bit
                  00543 			;    X+2    a.high8 : MSB, bit 0-7 of exponent, with bias 0x7F
                  00544 			;
                  00545 			;    bit 15 of mantissa is a hidden bit, always equal to 1
                  00546 			;    zero (0.0) :  a.high8 = 0 (mantissa & sign ignored)
                  00547 			;
                  00548 			;   MSB    LSB
                  00549 			;    7F 00 00  : 1.0   =  1.0  * 2**(0x7F-0x7F) = 1.0 * 1
                  00550 			;    7F 80 00  : -1.0  = -1.0  * 2**(0x7F-0x7F) = -1.0 * 1
                  00551 			;    80 00 00  : 2.0   =  1.0  * 2**(0x80-0x7F) = 1.0 * 2
                  00552 			;    80 40 00  : 3.0   =  1.5  * 2**(0x80-0x7F) = 1.5 * 2
                  00553 			;    7E 60 00  : 0.875 =  1.75 * 2**(0x7E-0x7F) = 1.75 * 0.5
                  00554 			;    7F 60 00  : 1.75  =  1.75 * 2**(0x7E-0x7F) = 1.75 * 1
                  00555 			;    7F 7F FF  : 1.999969482
                  00556 			;    00 7C 5A  : 0.0 (mantissa & sign ignored)
                  00557 			;    01 00 00  : 1.17549435e-38 =  1.0 * 2**(0x01-0x7F)
                  00558 			;    FE 7F FF  : 3.40277175e+38 =  1.999969482 * 2**(0xFE-0x7F)
                  00559 			;    FF 00 00  : +INF : positive infinity
                  00560 			;    FF 80 00  : -INF : negative infinity
                  00561 			;*/                 
                  00562 			;
                  00563 			;#define  FpBIAS  0x7F
                  00564 			;
                  00565 			;#ifndef FpFlags_defined
                  00566 			; #define FpFlags_defined
                  00567 			;
                  00568 			; char FpFlags;
                  00569 			; //bit IOV         @ FpFlags.0; // integer overflow flag: NOT USED
                  00570 			; bit FpOverflow    @ FpFlags.1; // floating point overflow flag
                  00571 			; bit FpUnderFlow   @ FpFlags.2; // floating point underflow flag
                  00572 			; bit FpDiv0        @ FpFlags.3; // floating point divide by zero flag
                  00573 			; //bit FpNAN       @ FpFlags.4; // not-a-number exception flag: NOT USED
                  00574 			; bit FpDomainError @ FpFlags.5; // domain error exception flag
                  00575 			; bit FpRounding    @ FpFlags.6; // floating point rounding flag, 0=truncation
                  00576 			;                                // 1 = unbiased rounding to nearest LSB
                  00577 			; //bit FpSaturate  @ FpFlags.7; // floating point saturate flag: NOT USED
                  00578 			;
                  00579 			; #pragma floatOverflow FpOverflow
                  00580 			; #pragma floatUnderflow FpUnderFlow
                  00581 			;
                  00582 			; #define InitFpFlags()  FpFlags = 0x40 /* enable rounding as default */
                  00583 			;#endif
                  00584 			;
                  00585 			;#ifdef DISABLE_ROUNDING
                  00586 			; #pragma floatRounding 0
                  00587 			;#endif
                  00588 			;
                  00589 			;
                  00590 			;#if __CoreSet__ < 1600
                  00591 			; #define genAdd(r,a) W=a; btsc(Carry); W=incsz(a); r+=W
                  00592 			; #define genSub(r,a) W=a; btss(Carry); W=incsz(a); r-=W
                  00593 			; #define genAddW(r,a) W=a; btsc(Carry); W=incsz(a); W=r+W
                  00594 			; #define genSubW(r,a) W=a; btss(Carry); W=incsz(a); W=r-W
                  00595 			;#else
                  00596 			; #define genAdd(r,a) W=a; r=addWFC(r)
                  00597 			; #define genSub(r,a) W=a; r=subWFB(r)
                  00598 			; #define genAddW(r,a) W=a; W=addWFC(r)
                  00599 			; #define genSubW(r,a) W=a; W=subWFB(r)
                  00600 			;#endif
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 11

ADDR   CODE       LINE  SOURCE

                  00601 			;
                  00602 			;#if __CoreSet__ == 1700 || __CoreSet__ == 1800
                  00603 			; #define hw_mult8x8(a,b)  W = a; multiply(b)
                  00604 			; #define loRES PRODL
                  00605 			; #define hiRES PRODH
                  00606 			;#endif
                  00607 			;
                  00608 			;#if __CoreSet__ == 2000
                  00609 			; #define hw_mult8x8(a,b)  W = a; multiply(b)
                  00610 			; #define loRES W
                  00611 			; #define hiRES MULH
                  00612 			;#endif
                  00613 			;
                  00614 			;
                  00615 			;float24 operator* _fmul24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  00616 			;{
                  00617 _fmul24
                  00618 			;    uns16 aarg;
                  00619 			;    W = arg1f24.mid8;
00014C 0100       00620 	MOVLB 0
00014E 51B1       00621 	MOVF  arg1f24+1,W,1
                  00622 			;    aarg.high8 = W;
000150 6FBC       00623 	MOVWF aarg+1,1
                  00624 			;
                  00625 			;    // save sign
                  00626 			;    char sign = arg2f24.mid8 ^ W;  // before first overflow test
000152 19B4       00627 	XORWF arg2f24+1,W,1
000154 6FBD       00628 	MOVWF sign,1
                  00629 			;
                  00630 			;    W = arg1f24.high8;
000156 51B2       00631 	MOVF  arg1f24+2,W,1
                  00632 			;   #if __CoreSet__ / 100 == 17
                  00633 			;    if (W != 0)
                  00634 			;        W = arg2f24.high8;
                  00635 			;    if (W == 0)
                  00636 			;        goto RES0;
                  00637 			;   #else
                  00638 			;    if (!Zero_)
000158 A4D8       00639 	BTFSS 0xFD8,Zero_,0
                  00640 			;        W = arg2f24.high8;
00015A 51B5       00641 	MOVF  arg2f24+2,W,1
                  00642 			;    if (Zero_)
00015C B4D8       00643 	BTFSC 0xFD8,Zero_,0
                  00644 			;        goto RES0;
00015E D04A       00645 	BRA   m018
                  00646 			;   #endif
                  00647 			;
                  00648 			;    arg1f24.high8 += W /* arg2f24.high8 */;
000160 0100       00649 	MOVLB 0
000162 27B2       00650 	ADDWF arg1f24+2,1,1
                  00651 			;    W = FpBIAS-1;
000164 0E7E       00652 	MOVLW 126
                  00653 			;    if (Carry)  {
000166 A0D8       00654 	BTFSS 0xFD8,Carry,0
000168 D004       00655 	BRA   m014
                  00656 			;        arg1f24.high8 -= W;
00016A 5FB2       00657 	SUBWF arg1f24+2,1,1
                  00658 			;        if (Carry)
00016C A0D8       00659 	BTFSS 0xFD8,Carry,0
00016E D005       00660 	BRA   m015
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 12

ADDR   CODE       LINE  SOURCE

                  00661 			;            goto OVERFLOW;
000170 D044       00662 	BRA   m019
                  00663 			;    }
                  00664 			;    else  {
                  00665 			;        arg1f24.high8 -= W;
000172 0100       00666 m014	MOVLB 0
000174 5FB2       00667 	SUBWF arg1f24+2,1,1
                  00668 			;        if (!Carry)
000176 A0D8       00669 	BTFSS 0xFD8,Carry,0
                  00670 			;            goto UNDERFLOW;
000178 D03B       00671 	BRA   m017
                  00672 			;    }
                  00673 			;    aarg.low8 = arg1f24.low8;
00017A C0B0 F0BB  00674 m015	MOVFF arg1f24,aarg
                  00675 			;
                  00676 			;    aarg.15 = 1;
00017E 0100       00677 	MOVLB 0
000180 8FBC       00678 	BSF   aarg+1,7,1
                  00679 			;    arg2f24.15 = 1;
000182 8FB4       00680 	BSF   arg2f24+1,7,1
                  00681 			;
                  00682 			;   #if defined hw_mult8x8  &&  !defined FP_OPTIM_SIZE
                  00683 			;
                  00684 			;    char tmpL;
                  00685 			;    arg1f24.low16 = 0;
000184 6BB0       00686 	CLRF  arg1f24,1
000186 6BB1       00687 	CLRF  arg1f24+1,1
                  00688 			;
                  00689 			;    hw_mult8x8( arg2f24.low8, aarg.low8);   // p1
000188 51B3       00690 	MOVF  arg2f24,W,1
00018A 03BB       00691 	MULWF aarg,1
                  00692 			;    tmpL = hiRES;
00018C CFF4 F0BE  00693 	MOVFF PRODH,tmpL
                  00694 			;
                  00695 			;    hw_mult8x8( arg2f24.mid8, aarg.low8);  // p2
000190 51B4       00696 	MOVF  arg2f24+1,W,1
000192 03BB       00697 	MULWF aarg,1
                  00698 			;    tmpL += loRES;
000194 50F3       00699 	MOVF  PRODL,W,0
000196 27BE       00700 	ADDWF tmpL,1,1
                  00701 			;    genAdd( arg1f24.low8, hiRES);
000198 50F4       00702 	MOVF  PRODH,W,0
00019A 23B0       00703 	ADDWFC arg1f24,1,1
                  00704 			;    genAdd( arg1f24.mid8, 0);
00019C 0E00       00705 	MOVLW 0
00019E 23B1       00706 	ADDWFC arg1f24+1,1,1
                  00707 			;
                  00708 			;    hw_mult8x8( arg2f24.low8, aarg.mid8);  // p2
0001A0 51B3       00709 	MOVF  arg2f24,W,1
0001A2 03BC       00710 	MULWF aarg+1,1
                  00711 			;    tmpL += loRES;
0001A4 50F3       00712 	MOVF  PRODL,W,0
0001A6 27BE       00713 	ADDWF tmpL,1,1
                  00714 			;    genAdd( arg1f24.low8, hiRES);
0001A8 50F4       00715 	MOVF  PRODH,W,0
0001AA 23B0       00716 	ADDWFC arg1f24,1,1
                  00717 			;    genAdd( arg1f24.mid8, 0);
0001AC 0E00       00718 	MOVLW 0
0001AE 23B1       00719 	ADDWFC arg1f24+1,1,1
                  00720 			;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 13

ADDR   CODE       LINE  SOURCE

                  00721 			;    hw_mult8x8( arg2f24.mid8, aarg.mid8);  // p3
0001B0 51B4       00722 	MOVF  arg2f24+1,W,1
0001B2 03BC       00723 	MULWF aarg+1,1
                  00724 			;    arg1f24.low8 += loRES;
0001B4 50F3       00725 	MOVF  PRODL,W,0
0001B6 27B0       00726 	ADDWF arg1f24,1,1
                  00727 			;    genAdd( arg1f24.mid8, hiRES);
0001B8 50F4       00728 	MOVF  PRODH,W,0
0001BA 23B1       00729 	ADDWFC arg1f24+1,1,1
                  00730 			;
                  00731 			;   #undef hw_mult8x8
                  00732 			;   #undef loRES
                  00733 			;   #undef hiRES
                  00734 			;
                  00735 			;    if (!arg1f24.15)  {
0001BC BFB1       00736 	BTFSC arg1f24+1,7,1
0001BE D009       00737 	BRA   m016
                  00738 			;        tmpL = rl( tmpL);
0001C0 37BE       00739 	RLCF  tmpL,1,1
                  00740 			;        arg1f24.low16 = rl( arg1f24.low16);
0001C2 37B0       00741 	RLCF  arg1f24,1,1
0001C4 37B1       00742 	RLCF  arg1f24+1,1,1
                  00743 			;        if (arg1f24.high8 == 0)
0001C6 53B2       00744 	MOVF  arg1f24+2,1,1
0001C8 B4D8       00745 	BTFSC 0xFD8,Zero_,0
                  00746 			;            goto UNDERFLOW;
0001CA D012       00747 	BRA   m017
                  00748 			;        arg1f24.high8 -= 1;
0001CC 0100       00749 	MOVLB 0
0001CE 07B2       00750 	DECF  arg1f24+2,1,1
                  00751 			;        W = rl( tmpL);  // restore bit behind LSB in Carry
0001D0 35BE       00752 	RLCF  tmpL,W,1
                  00753 			;    }
                  00754 			;
                  00755 			;   #else
                  00756 			;
                  00757 			;    arg1f24.low16 = 0;
                  00758 			;
                  00759 			;    char counter = sizeof(aarg)*8;
                  00760 			;
                  00761 			;    do  {
                  00762 			;        aarg = rr( aarg);
                  00763 			;        if (Carry)  {
                  00764 			;            arg1f24.low8 += arg2f24.low8;
                  00765 			;            genAdd( arg1f24.mid8, arg2f24.mid8);
                  00766 			;        }
                  00767 			;        arg1f24.low16 = rr( arg1f24.low16);
                  00768 			;        counter = decsz(counter);
                  00769 			;    } while (1);
                  00770 			;
                  00771 			;    if (!arg1f24.15)  {
                  00772 			;        // catch Carry bit that was shifted out previously
                  00773 			;        arg1f24.low16 = rl( arg1f24.low16);
                  00774 			;        if (arg1f24.high8 == 0)
                  00775 			;            goto UNDERFLOW;
                  00776 			;        arg1f24.high8 -= 1;
                  00777 			;        W = rl( aarg.high8);
                  00778 			;        // restore bit behind LSB in Carry
                  00779 			;    }
                  00780 			;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 14

ADDR   CODE       LINE  SOURCE

                  00781 			;   #endif
                  00782 			;
                  00783 			;   #ifndef DISABLE_ROUNDING
                  00784 			;    if (FpRounding  &&  Carry)  {
0001D2 0100       00785 m016	MOVLB 0
0001D4 ADD8       00786 	BTFSS 0xD8,FpRounding,1
0001D6 D018       00787 	BRA   m021
0001D8 A0D8       00788 	BTFSS 0xFD8,Carry,0
0001DA D016       00789 	BRA   m021
                  00790 			;        arg1f24.low8 += 1;
0001DC 3FB0       00791 	INCFSZ arg1f24,1,1
                  00792 			;        if (!arg1f24.low8)  {
0001DE D014       00793 	BRA   m021
                  00794 			;            arg1f24.mid8 += 1;
0001E0 3FB1       00795 	INCFSZ arg1f24+1,1,1
                  00796 			;            if (!arg1f24.mid8)  {
0001E2 D012       00797 	BRA   m021
                  00798 			;               #if __CoreSet__ >= 1700 && __CoreSet__ <= 1800
                  00799 			;                Carry = 1; // previous INCF changes Carry
0001E4 80D8       00800 	BSF   0xFD8,Carry,0
                  00801 			;               #else
                  00802 			;                // Carry = 1; //OK
                  00803 			;               #endif
                  00804 			;                arg1f24.low16 = rr( arg1f24.low16);
0001E6 33B1       00805 	RRCF  arg1f24+1,1,1
0001E8 33B0       00806 	RRCF  arg1f24,1,1
                  00807 			;                arg1f24.high8 += 1;
0001EA 3FB2       00808 	INCFSZ arg1f24+2,1,1
                  00809 			;                if (Zero_)
0001EC D00D       00810 	BRA   m021
                  00811 			;                    goto OVERFLOW;
0001EE D005       00812 	BRA   m019
                  00813 			;            }
                  00814 			;        }
                  00815 			;    }
                  00816 			;   #endif
                  00817 			;    goto SET_SIGN;
                  00818 			;
                  00819 			;  UNDERFLOW:
                  00820 			;    FpUnderFlow = 1;
0001F0 0100       00821 m017	MOVLB 0
0001F2 85D8       00822 	BSF   0xD8,FpUnderFlow,1
                  00823 			;  RES0:
                  00824 			;    arg1f24.high8 = 0;
0001F4 0100       00825 m018	MOVLB 0
0001F6 6BB2       00826 	CLRF  arg1f24+2,1
                  00827 			;    goto MANTISSA;
0001F8 D003       00828 	BRA   m020
                  00829 			;
                  00830 			;  OVERFLOW:
                  00831 			;    FpOverflow = 1;
0001FA 0100       00832 m019	MOVLB 0
0001FC 83D8       00833 	BSF   0xD8,FpOverflow,1
                  00834 			;    arg1f24.high8 = 0xFF;
0001FE 69B2       00835 	SETF  arg1f24+2,1
                  00836 			;  MANTISSA:
                  00837 			;    arg1f24.low16 = 0x8000;
000200 0100       00838 m020	MOVLB 0
000202 6BB0       00839 	CLRF  arg1f24,1
000204 0E80       00840 	MOVLW 128
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 15

ADDR   CODE       LINE  SOURCE

000206 6FB1       00841 	MOVWF arg1f24+1,1
                  00842 			;
                  00843 			;  SET_SIGN:
                  00844 			;    if (!(sign & 0x80))
000208 0100       00845 m021	MOVLB 0
00020A AFBD       00846 	BTFSS sign,7,1
                  00847 			;        arg1f24.15 = 0;
00020C 9FB1       00848 	BCF   arg1f24+1,7,1
                  00849 			;    return arg1f24;
00020E 0100       00850 	MOVLB 0
000210 51B0       00851 	MOVF  arg1f24,W,1
000212 0012       00852 	RETURN
                  00853 			;}
                  00854 			;
                  00855 			;
                  00856 			;
                  00857 			;float24 operator/ _fdiv24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  00858 			;{
                  00859 _fdiv24
                  00860 			;    uns16 aarg;
                  00861 			;    W = arg1f24.mid8;
                  00862 			;    aarg.high8 = W;
                  00863 			;
                  00864 			;    // save sign
                  00865 			;    char sign = arg2f24.mid8 ^ W;  // before first overflow test
                  00866 			;
                  00867 			;   #if __CoreSet__ / 100 == 17
                  00868 			;    if (!arg2f24.high8)
                  00869 			;        goto Div0;
                  00870 			;   #else
                  00871 			;    W = arg2f24.high8;
                  00872 			;    if (Zero_)
                  00873 			;        goto Div0;
                  00874 			;   #endif
                  00875 			;    if (!arg1f24.high8)
                  00876 			;        goto RES0;
                  00877 			;
                  00878 			;    arg1f24.high8 -= arg2f24.high8;
                  00879 			;    W = FpBIAS;
                  00880 			;    if (!Carry)  {
                  00881 			;        arg1f24.high8 += W;
                  00882 			;        if (!Carry)
                  00883 			;            goto UNDERFLOW;
                  00884 			;    }
                  00885 			;    else  {
                  00886 			;        arg1f24.high8 += W;
                  00887 			;        if (Carry)
                  00888 			;            goto OVERFLOW;
                  00889 			;    }
                  00890 			;
                  00891 			;    aarg.low8 = arg1f24.low8;
                  00892 			;    aarg.15 = 1;
                  00893 			;    arg2f24.15 = 1;
                  00894 			;
                  00895 			;    // division: shift & add
                  00896 			;    char counter = 16;
                  00897 			;    arg1f24.low16 = 0;  // speedup
                  00898 			;
                  00899 			;#if defined FP_OPTIM_SPEED || !defined FP_OPTIM_SIZE  // SPEED
                  00900 			;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 16

ADDR   CODE       LINE  SOURCE

                  00901 			;    goto START_ML;
                  00902 			;
                  00903 			;  TEST_ZERO_L:
                  00904 			;    W = aarg.low8 - arg2f24.low8;
                  00905 			;    if (!Carry)
                  00906 			;        goto SHIFT_IN_CARRY;
                  00907 			;    aarg.low8 = W;
                  00908 			;    aarg.high8 = 0;
                  00909 			;    goto SET_AND_SHIFT_IN_CARRY;
                  00910 			;
                  00911 			;// MAIN LOOP
                  00912 			;    do  {
                  00913 			;      LOOP_ML:
                  00914 			;        if (!Carry)  {
                  00915 			;           START_ML:
                  00916 			;            W = aarg.high8 - arg2f24.mid8;
                  00917 			;            if (Zero_)
                  00918 			;                goto TEST_ZERO_L;
                  00919 			;            if (!Carry)
                  00920 			;                goto SHIFT_IN_CARRY;
                  00921 			;        }
                  00922 			;        aarg.low8 -= arg2f24.low8;
                  00923 			;        genSub( aarg.high8, arg2f24.mid8);
                  00924 			;      SET_AND_SHIFT_IN_CARRY:
                  00925 			;        Carry = 1;
                  00926 			;      SHIFT_IN_CARRY:
                  00927 			;        arg1f24.low16 = rl( arg1f24.low16);
                  00928 			;        // Carry = 0;  // ok, speedup
                  00929 			;        aarg = rl( aarg);
                  00930 			;        counter = decsz(counter);
                  00931 			;    } while (1);
                  00932 			;
                  00933 			;
                  00934 			;
                  00935 			;#else  // SIZE
                  00936 			;
                  00937 			;    goto START_ML;
                  00938 			;
                  00939 			;// MAIN LOOP
                  00940 			;    do  {
                  00941 			;      LOOP_ML:
                  00942 			;        if (Carry)
                  00943 			;            goto SUBTRACT;
                  00944 			;      START_ML:
                  00945 			;        W = aarg.low8 - arg2f24.low8;
                  00946 			;        genSubW( aarg.high8, arg2f24.mid8);
                  00947 			;        if (!Carry)
                  00948 			;            goto SKIP_SUB;
                  00949 			;       SUBTRACT:
                  00950 			;        aarg.low8 -= arg2f24.low8;
                  00951 			;        genSub( aarg.high8, arg2f24.mid8);
                  00952 			;        Carry = 1;
                  00953 			;       SKIP_SUB:
                  00954 			;        arg1f24.low16 = rl( arg1f24.low16);
                  00955 			;        // Carry = 0;  // ok
                  00956 			;        aarg = rl( aarg);
                  00957 			;        counter = decsz(counter);
                  00958 			;    } while (1);
                  00959 			;
                  00960 			;#endif
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 17

ADDR   CODE       LINE  SOURCE

                  00961 			;
                  00962 			;    if (!arg1f24.15)  {
                  00963 			;        if (!arg1f24.high8)
                  00964 			;            goto UNDERFLOW;
                  00965 			;       #if __CoreSet__ >= 1700 && __CoreSet__ <= 1800
                  00966 			;        sign = rr( sign);   // Save Carry
                  00967 			;       #endif
                  00968 			;        arg1f24.high8 --;
                  00969 			;        counter ++;
                  00970 			;       #if __CoreSet__ >= 1700 && __CoreSet__ <= 1800
                  00971 			;        sign = rl( sign);   // Restore Carry, changed by INCF/DECF
                  00972 			;       #endif
                  00973 			;        goto LOOP_ML;
                  00974 			;    }
                  00975 			;
                  00976 			;   #ifndef DISABLE_ROUNDING
                  00977 			;    if (FpRounding)  {
                  00978 			;        if (Carry)
                  00979 			;            goto ADD_1;
                  00980 			;        aarg.low8 -= arg2f24.low8;
                  00981 			;        genSub( aarg.high8, arg2f24.mid8);
                  00982 			;        if (Carry)  {
                  00983 			;          ADD_1:
                  00984 			;            arg1f24.low8 += 1;
                  00985 			;            if (!arg1f24.low8)  {
                  00986 			;                arg1f24.mid8 ++;
                  00987 			;                if (!arg1f24.mid8)  {
                  00988 			;                    arg1f24.low16 = rr( arg1f24.low16);
                  00989 			;                    arg1f24.high8 ++;
                  00990 			;                    if (!arg1f24.high8)
                  00991 			;                        goto OVERFLOW;
                  00992 			;                }
                  00993 			;            }
                  00994 			;        }
                  00995 			;    }
                  00996 			;   #endif
                  00997 			;    goto SET_SIGN;
                  00998 			;
                  00999 			;  Div0:
                  01000 			;    FpDiv0 = 1;
                  01001 			;    goto SATURATE;
                  01002 			;
                  01003 			;  UNDERFLOW:
                  01004 			;    FpUnderFlow = 1;
                  01005 			;  RES0:
                  01006 			;    arg1f24.high8 = 0;
                  01007 			;    goto MANTISSA;
                  01008 			;
                  01009 			;  OVERFLOW:
                  01010 			;    FpOverflow = 1;
                  01011 			;  SATURATE:
                  01012 			;    arg1f24.high8 = 0xFF;
                  01013 			;  MANTISSA:
                  01014 			;    arg1f24.low16 = 0x8000;
                  01015 			;
                  01016 			;  SET_SIGN:
                  01017 			;    if (!(sign & 0x80))
                  01018 			;        arg1f24.15 = 0;
                  01019 			;    return arg1f24;
                  01020 			;}
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 18

ADDR   CODE       LINE  SOURCE

                  01021 			;
                  01022 			;
                  01023 			;float24 operator+ _fadd24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  01024 			;{
                  01025 _fadd24
                  01026 			;    char xtra, temp;
                  01027 			;    char expo = arg1f24.high8 - arg2f24.high8;
000214 0100       01028 	MOVLB 0
000216 51B5       01029 	MOVF  arg2f24+2,W,1
000218 5DB2       01030 	SUBWF arg1f24+2,W,1
00021A 6FBD       01031 	MOVWF expo,1
                  01032 			;    if (!Carry)  {
00021C B0D8       01033 	BTFSC 0xFD8,Carry,0
00021E D013       01034 	BRA   m022
                  01035 			;        expo = -expo;
000220 6DBD       01036 	NEGF  expo,1
                  01037 			;        temp = arg1f24.high8;
000222 C0B2 F0BC  01038 	MOVFF arg1f24+2,temp
                  01039 			;        arg1f24.high8 = arg2f24.high8;
000226 C0B5 F0B2  01040 	MOVFF arg2f24+2,arg1f24+2
                  01041 			;        arg2f24.high8 = temp;
00022A C0BC F0B5  01042 	MOVFF temp,arg2f24+2
                  01043 			;        temp = arg1f24.mid8;
00022E C0B1 F0BC  01044 	MOVFF arg1f24+1,temp
                  01045 			;        arg1f24.mid8 = arg2f24.mid8;
000232 C0B4 F0B1  01046 	MOVFF arg2f24+1,arg1f24+1
                  01047 			;        arg2f24.mid8 = temp;
000236 C0BC F0B4  01048 	MOVFF temp,arg2f24+1
                  01049 			;        temp = arg1f24.low8;
00023A C0B0 F0BC  01050 	MOVFF arg1f24,temp
                  01051 			;        arg1f24.low8 = arg2f24.low8;
00023E C0B3 F0B0  01052 	MOVFF arg2f24,arg1f24
                  01053 			;        arg2f24.low8 = temp;
000242 C0BC F0B3  01054 	MOVFF temp,arg2f24
                  01055 			;    }
                  01056 			;    if (expo > sizeof(arg1f24)*8-7)
000246 0E11       01057 m022	MOVLW 17
000248 0100       01058 	MOVLB 0
00024A 65BD       01059 	CPFSGT expo,1
00024C D001       01060 	BRA   m023
                  01061 			;        goto _RETURN_MF;
00024E D086       01062 	BRA   m041
                  01063 			;    if (!arg2f24.high8)
000250 0100       01064 m023	MOVLB 0
000252 53B5       01065 	MOVF  arg2f24+2,1,1
000254 B4D8       01066 	BTFSC 0xFD8,Zero_,0
                  01067 			;        goto _RETURN_MF;   // result is arg1f24
000256 D082       01068 	BRA   m041
                  01069 			;
                  01070 			;    xtra = 0;
000258 0100       01071 	MOVLB 0
00025A 6BBB       01072 	CLRF  xtra,1
                  01073 			;
                  01074 			;    W = arg1f24.mid8;
00025C 51B1       01075 	MOVF  arg1f24+1,W,1
                  01076 			;    temp = W;
00025E 6FBC       01077 	MOVWF temp,1
                  01078 			;    char sign = arg2f24.mid8 ^ W;
000260 19B4       01079 	XORWF arg2f24+1,W,1
000262 6FBE       01080 	MOVWF sign_3,1
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 19

ADDR   CODE       LINE  SOURCE

                  01081 			;    arg1f24.15 = 1;
000264 8FB1       01082 	BSF   arg1f24+1,7,1
                  01083 			;    arg2f24.15 = 1;
000266 8FB4       01084 	BSF   arg2f24+1,7,1
                  01085 			;
                  01086 			;    while (1)  {
                  01087 			;        W = 8;
000268 0E08       01088 m024	MOVLW 8
                  01089 			;        expo -= W;
00026A 0100       01090 	MOVLB 0
00026C 5FBD       01091 	SUBWF expo,1,1
                  01092 			;        if (!Carry)
00026E A0D8       01093 	BTFSS 0xFD8,Carry,0
                  01094 			;            break;
000270 D007       01095 	BRA   m025
                  01096 			;        xtra = arg2f24.low8;
000272 C0B3 F0BB  01097 	MOVFF arg2f24,xtra
                  01098 			;        arg2f24.low8 = arg2f24.mid8;
000276 C0B4 F0B3  01099 	MOVFF arg2f24+1,arg2f24
                  01100 			;        arg2f24.mid8 = 0;
00027A 0100       01101 	MOVLB 0
00027C 6BB4       01102 	CLRF  arg2f24+1,1
                  01103 			;    }
00027E D7F4       01104 	BRA   m024
                  01105 			;    expo += W;
000280 0100       01106 m025	MOVLB 0
000282 27BD       01107 	ADDWF expo,1,1
                  01108 			;    if (expo)  {
000284 B4D8       01109 	BTFSC 0xFD8,Zero_,0
000286 D007       01110 	BRA   m027
                  01111 			;        do  {
                  01112 			;            Carry = 0;
000288 90D8       01113 m026	BCF   0xFD8,Carry,0
                  01114 			;            arg2f24.low16 = rr( arg2f24.low16);
00028A 0100       01115 	MOVLB 0
00028C 33B4       01116 	RRCF  arg2f24+1,1,1
00028E 33B3       01117 	RRCF  arg2f24,1,1
                  01118 			;            xtra = rr( xtra);
000290 33BB       01119 	RRCF  xtra,1,1
                  01120 			;        } while (--expo > 0);
000292 2FBD       01121 	DECFSZ expo,1,1
000294 D7F9       01122 	BRA   m026
                  01123 			;    }
                  01124 			;
                  01125 			;
                  01126 			;    if (sign & 0x80)  {
000296 0100       01127 m027	MOVLB 0
000298 AFBE       01128 	BTFSS sign_3,7,1
00029A D039       01129 	BRA   m033
                  01130 			;        // SUBTRACT
                  01131 			;        arg1f24.low8 -= arg2f24.low8;
00029C 51B3       01132 	MOVF  arg2f24,W,1
00029E 5FB0       01133 	SUBWF arg1f24,1,1
                  01134 			;        genSub( arg1f24.mid8, arg2f24.mid8);
0002A0 51B4       01135 	MOVF  arg2f24+1,W,1
0002A2 5BB1       01136 	SUBWFB arg1f24+1,1,1
                  01137 			;        if (!Carry)  {  // arg2f24 > arg1f24
0002A4 B0D8       01138 	BTFSC 0xFD8,Carry,0
0002A6 D007       01139 	BRA   m028
                  01140 			;            arg1f24.low16 = -arg1f24.low16;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 20

ADDR   CODE       LINE  SOURCE

0002A8 80D8       01141 	BSF   0xFD8,Carry,0
0002AA 0E00       01142 	MOVLW 0
0002AC 57B0       01143 	SUBFWB arg1f24,1,1
0002AE 0E00       01144 	MOVLW 0
0002B0 57B1       01145 	SUBFWB arg1f24+1,1,1
                  01146 			;            // xtra == 0 because arg1f24.exp == arg2f24.exp
                  01147 			;            temp ^= 0x80;  // invert sign
0002B2 0E80       01148 	MOVLW 128
0002B4 1BBC       01149 	XORWF temp,1,1
                  01150 			;        }
                  01151 			;        xtra = -xtra;
0002B6 0100       01152 m028	MOVLB 0
0002B8 6DBB       01153 	NEGF  xtra,1
                  01154 			;        if (xtra)
0002BA B4D8       01155 	BTFSC 0xFD8,Zero_,0
0002BC D003       01156 	BRA   m029
                  01157 			;            arg1f24.low16 --;
0002BE 07B0       01158 	DECF  arg1f24,1,1
0002C0 0E00       01159 	MOVLW 0
0002C2 5BB1       01160 	SUBWFB arg1f24+1,1,1
                  01161 			;        // adjust result left
                  01162 			;       #define counter expo
                  01163 			;        counter = 3;
0002C4 0E03       01164 m029	MOVLW 3
0002C6 0100       01165 	MOVLB 0
0002C8 6FBD       01166 	MOVWF expo,1
                  01167 			;        while (!arg1f24.mid8)  {
0002CA 0100       01168 m030	MOVLB 0
0002CC 53B1       01169 	MOVF  arg1f24+1,1,1
0002CE A4D8       01170 	BTFSS 0xFD8,Zero_,0
0002D0 D00D       01171 	BRA   m031
                  01172 			;            arg1f24.mid8 = arg1f24.low8;
0002D2 C0B0 F0B1  01173 	MOVFF arg1f24,arg1f24+1
                  01174 			;            arg1f24.low8 = xtra;
0002D6 C0BB F0B0  01175 	MOVFF xtra,arg1f24
                  01176 			;            xtra = 0;
0002DA 6BBB       01177 	CLRF  xtra,1
                  01178 			;            arg1f24.high8 -= 8;
0002DC 0E08       01179 	MOVLW 8
0002DE 5FB2       01180 	SUBWF arg1f24+2,1,1
                  01181 			;            if (!Carry)
0002E0 A0D8       01182 	BTFSS 0xFD8,Carry,0
                  01183 			;                goto RES0;
0002E2 D02F       01184 	BRA   m037
                  01185 			;            if (--counter == 0)  // max 2 iterations
0002E4 0100       01186 	MOVLB 0
0002E6 2FBD       01187 	DECFSZ expo,1,1
0002E8 D7F0       01188 	BRA   m030
                  01189 			;                goto RES0;
0002EA D02B       01190 	BRA   m037
                  01191 			;        }
                  01192 			;       #undef counter
                  01193 			;        while (!arg1f24.15)  {
0002EC 0100       01194 m031	MOVLB 0
0002EE BFB1       01195 	BTFSC arg1f24+1,7,1
0002F0 D007       01196 	BRA   m032
                  01197 			;            Carry = 0;
0002F2 90D8       01198 	BCF   0xFD8,Carry,0
                  01199 			;            xtra = rl( xtra);
0002F4 37BB       01200 	RLCF  xtra,1,1
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 21

ADDR   CODE       LINE  SOURCE

                  01201 			;            arg1f24.low16 = rl( arg1f24.low16);
0002F6 37B0       01202 	RLCF  arg1f24,1,1
0002F8 37B1       01203 	RLCF  arg1f24+1,1,1
                  01204 			;            arg1f24.high8 --;
0002FA 2FB2       01205 	DECFSZ arg1f24+2,1,1
                  01206 			;            if (!arg1f24.high8)
0002FC D7F7       01207 	BRA   m031
                  01208 			;                goto RES0;   // UNDERFLOW?
0002FE D021       01209 	BRA   m037
                  01210 			;        }
                  01211 			;       #ifndef DISABLE_ROUNDING
                  01212 			;        if (FpRounding  &&  (xtra & 0x80))  {
000300 0100       01213 m032	MOVLB 0
000302 ADD8       01214 	BTFSS 0xD8,FpRounding,1
000304 D028       01215 	BRA   m040
000306 AFBB       01216 	BTFSS xtra,7,1
000308 D026       01217 	BRA   m040
                  01218 			;            xtra = 0; // disable recursion
00030A 6BBB       01219 	CLRF  xtra,1
                  01220 			;            goto INCREMENT;
00030C D012       01221 	BRA   m036
                  01222 			;        }
                  01223 			;       #endif
                  01224 			;    }
                  01225 			;    else  {
                  01226 			;        // ADD arg1f24 and arg2f24
                  01227 			;        arg1f24.low8 += arg2f24.low8;
00030E 0100       01228 m033	MOVLB 0
000310 51B3       01229 	MOVF  arg2f24,W,1
000312 27B0       01230 	ADDWF arg1f24,1,1
                  01231 			;        genAdd( arg1f24.mid8, arg2f24.mid8);
000314 51B4       01232 	MOVF  arg2f24+1,W,1
000316 23B1       01233 	ADDWFC arg1f24+1,1,1
                  01234 			;        if (Carry)  {
000318 A0D8       01235 	BTFSS 0xFD8,Carry,0
00031A D006       01236 	BRA   m035
                  01237 			;          ADJUST_RIGHT:
                  01238 			;            arg1f24.low16 = rr( arg1f24.low16);
00031C 0100       01239 m034	MOVLB 0
00031E 33B1       01240 	RRCF  arg1f24+1,1,1
000320 33B0       01241 	RRCF  arg1f24,1,1
                  01242 			;            xtra = rr( xtra);
000322 33BB       01243 	RRCF  xtra,1,1
                  01244 			;            arg1f24.high8 += 1;  // exp
000324 4BB2       01245 	INFSNZ arg1f24+2,1,1
                  01246 			;            if (!arg1f24.high8)
                  01247 			;                goto OVERFLOW;
000326 D010       01248 	BRA   m038
                  01249 			;        }
                  01250 			;       #ifndef DISABLE_ROUNDING
                  01251 			;        if (FpRounding  &&  (xtra & 0x80))  {
000328 0100       01252 m035	MOVLB 0
00032A ADD8       01253 	BTFSS 0xD8,FpRounding,1
00032C D014       01254 	BRA   m040
00032E AFBB       01255 	BTFSS xtra,7,1
000330 D012       01256 	BRA   m040
                  01257 			;          INCREMENT:
                  01258 			;            arg1f24.low8 += 1;
000332 0100       01259 m036	MOVLB 0
000334 3FB0       01260 	INCFSZ arg1f24,1,1
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 22

ADDR   CODE       LINE  SOURCE

                  01261 			;            if (!arg1f24.low8)  {
000336 D00F       01262 	BRA   m040
                  01263 			;                arg1f24.mid8 += 1;
000338 3FB1       01264 	INCFSZ arg1f24+1,1,1
                  01265 			;                if (!arg1f24.mid8)  {
00033A D00D       01266 	BRA   m040
                  01267 			;                    Carry = 1; // prepare for shift
00033C 80D8       01268 	BSF   0xFD8,Carry,0
                  01269 			;                    arg1f24.0 = 0;  // disable recursion
00033E 91B0       01270 	BCF   arg1f24,0,1
                  01271 			;                    goto ADJUST_RIGHT;
000340 D7ED       01272 	BRA   m034
                  01273 			;                }
                  01274 			;            }
                  01275 			;        }
                  01276 			;       #endif
                  01277 			;    }
                  01278 			;    goto SET_SIGN;
                  01279 			;
                  01280 			;//  UNDERFLOW:
                  01281 			;//    FpUnderFlow = 1;
                  01282 			;  RES0:
                  01283 			;    arg1f24.high8 = 0;
000342 0100       01284 m037	MOVLB 0
000344 6BB2       01285 	CLRF  arg1f24+2,1
                  01286 			;    goto MANTISSA;
000346 D003       01287 	BRA   m039
                  01288 			;
                  01289 			;  OVERFLOW:
                  01290 			;    FpOverflow = 1;
000348 0100       01291 m038	MOVLB 0
00034A 83D8       01292 	BSF   0xD8,FpOverflow,1
                  01293 			;    arg1f24.high8 = 0xFF;
00034C 69B2       01294 	SETF  arg1f24+2,1
                  01295 			;  MANTISSA:
                  01296 			;    arg1f24.low16 = 0x8000;
00034E 0100       01297 m039	MOVLB 0
000350 6BB0       01298 	CLRF  arg1f24,1
000352 0E80       01299 	MOVLW 128
000354 6FB1       01300 	MOVWF arg1f24+1,1
                  01301 			;
                  01302 			;  SET_SIGN:
                  01303 			;    if (!(temp & 0x80))
000356 0100       01304 m040	MOVLB 0
000358 AFBC       01305 	BTFSS temp,7,1
                  01306 			;        arg1f24.15 = 0;
00035A 9FB1       01307 	BCF   arg1f24+1,7,1
                  01308 			;
                  01309 			;  _RETURN_MF:
                  01310 			;    return arg1f24;
00035C 0100       01311 m041	MOVLB 0
00035E 51B0       01312 	MOVF  arg1f24,W,1
000360 0012       01313 	RETURN
                  01314 			;}
                  01315 			;
                  01316 			;
                  01317 			;// SUBTRACTION
                  01318 			;
                  01319 			;float24 operator- _fsub24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  01320 			;{
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 23

ADDR   CODE       LINE  SOURCE

                  01321 _fsub24
                  01322 			;    arg2f24.mid8 ^= 0x80;
000362 0E80       01323 	MOVLW 128
000364 0100       01324 	MOVLB 0
000366 1BB4       01325 	XORWF arg2f24+1,1,1
                  01326 			;    arg1f24 += arg2f24;
000368 DF55       01327 	RCALL _fadd24
                  01328 			;    return arg1f24;
00036A 0100       01329 	MOVLB 0
00036C 51B0       01330 	MOVF  arg1f24,W,1
00036E 0012       01331 	RETURN
                  01332 			;}
                  01333 			;
                  01334 			;
                  01335 			;float24 operator=( int8 arg) @
                  01336 			;float24 operator=( uns8 arg) @
                  01337 			;float24 operator=( int16 arg) @
                  01338 			;float24 operator=( uns16 arg) @
                  01339 			;float24 operator= _int24ToFloat24( sharedM int24 arg1f24)
                  01340 			;{
                  01341 _int24ToFloat24
                  01342 			;    sharedM float24 arg2f24;   // unused, but required
                  01343 			;    char expo = FpBIAS + 16 - 1;
000370 0E8E       01344 	MOVLW 142
000372 0100       01345 	MOVLB 0
000374 6FB6       01346 	MOVWF expo_2,1
                  01347 			;    char xtra = 0;
000376 6BB7       01348 	CLRF  xtra_2,1
                  01349 			;    char sign = 0;
000378 6BB8       01350 	CLRF  sign_4,1
                  01351 			;    if (arg1f24 < 0)  {
00037A AFB2       01352 	BTFSS arg1f24+2,7,1
00037C D008       01353 	BRA   m042
                  01354 			;        arg1f24 = -arg1f24;
00037E 80D8       01355 	BSF   0xFD8,Carry,0
000380 0E00       01356 	MOVLW 0
000382 57B0       01357 	SUBFWB arg1f24,1,1
000384 0E00       01358 	MOVLW 0
000386 57B1       01359 	SUBFWB arg1f24+1,1,1
000388 0E00       01360 	MOVLW 0
00038A 57B2       01361 	SUBFWB arg1f24+2,1,1
                  01362 			;        sign |= 0x80;
00038C 8FB8       01363 	BSF   sign_4,7,1
                  01364 			;    }
                  01365 			;    if (arg1f24.high8)  {
00038E 0100       01366 m042	MOVLB 0
000390 53B2       01367 	MOVF  arg1f24+2,1,1
000392 B4D8       01368 	BTFSC 0xFD8,Zero_,0
000394 D009       01369 	BRA   m043
                  01370 			;        expo += 8;
000396 0E08       01371 	MOVLW 8
000398 27B6       01372 	ADDWF expo_2,1,1
                  01373 			;        xtra = arg1f24.low8;
00039A C0B0 F0B7  01374 	MOVFF arg1f24,xtra_2
                  01375 			;        arg1f24.low8 = arg1f24.mid8;
00039E C0B1 F0B0  01376 	MOVFF arg1f24+1,arg1f24
                  01377 			;        arg1f24.mid8 = arg1f24.high8;
0003A2 C0B2 F0B1  01378 	MOVFF arg1f24+2,arg1f24+1
                  01379 			;    }
                  01380 			;    else if (!arg1f24.mid8)  {
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 24

ADDR   CODE       LINE  SOURCE

0003A6 D012       01381 	BRA   m045
0003A8 0100       01382 m043	MOVLB 0
0003AA 53B1       01383 	MOVF  arg1f24+1,1,1
0003AC A4D8       01384 	BTFSS 0xFD8,Zero_,0
0003AE D00E       01385 	BRA   m045
                  01386 			;        expo -= 8;
0003B0 0E08       01387 	MOVLW 8
0003B2 5FB6       01388 	SUBWF expo_2,1,1
                  01389 			;        W = arg1f24.low8;
0003B4 51B0       01390 	MOVF  arg1f24,W,1
                  01391 			;        if (!W)
0003B6 B4D8       01392 	BTFSC 0xFD8,Zero_,0
                  01393 			;            goto _RETURN_MF;
0003B8 D01D       01394 	BRA   m047
                  01395 			;        arg1f24.mid8 = W;
0003BA 0100       01396 	MOVLB 0
0003BC 6FB1       01397 	MOVWF arg1f24+1,1
                  01398 			;        arg1f24.low8 = 0;
0003BE 6BB0       01399 	CLRF  arg1f24,1
                  01400 			;    }
                  01401 			;
                  01402 			;    // arg1f24.mid8 != 0
                  01403 			;    goto TEST_ARG1_B15;
0003C0 D005       01404 	BRA   m045
                  01405 			;    do  {
                  01406 			;        xtra = rl( xtra);
0003C2 0100       01407 m044	MOVLB 0
0003C4 37B7       01408 	RLCF  xtra_2,1,1
                  01409 			;        arg1f24.low16 = rl( arg1f24.low16);
0003C6 37B0       01410 	RLCF  arg1f24,1,1
0003C8 37B1       01411 	RLCF  arg1f24+1,1,1
                  01412 			;        expo --;
0003CA 07B6       01413 	DECF  expo_2,1,1
                  01414 			;      TEST_ARG1_B15:
                  01415 			;    } while (!arg1f24.15);
0003CC 0100       01416 m045	MOVLB 0
0003CE AFB1       01417 	BTFSS arg1f24+1,7,1
0003D0 D7F8       01418 	BRA   m044
                  01419 			;
                  01420 			;   #ifndef DISABLE_ROUNDING
                  01421 			;    if (FpRounding && (xtra & 0x80))  {
0003D2 ADD8       01422 	BTFSS 0xD8,FpRounding,1
0003D4 D00A       01423 	BRA   m046
0003D6 AFB7       01424 	BTFSS xtra_2,7,1
0003D8 D008       01425 	BRA   m046
                  01426 			;        arg1f24.low8 += 1;
0003DA 3FB0       01427 	INCFSZ arg1f24,1,1
                  01428 			;        if (!arg1f24.low8)  {
0003DC D006       01429 	BRA   m046
                  01430 			;            arg1f24.mid8 += 1;
0003DE 3FB1       01431 	INCFSZ arg1f24+1,1,1
                  01432 			;            if (!arg1f24.mid8)  {
0003E0 D004       01433 	BRA   m046
                  01434 			;                Carry = 1;
0003E2 80D8       01435 	BSF   0xFD8,Carry,0
                  01436 			;                arg1f24.low16 = rr( arg1f24.low16);
0003E4 33B1       01437 	RRCF  arg1f24+1,1,1
0003E6 33B0       01438 	RRCF  arg1f24,1,1
                  01439 			;                expo ++;
0003E8 2BB6       01440 	INCF  expo_2,1,1
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 25

ADDR   CODE       LINE  SOURCE

                  01441 			;            }
                  01442 			;        }
                  01443 			;    }
                  01444 			;   #endif
                  01445 			;
                  01446 			;    arg1f24.high8 = expo;
0003EA C0B6 F0B2  01447 m046	MOVFF expo_2,arg1f24+2
                  01448 			;    if (!(sign & 0x80))
0003EE 0100       01449 	MOVLB 0
0003F0 AFB8       01450 	BTFSS sign_4,7,1
                  01451 			;        arg1f24.15 = 0;
0003F2 9FB1       01452 	BCF   arg1f24+1,7,1
                  01453 			;
                  01454 			;  _RETURN_MF:
                  01455 			;    float24 rval @ arg1f24;
                  01456 			;    rval.low24 = arg1f24.low24;
                  01457 			;    return rval;
0003F4 0100       01458 m047	MOVLB 0
0003F6 51B0       01459 	MOVF  rval,W,1
0003F8 0012       01460 	RETURN
                  01461 			;}
                  01462 			;
                  01463 			;
                  01464 			;float24 operator=( uns24 arg) @
                  01465 			;float24 operator= _int32ToFloat24( int32 arg32)
                  01466 			;{
                  01467 _int32ToFloat24
                  01468 			;    char expo = FpBIAS + 16 - 1;
                  01469 			;    char xtra @ arg32.high8;
                  01470 			;    char sign = 0;
                  01471 			;    if (arg32 < 0)  {
                  01472 			;        arg32 = -arg32;
                  01473 			;        sign |= 0x80;
                  01474 			;    }
                  01475 			;    if (arg32.high8)  {
                  01476 			;        expo += 8;
                  01477 			;        arg32.low8 = arg32.midL8;
                  01478 			;        arg32.midL8 = arg32.midH8;
                  01479 			;        arg32.midH8 = arg32.high8;
                  01480 			;        arg32.high8 = 0;
                  01481 			;    }
                  01482 			;    if (arg32.midH8)  {
                  01483 			;        expo += 8;
                  01484 			;        xtra = arg32.low8;
                  01485 			;        arg32.low8 = arg32.midL8;
                  01486 			;        arg32.midL8 = arg32.midH8;
                  01487 			;    }
                  01488 			;    else if (!arg32.midL8)  {
                  01489 			;        expo -= 8;
                  01490 			;        W = arg32.low8;
                  01491 			;        if (!W)
                  01492 			;            goto _RETURN_MF;
                  01493 			;        arg32.midL8 = W;
                  01494 			;        arg32.low8 = 0;
                  01495 			;    }
                  01496 			;
                  01497 			;    // arg32.midL8 != 0
                  01498 			;    goto TEST_ARG_B15;
                  01499 			;    do  {
                  01500 			;        xtra = rl( xtra);
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 26

ADDR   CODE       LINE  SOURCE

                  01501 			;        arg32.low16 = rl( arg32.low16);
                  01502 			;        expo --;
                  01503 			;      TEST_ARG_B15:
                  01504 			;    } while (!arg32.15);
                  01505 			;
                  01506 			;   #ifndef DISABLE_ROUNDING
                  01507 			;    if (FpRounding && (xtra & 0x80))  {
                  01508 			;        arg32.low8 += 1;
                  01509 			;        if (!arg32.low8)  {
                  01510 			;            arg32.midL8 += 1;
                  01511 			;            if (!arg32.midL8)  {
                  01512 			;                Carry = 1;
                  01513 			;                arg32.low16 = rr( arg32.low16);
                  01514 			;                expo ++;
                  01515 			;            }
                  01516 			;        }
                  01517 			;    }
                  01518 			;   #endif
                  01519 			;
                  01520 			;    arg32.midH8 = expo;
                  01521 			;    if (!(sign & 0x80))
                  01522 			;        arg32.15 = 0;
                  01523 			;
                  01524 			;  _RETURN_MF:
                  01525 			;    float24 rval @ arg32;
                  01526 			;    rval.low24 = arg32.low24;
                  01527 			;    return rval;
                  01528 			;}
                  01529 			;
                  01530 			;
                  01531 			;uns8 operator=( sharedM float24 arg1f24) @
                  01532 			;int8 operator=( sharedM float24 arg1f24) @
                  01533 			;uns16 operator=( sharedM float24 arg1f24) @
                  01534 			;int16 operator=( sharedM float24 arg1f24) @
                  01535 			;int24 operator= _float24ToInt24( sharedM float24 arg1f24)
                  01536 			;{
                  01537 _float24ToInt24
                  01538 			;    sharedM float24 arg2f24;   // unused, but required
                  01539 			;    char sign = arg1f24.mid8;
0003FA C0B1 F0B6  01540 	MOVFF arg1f24+1,sign_6
                  01541 			;    char expo = arg1f24.high8 - (FpBIAS-1);
0003FE 0E7E       01542 	MOVLW 126
000400 0100       01543 	MOVLB 0
000402 5DB2       01544 	SUBWF arg1f24+2,W,1
000404 6FB7       01545 	MOVWF expo_4,1
                  01546 			;    if (!Carry)
000406 A0D8       01547 	BTFSS 0xFD8,Carry,0
                  01548 			;        goto RES0;
000408 D032       01549 	BRA   m053
                  01550 			;    arg1f24.15 = 1;
00040A 0100       01551 	MOVLB 0
00040C 8FB1       01552 	BSF   arg1f24+1,7,1
                  01553 			;
                  01554 			;    arg1f24.high8 = 0;
00040E 6BB2       01555 	CLRF  arg1f24+2,1
                  01556 			;   #ifndef DISABLE_ROUNDING
                  01557 			;    char xtra = 0;
000410 6BB8       01558 	CLRF  xtra_4,1
                  01559 			;   #endif
                  01560 			;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 27

ADDR   CODE       LINE  SOURCE

                  01561 			;    // (a): expo = 0..8 : shift 1 byte to the right
                  01562 			;    // (b): expo = 9..16: shift 0 byte
                  01563 			;    // (c): expo = 17..24: shift 1 byte to the left
                  01564 			;   #if __CoreSet__ / 100 == 12
                  01565 			;    expo -= 17;
                  01566 			;    expo = 0xFF - expo;  // COMF (Carry unchanged)
                  01567 			;    if (Carry)  {  // (c)
                  01568 			;   #else
                  01569 			;    expo = 16 - expo;
000412 51B7       01570 	MOVF  expo_4,W,1
000414 0810       01571 	SUBLW 16
000416 6FB7       01572 	MOVWF expo_4,1
                  01573 			;    if (!Carry)  {  // (c)
000418 B0D8       01574 	BTFSC 0xFD8,Carry,0
00041A D00B       01575 	BRA   m048
                  01576 			;   #endif
                  01577 			;        expo += 8;
00041C 0E08       01578 	MOVLW 8
00041E 27B7       01579 	ADDWF expo_4,1,1
                  01580 			;        if (!Carry)
000420 A0D8       01581 	BTFSS 0xFD8,Carry,0
                  01582 			;            goto OVERFLOW;
000422 D021       01583 	BRA   m052
                  01584 			;        arg1f24.high8 = arg1f24.mid8;
000424 C0B1 F0B2  01585 	MOVFF arg1f24+1,arg1f24+2
                  01586 			;        arg1f24.mid8 = arg1f24.low8;
000428 C0B0 F0B1  01587 	MOVFF arg1f24,arg1f24+1
                  01588 			;        arg1f24.low8 = 0;
00042C 0100       01589 	MOVLB 0
00042E 6BB0       01590 	CLRF  arg1f24,1
                  01591 			;    }
                  01592 			;    else  {  // (a) (b)
000430 D00B       01593 	BRA   m049
                  01594 			;        // expo = 0 .. 16
                  01595 			;        W = expo - 8;
000432 0E08       01596 m048	MOVLW 8
000434 0100       01597 	MOVLB 0
000436 5DB7       01598 	SUBWF expo_4,W,1
                  01599 			;        if (Carry)  {  // (a)
000438 A0D8       01600 	BTFSS 0xFD8,Carry,0
00043A D006       01601 	BRA   m049
                  01602 			;            expo = W;
00043C 6FB7       01603 	MOVWF expo_4,1
                  01604 			;           #ifndef DISABLE_ROUNDING
                  01605 			;            xtra = arg1f24.low8;
00043E C0B0 F0B8  01606 	MOVFF arg1f24,xtra_4
                  01607 			;           #endif
                  01608 			;            arg1f24.low8 = arg1f24.mid8;
000442 C0B1 F0B0  01609 	MOVFF arg1f24+1,arg1f24
                  01610 			;            arg1f24.mid8 = 0;
000446 6BB1       01611 	CLRF  arg1f24+1,1
                  01612 			;        }
                  01613 			;    }
                  01614 			;    if (expo)  {
000448 0100       01615 m049	MOVLB 0
00044A 53B7       01616 	MOVF  expo_4,1,1
00044C B4D8       01617 	BTFSC 0xFD8,Zero_,0
00044E D008       01618 	BRA   m051
                  01619 			;        do  {
                  01620 			;            Carry = 0;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 28

ADDR   CODE       LINE  SOURCE

000450 90D8       01621 m050	BCF   0xFD8,Carry,0
                  01622 			;            arg1f24.high8 = rr( arg1f24.high8);
000452 0100       01623 	MOVLB 0
000454 33B2       01624 	RRCF  arg1f24+2,1,1
                  01625 			;            arg1f24.low16 = rr( arg1f24.low16);
000456 33B1       01626 	RRCF  arg1f24+1,1,1
000458 33B0       01627 	RRCF  arg1f24,1,1
                  01628 			;           #ifndef DISABLE_ROUNDING
                  01629 			;            xtra = rr( xtra);
00045A 33B8       01630 	RRCF  xtra_4,1,1
                  01631 			;           #endif
                  01632 			;        } while (--expo);
00045C 2FB7       01633 	DECFSZ expo_4,1,1
00045E D7F8       01634 	BRA   m050
                  01635 			;    }
                  01636 			;    if (arg1f24.23)  {
000460 0100       01637 m051	MOVLB 0
000462 AFB2       01638 	BTFSS arg1f24+2,7,1
000464 D00B       01639 	BRA   m055
                  01640 			;       OVERFLOW:
                  01641 			;        FpOverflow = 1;
000466 0100       01642 m052	MOVLB 0
000468 83D8       01643 	BSF   0xD8,FpOverflow,1
                  01644 			;        W = 0xFF;
00046A 0EFF       01645 	MOVLW 255
                  01646 			;        goto ASSIGNW;
00046C D001       01647 	BRA   m054
                  01648 			;       RES0:
                  01649 			;        W = 0;
00046E 0E00       01650 m053	MOVLW 0
                  01651 			;       ASSIGNW:
                  01652 			;        arg1f24.low8 = W;
000470 0100       01653 m054	MOVLB 0
000472 6FB0       01654 	MOVWF arg1f24,1
                  01655 			;        arg1f24.mid8 = W;
000474 6FB1       01656 	MOVWF arg1f24+1,1
                  01657 			;        arg1f24.high8 = W;
000476 6FB2       01658 	MOVWF arg1f24+2,1
                  01659 			;        arg1f24.23 = 0;
000478 9FB2       01660 	BCF   arg1f24+2,7,1
                  01661 			;    }
                  01662 			;    else  {
00047A D011       01663 	BRA   m057
                  01664 			;       #ifndef DISABLE_ROUNDING
                  01665 			;        if (FpRounding && (xtra & 0x80))  {
00047C 0100       01666 m055	MOVLB 0
00047E ADD8       01667 	BTFSS 0xD8,FpRounding,1
000480 D004       01668 	BRA   m056
000482 AFB8       01669 	BTFSS xtra_4,7,1
000484 D002       01670 	BRA   m056
                  01671 			;            arg1f24.low8 += 1;
000486 4BB0       01672 	INFSNZ arg1f24,1,1
                  01673 			;            if (!arg1f24.low8)
                  01674 			;                arg1f24.mid8 += 1;
000488 2BB1       01675 	INCF  arg1f24+1,1,1
                  01676 			;        }
                  01677 			;       #endif
                  01678 			;        if (sign & 0x80)
00048A 0100       01679 m056	MOVLB 0
00048C AFB6       01680 	BTFSS sign_6,7,1
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 29

ADDR   CODE       LINE  SOURCE

00048E D007       01681 	BRA   m057
                  01682 			;            arg1f24.low24 = -arg1f24.low24;
000490 80D8       01683 	BSF   0xFD8,Carry,0
000492 0E00       01684 	MOVLW 0
000494 57B0       01685 	SUBFWB arg1f24,1,1
000496 0E00       01686 	MOVLW 0
000498 57B1       01687 	SUBFWB arg1f24+1,1,1
00049A 0E00       01688 	MOVLW 0
00049C 57B2       01689 	SUBFWB arg1f24+2,1,1
                  01690 			;    }
                  01691 			;    int24 rval @ arg1f24;
                  01692 			;    rval = arg1f24.low24;
                  01693 			;    return rval;
00049E 0100       01694 m057	MOVLB 0
0004A0 51B0       01695 	MOVF  rval_3,W,1
0004A2 0012       01696 	RETURN
                  01697 			;}
                  01698 			;
                  01699 			;
                  01700 			;bit operator< _f24_LT_f24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  01701 			;{
                  01702 _f24_LT_f24
                  01703 			;    Carry = 0;
                  01704 			;    if (!(arg1f24.high8 | arg2f24.high8))
                  01705 			;        return Carry;
                  01706 			;    if (!arg1f24.15)  {
                  01707 			;        if (arg2f24.15)
                  01708 			;            return Carry;
                  01709 			;        W = arg1f24.low8 - arg2f24.low8;
                  01710 			;        genSubW( arg1f24.mid8, arg2f24.mid8);
                  01711 			;        genSubW( arg1f24.high8, arg2f24.high8);
                  01712 			;        goto _RETURN_MF;
                  01713 			;    }
                  01714 			;    if (!arg2f24.15)
                  01715 			;        goto _RETURN_MF;
                  01716 			;    W = arg2f24.low8 - arg1f24.low8;
                  01717 			;    genSubW( arg2f24.mid8, arg1f24.mid8);
                  01718 			;    genSubW( arg2f24.high8, arg1f24.high8);
                  01719 			;  _RETURN_MF:
                  01720 			;    if (Carry)
                  01721 			;        return 0;
                  01722 			;    return 1;
                  01723 			;}
                  01724 			;
                  01725 			;
                  01726 			;bit operator>= _f24_GE_f24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  01727 			;{
                  01728 _f24_GE_f24
                  01729 			;    Carry = 1;
                  01730 			;    if (!(arg1f24.high8 | arg2f24.high8))
                  01731 			;        return Carry;
                  01732 			;    if (!arg1f24.15)  {
                  01733 			;        if (arg2f24.15)
                  01734 			;            return Carry;
                  01735 			;        W = arg1f24.low8 - arg2f24.low8;
                  01736 			;        genSubW( arg1f24.mid8, arg2f24.mid8);
                  01737 			;        genSubW( arg1f24.high8, arg2f24.high8);
                  01738 			;        return Carry;
                  01739 			;    }
                  01740 			;    Carry = 0;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 30

ADDR   CODE       LINE  SOURCE

                  01741 			;    if (!arg2f24.15)
                  01742 			;        return Carry;
                  01743 			;    W = arg2f24.low8 - arg1f24.low8;
                  01744 			;    genSubW( arg2f24.mid8, arg1f24.mid8);
                  01745 			;    genSubW( arg2f24.high8, arg1f24.high8);
                  01746 			;    return Carry;
                  01747 			;}
                  01748 			;
                  01749 			;
                  01750 			;
                  01751 			;bit operator> _f24_GT_f24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  01752 			;{
                  01753 _f24_GT_f24
                  01754 			;    Carry = 0;
                  01755 			;    if (!(arg1f24.high8 | arg2f24.high8))
                  01756 			;        return Carry;
                  01757 			;    if (!arg1f24.15)  {
                  01758 			;        if (arg2f24.15)
                  01759 			;            goto _RETURN_MF;
                  01760 			;        W = arg2f24.low8 - arg1f24.low8;
                  01761 			;        genSubW( arg2f24.mid8, arg1f24.mid8);
                  01762 			;        genSubW( arg2f24.high8, arg1f24.high8);
                  01763 			;        goto _RETURN_MF;
                  01764 			;    }
                  01765 			;    if (!arg2f24.15)
                  01766 			;        return Carry;
                  01767 			;    W = arg1f24.low8 - arg2f24.low8;
                  01768 			;    genSubW( arg1f24.mid8, arg2f24.mid8);
                  01769 			;    genSubW( arg1f24.high8, arg2f24.high8);
                  01770 			;  _RETURN_MF:
                  01771 			;    if (Carry)
                  01772 			;        return 0;
                  01773 			;    return 1;
                  01774 			;}
                  01775 			;
                  01776 			;
                  01777 			;
                  01778 			;bit operator<= _f24_LE_f24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  01779 			;{
                  01780 _f24_LE_f24
                  01781 			;    Carry = 1;
                  01782 			;    if (!(arg1f24.high8 | arg2f24.high8))
                  01783 			;        return Carry;
                  01784 			;    if (!arg1f24.15)  {
                  01785 			;        Carry = 0;
                  01786 			;        if (arg2f24.15)
                  01787 			;            return Carry;
                  01788 			;        W = arg2f24.low8 - arg1f24.low8;
                  01789 			;        genSubW( arg2f24.mid8, arg1f24.mid8);
                  01790 			;        genSubW( arg2f24.high8, arg1f24.high8);
                  01791 			;        return Carry;
                  01792 			;    }
                  01793 			;    if (!arg2f24.15)
                  01794 			;        return Carry;
                  01795 			;    W = arg1f24.low8 - arg2f24.low8;
                  01796 			;    genSubW( arg1f24.mid8, arg2f24.mid8);
                  01797 			;    genSubW( arg1f24.high8, arg2f24.high8);
                  01798 			;    return Carry;
                  01799 
                  01800   ; FILE C:\PIC\CC8E\MATH16.H
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 31

ADDR   CODE       LINE  SOURCE

                  01801 			;// SIZE
                  01802 			;
                  01803 			;#pragma library 1
                  01804 			;/*
                  01805 			;uns16 operator* _mult8x8( uns8 arg1, uns8 arg2);
                  01806 			;uns16 operator* _multU16x8( uns16 arg1, uns8 arg2);
                  01807 			;uns16 operator* _mult16x16( uns16 arg1, uns16 arg2);
                  01808 			;uns16 operator/ _divU16_8( uns16 arg1, uns8 arg2);
                  01809 			;uns16 operator/ _divU16_16( uns16 arg1, uns16 arg2);
                  01810 			;int16 operator/ _divS16_8( int16 arg1, int8 arg2);
                  01811 			;int16 operator/ _divS16_16( int16 arg1, int16 arg2);
                  01812 			;uns8 operator% _remU16_8( uns16 arg1, uns8 arg2);
                  01813 			;uns16 operator% _remU16_16( uns16 arg1, uns16 arg2);
                  01814 			;int8 operator% _remS16_8( int16 arg1, int8 arg2);
                  01815 			;int16 operator% _remS16_16( int16 arg1, int16 arg2);
                  01816 			;*/
                  01817 			;
                  01818 			;#if __CoreSet__ < 1600
                  01819 			; #define genAdd(r,a) W=a; btsc(Carry); W=incsz(a); r+=W
                  01820 			; #define genSub(r,a) W=a; btss(Carry); W=incsz(a); r-=W
                  01821 			; #define genAddW(r,a) W=a; btsc(Carry); W=incsz(a); W=r+W
                  01822 			; #define genSubW(r,a) W=a; btss(Carry); W=incsz(a); W=r-W
                  01823 			;#else
                  01824 			; #define genAdd(r,a) W=a; r=addWFC(r)
                  01825 			; #define genSub(r,a) W=a; r=subWFB(r)
                  01826 			; #define genAddW(r,a) W=a; W=addWFC(r)
                  01827 			; #define genSubW(r,a) W=a; W=subWFB(r)
                  01828 			;#endif
                  01829 			;
                  01830 			;#if __CoreSet__ == 1700 || __CoreSet__ == 1800
                  01831 			; #define hw_mult8x8(a,b)  W = a; multiply(b)
                  01832 			; #define loRES PRODL
                  01833 			; #define hiRES PRODH
                  01834 			;#endif
                  01835 			;
                  01836 			;#if __CoreSet__ == 2000
                  01837 			; #define hw_mult8x8(a,b)  W = a; multiply(b)
                  01838 			; #define loRES W
                  01839 			; #define hiRES MULH
                  01840 			;#endif
                  01841 			;
                  01842 			;
                  01843 			;
                  01844 			;#ifdef hw_mult8x8
                  01845 			;
                  01846 			;inline int16 operator*( int8 arg1, int8 arg2);
                  01847 			;inline uns16 operator*( uns8 arg1, uns8 arg2);
                  01848 			;inline int16 operator*( int8 arg1, int16 arg2);
                  01849 			;inline uns16 operator*( uns8 arg1, uns16 arg2);
                  01850 			;inline int16 operator*( int16 arg1, int8 arg2);
                  01851 			;inline uns16 operator*( uns16 arg1, uns8 arg2);
                  01852 			;inline int16 operator*( int16 arg1, int16 arg2);
                  01853 			;inline uns16 operator*( uns16 arg1, uns16 arg2);
                  01854 			;
                  01855 			;#undef hw_mult8x8
                  01856 			;#undef loRES
                  01857 			;#undef hiRES
                  01858 			;
                  01859 			;#else
                  01860 			;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 32

ADDR   CODE       LINE  SOURCE

                  01861 			;int8 operator*( int8 arg1, int8 arg2)  @
                  01862 			;
                  01863 			;uns16 operator* _mult8x8( uns8 arg1, uns8 arg2)
                  01864 			;{
                  01865 			;    uns16 rval;
                  01866 			;    char counter = sizeof(arg2)*8;
                  01867 			;    rval.high8 = 0;
                  01868 			;    W = arg1;
                  01869 			;    do  {
                  01870 			;        arg2 = rr( arg2);
                  01871 			;        if (Carry)
                  01872 			;            rval.high8 += W;
                  01873 			;        rval = rr( rval);
                  01874 			;        counter = decsz(counter);
                  01875 			;    } while (1);
                  01876 			;    return rval;
                  01877 			;}
                  01878 			;
                  01879 			;
                  01880 			;uns16 operator*( uns8 arg1, uns16 arg2) exchangeArgs @
                  01881 			;
                  01882 			;uns16 operator* _multU16x8( uns16 arg1, uns8 arg2)
                  01883 			;{
                  01884 			;    uns16 rval;
                  01885 			;    uns8 rvalH = 0;
                  01886 			;    char counter = sizeof(arg1)*8;
                  01887 			;    W = arg2;
                  01888 			;    do  {
                  01889 			;        arg1 = rr( arg1);
                  01890 			;        if (Carry)
                  01891 			;            rvalH += W;
                  01892 			;        rvalH = rr(rvalH);
                  01893 			;        rval = rr(rval);
                  01894 			;        counter = decsz(counter);
                  01895 			;    } while (1);
                  01896 			;    return rval;
                  01897 			;}
                  01898 			;
                  01899 			;
                  01900 			;int16 operator*( int16 arg1, int16 arg2) @
                  01901 			;
                  01902 			;uns16 operator* _mult16x16( uns16 arg1, uns16 arg2)
                  01903 			;{
                  01904 			;    uns16 rval;
                  01905 			;    char counter = sizeof(arg1)*8;
                  01906 			;    do  {
                  01907 			;        Carry = 0;
                  01908 			;        rval = rl( rval);
                  01909 			;        arg1 = rl( arg1);
                  01910 			;        if (Carry)
                  01911 			;            rval += arg2;
                  01912 			;        counter = decsz(counter);
                  01913 			;    } while (1);
                  01914 			;    return rval;
                  01915 			;}
                  01916 			;
                  01917 			;#endif
                  01918 			;
                  01919 			;
                  01920 			;uns16 operator/ _divU16_8( uns16 arg1, uns8 arg2)
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 33

ADDR   CODE       LINE  SOURCE

                  01921 			;{
                  01922 _divU16_8
0004A4 0100       01923 	MOVLB 0
0004A6 6FC6       01924 	MOVWF arg2,1
                  01925 			;    uns8 rm = 0;
0004A8 6BC7       01926 	CLRF  rm,1
                  01927 			;    char counter = sizeof(arg1)*8+1;
0004AA 0E11       01928 	MOVLW 17
0004AC 6FC8       01929 	MOVWF counter_2,1
                  01930 			;    goto ENTRY_ML;
0004AE D00B       01931 	BRA   m059
                  01932 			;    do  {
                  01933 			;        rm = rl( rm);
0004B0 0100       01934 m058	MOVLB 0
0004B2 37C7       01935 	RLCF  rm,1,1
                  01936 			;        uns8 tmp = rl( tmp);
0004B4 37C9       01937 	RLCF  tmp,1,1
                  01938 			;        W = rm - arg2;
0004B6 51C6       01939 	MOVF  arg2,W,1
0004B8 5DC7       01940 	SUBWF rm,W,1
                  01941 			;        if (tmp&1)
0004BA B1C9       01942 	BTFSC tmp,0,1
                  01943 			;            Carry = 1;
0004BC 80D8       01944 	BSF   0xFD8,Carry,0
                  01945 			;        if (Carry)
0004BE A0D8       01946 	BTFSS 0xFD8,Carry,0
0004C0 D002       01947 	BRA   m059
                  01948 			;            rm = W;
0004C2 0100       01949 	MOVLB 0
0004C4 6FC7       01950 	MOVWF rm,1
                  01951 			;       ENTRY_ML:
                  01952 			;        arg1 = rl( arg1);
0004C6 0100       01953 m059	MOVLB 0
0004C8 37C4       01954 	RLCF  arg1,1,1
0004CA 37C5       01955 	RLCF  arg1+1,1,1
                  01956 			;        counter = decsz(counter);
0004CC 2FC8       01957 	DECFSZ counter_2,1,1
                  01958 			;    } while (1);
0004CE D7F0       01959 	BRA   m058
                  01960 			;    return arg1;
0004D0 51C4       01961 	MOVF  arg1,W,1
0004D2 0012       01962 	RETURN
                  01963 			;}
                  01964 			;
                  01965 			;
                  01966 			;uns16 operator/ _divU16_16( uns16 arg1, uns16 arg2)
                  01967 			;{
                  01968 _divU16_16
                  01969 			;    uns16 rm = 0;
0004D4 0100       01970 	MOVLB 0
0004D6 6BC8       01971 	CLRF  rm_2,1
0004D8 6BC9       01972 	CLRF  rm_2+1,1
                  01973 			;    char counter = sizeof(arg1)*8+1;
0004DA 0E11       01974 	MOVLW 17
0004DC 6FCA       01975 	MOVWF counter_3,1
                  01976 			;    goto ENTRY_ML;
0004DE D00E       01977 	BRA   m061
                  01978 			;    do  {
                  01979 			;        rm = rl( rm);
0004E0 0100       01980 m060	MOVLB 0
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 34

ADDR   CODE       LINE  SOURCE

0004E2 37C8       01981 	RLCF  rm_2,1,1
0004E4 37C9       01982 	RLCF  rm_2+1,1,1
                  01983 			;        W = rm.low8 - arg2.low8;
0004E6 51C6       01984 	MOVF  arg2_2,W,1
0004E8 5DC8       01985 	SUBWF rm_2,W,1
                  01986 			;        genSubW( rm.high8, arg2.high8);
0004EA 51C7       01987 	MOVF  arg2_2+1,W,1
0004EC 59C9       01988 	SUBWFB rm_2+1,W,1
                  01989 			;        if (!Carry)
0004EE A0D8       01990 	BTFSS 0xFD8,Carry,0
                  01991 			;            goto ENTRY_ML;
0004F0 D005       01992 	BRA   m061
                  01993 			;        rm.high8 = W;
0004F2 0100       01994 	MOVLB 0
0004F4 6FC9       01995 	MOVWF rm_2+1,1
                  01996 			;        rm.low8 -= arg2.low8;
0004F6 51C6       01997 	MOVF  arg2_2,W,1
0004F8 5FC8       01998 	SUBWF rm_2,1,1
                  01999 			;        Carry = 1;
0004FA 80D8       02000 	BSF   0xFD8,Carry,0
                  02001 			;       ENTRY_ML:
                  02002 			;        arg1 = rl( arg1);
0004FC 0100       02003 m061	MOVLB 0
0004FE 37C4       02004 	RLCF  arg1_2,1,1
000500 37C5       02005 	RLCF  arg1_2+1,1,1
                  02006 			;        counter = decsz(counter);
000502 2FCA       02007 	DECFSZ counter_3,1,1
                  02008 			;    } while (1);
000504 D7ED       02009 	BRA   m060
                  02010 			;    return arg1;
000506 51C4       02011 	MOVF  arg1_2,W,1
000508 0012       02012 	RETURN
                  02013 			;}
                  02014 			;
                  02015 			;
                  02016 			;int8  operator/ (int8 arg1, int8 arg2) @
                  02017 			;
                  02018 			;int16 operator/ _divS16_8( int16 arg1, int8 arg2)
                  02019 			;{
                  02020 _divS16_8
                  02021 			;    uns8 rm = 0;
                  02022 			;    char counter = 16+1;
                  02023 			;    char sign = arg1.high8 ^ arg2.high8;
                  02024 			;    if (arg1 < 0)  {
                  02025 			;       INVERT_ML:
                  02026 			;        arg1 = -arg1;
                  02027 			;        if (!counter)
                  02028 			;            return arg1;
                  02029 			;    }
                  02030 			;    if (arg2 < 0)
                  02031 			;        arg2 = -arg2;
                  02032 			;    goto ENTRY_ML;
                  02033 			;    do  {
                  02034 			;        rm = rl( rm);
                  02035 			;        W = rm - arg2;
                  02036 			;        if (Carry)
                  02037 			;            rm = W;
                  02038 			;       ENTRY_ML:
                  02039 			;        arg1 = rl( arg1);
                  02040 			;        counter = decsz(counter);
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 35

ADDR   CODE       LINE  SOURCE

                  02041 			;    } while (1);
                  02042 			;    if (sign & 0x80)
                  02043 			;        goto INVERT_ML;
                  02044 			;    return arg1;
                  02045 			;}
                  02046 			;
                  02047 			;
                  02048 			;int16 operator/ _divS16_16( int16 arg1, int16 arg2)
                  02049 			;{
                  02050 _divS16_16
                  02051 			;    uns16 rm = 0;
                  02052 			;    char counter = sizeof(arg1)*8+1;
                  02053 			;    char sign = arg1.high8 ^ arg2.high8;
                  02054 			;    if (arg1 < 0)  {
                  02055 			;       INVERT_ML:
                  02056 			;        arg1 = -arg1;
                  02057 			;        if (!counter)
                  02058 			;            return arg1;
                  02059 			;    }
                  02060 			;    if (arg2 < 0)
                  02061 			;        arg2 = -arg2;
                  02062 			;    goto ENTRY_ML;
                  02063 			;    do  {
                  02064 			;        rm = rl( rm);
                  02065 			;        W = rm.low8 - arg2.low8;
                  02066 			;        genSubW( rm.high8, arg2.high8);
                  02067 			;        if (!Carry)
                  02068 			;            goto ENTRY_ML;
                  02069 			;        rm.high8 = W;
                  02070 			;        rm.low8 -= arg2.low8;
                  02071 			;        Carry = 1;
                  02072 			;       ENTRY_ML:
                  02073 			;        arg1 = rl( arg1);
                  02074 			;        counter = decsz(counter);
                  02075 			;    } while (1);
                  02076 			;    if (sign & 0x80)
                  02077 			;        goto INVERT_ML;
                  02078 			;    return arg1;
                  02079 			;}
                  02080 			;
                  02081 			;
                  02082 			;uns8 operator% _remU16_8( uns16 arg1, uns8 arg2)
                  02083 			;{
                  02084 _remU16_8
00050A 0100       02085 	MOVLB 0
00050C 6FC6       02086 	MOVWF arg2_5,1
                  02087 			;    uns8 rm = 0;
00050E 6BC7       02088 	CLRF  rm_5,1
                  02089 			;    char counter = sizeof(arg1)*8;
000510 0E10       02090 	MOVLW 16
000512 6FC8       02091 	MOVWF counter_6,1
                  02092 			;    do  {
                  02093 			;        arg1 = rl( arg1);
000514 0100       02094 m062	MOVLB 0
000516 37C4       02095 	RLCF  arg1_5,1,1
000518 37C5       02096 	RLCF  arg1_5+1,1,1
                  02097 			;        rm = rl( rm);
00051A 37C7       02098 	RLCF  rm_5,1,1
                  02099 			;        uns8 tmp = rl( tmp);
00051C 37C9       02100 	RLCF  tmp_2,1,1
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 36

ADDR   CODE       LINE  SOURCE

                  02101 			;        W = rm - arg2;
00051E 51C6       02102 	MOVF  arg2_5,W,1
000520 5DC7       02103 	SUBWF rm_5,W,1
                  02104 			;        if (tmp&1)
000522 B1C9       02105 	BTFSC tmp_2,0,1
                  02106 			;            Carry = 1;
000524 80D8       02107 	BSF   0xFD8,Carry,0
                  02108 			;        if (Carry)
000526 A0D8       02109 	BTFSS 0xFD8,Carry,0
000528 D002       02110 	BRA   m063
                  02111 			;            rm = W;
00052A 0100       02112 	MOVLB 0
00052C 6FC7       02113 	MOVWF rm_5,1
                  02114 			;        counter = decsz(counter);
00052E 0100       02115 m063	MOVLB 0
000530 2FC8       02116 	DECFSZ counter_6,1,1
                  02117 			;    } while (1);
000532 D7F0       02118 	BRA   m062
                  02119 			;    return rm;
000534 51C7       02120 	MOVF  rm_5,W,1
000536 0012       02121 	RETURN
                  02122 			;}
                  02123 			;
                  02124 			;
                  02125 			;uns16 operator% _remU16_16( uns16 arg1, uns16 arg2)
                  02126 			;{
                  02127 _remU16_16
                  02128 			;    uns16 rm = 0;
000538 0100       02129 	MOVLB 0
00053A 6BC8       02130 	CLRF  rm_6,1
00053C 6BC9       02131 	CLRF  rm_6+1,1
                  02132 			;    char counter = sizeof(arg1)*8;
00053E 0E10       02133 	MOVLW 16
000540 6FCA       02134 	MOVWF counter_7,1
                  02135 			;    do  {
                  02136 			;        arg1 = rl( arg1);
000542 0100       02137 m064	MOVLB 0
000544 37C4       02138 	RLCF  arg1_6,1,1
000546 37C5       02139 	RLCF  arg1_6+1,1,1
                  02140 			;        rm = rl( rm);
000548 37C8       02141 	RLCF  rm_6,1,1
00054A 37C9       02142 	RLCF  rm_6+1,1,1
                  02143 			;        W = rm.low8 - arg2.low8;
00054C 51C6       02144 	MOVF  arg2_6,W,1
00054E 5DC8       02145 	SUBWF rm_6,W,1
                  02146 			;        genSubW( rm.high8, arg2.high8);
000550 51C7       02147 	MOVF  arg2_6+1,W,1
000552 59C9       02148 	SUBWFB rm_6+1,W,1
                  02149 			;        if (!Carry)
000554 A0D8       02150 	BTFSS 0xFD8,Carry,0
                  02151 			;            goto NOSUB;
000556 D004       02152 	BRA   m065
                  02153 			;        rm.high8 = W;
000558 0100       02154 	MOVLB 0
00055A 6FC9       02155 	MOVWF rm_6+1,1
                  02156 			;        rm.low8 -= arg2.low8;
00055C 51C6       02157 	MOVF  arg2_6,W,1
00055E 5FC8       02158 	SUBWF rm_6,1,1
                  02159 			;      NOSUB:
                  02160 			;        counter = decsz(counter);
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 37

ADDR   CODE       LINE  SOURCE

000560 0100       02161 m065	MOVLB 0
000562 2FCA       02162 	DECFSZ counter_7,1,1
                  02163 			;    } while (1);
000564 D7EE       02164 	BRA   m064
                  02165 			;    return rm;
000566 51C8       02166 	MOVF  rm_6,W,1
000568 0012       02167 	RETURN
                  02168 			;}
                  02169 			;
                  02170 			;
                  02171 			;int8 operator% (int8 arg1, int8 arg2) @
                  02172 			;
                  02173 			;int8 operator% _remS16_8( int16 arg1, int8 arg2)
                  02174 			;{
                  02175 _remS16_8
                  02176 			;    int8 rm = 0;
                  02177 			;    char counter = 16;
                  02178 			;    char sign = arg1.high8;
                  02179 			;    if (arg1 < 0)
                  02180 			;        arg1 = -arg1;
                  02181 			;    if (arg2 < 0)
                  02182 			;        arg2 = -arg2;
                  02183 			;    do  {
                  02184 			;        arg1 = rl( arg1);
                  02185 			;        rm = rl( rm);
                  02186 			;        W = rm - arg2;
                  02187 			;        if (Carry)
                  02188 			;            rm = W;
                  02189 			;        counter = decsz(counter);
                  02190 			;    } while (1);
                  02191 			;    if (sign & 0x80)
                  02192 			;        rm = -rm;
                  02193 			;    return rm;
                  02194 			;}
                  02195 			;
                  02196 			;
                  02197 			;int16 operator% _remS16_16( int16 arg1, int16 arg2)
                  02198 			;{
                  02199 _remS16_16
                  02200 			;    int16 rm = 0;
                  02201 			;    char counter = sizeof(arg1)*8;
                  02202 			;    char sign = arg1.high8;
                  02203 			;    if (arg1 < 0)
                  02204 			;        arg1 = -arg1;
                  02205 			;    if (arg2 < 0)
                  02206 			;        arg2 = -arg2;
                  02207 			;    do  {
                  02208 			;        arg1 = rl( arg1);
                  02209 			;        rm = rl( rm);
                  02210 			;        W = rm.low8 - arg2.low8;
                  02211 			;        genSubW( rm.high8, arg2.high8);
                  02212 			;        if (!Carry)
                  02213 			;            goto NOSUB;
                  02214 			;        rm.high8 = W;
                  02215 			;        rm.low8 -= arg2.low8;
                  02216 			;      NOSUB:
                  02217 			;        counter = decsz(counter);
                  02218 			;    } while (1);
                  02219 			;    if (sign & 0x80)
                  02220 			;        rm = -rm;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 38

ADDR   CODE       LINE  SOURCE

                  02221 			;    return rm;
                  02222 
                  02223   ; FILE C:\PIC\CC8E\MATH24LB.H
                  02224 			;// *************************************************
                  02225 			;// 24 bit floating point math functions
                  02226 			;// Copyright (c) B Knudsen Data, Norway, 2000 - 2006
                  02227 			;// *************************************************
                  02228 			;
                  02229 			;#pragma library 1
                  02230 			;/* PROTOTYPES for page definition in application header file:
                  02231 			;float24 log( float24 arg1f24);
                  02232 			;float24 log10( float24 arg1f24);
                  02233 			;float24 exp10( float24 arg1f24);
                  02234 			;float24 exp( float24 arg1f24);
                  02235 			;float24 cos( float24 arg1f24);
                  02236 			;float24 sin( float24 arg1f24);
                  02237 			;float24 sqrt( float24 arg1f24);
                  02238 			;*/
                  02239 			;
                  02240 			;#ifndef FpFlags_defined
                  02241 			; #error The basic 24 bit floating point math library must be included first
                  02242 			;#endif
                  02243 			;
                  02244 			;#if __CoreSet__ / 100 == 12
                  02245 			; #error Math functions (exp,log,..) are not adapted to 12 bit core devices
                  02246 			;#endif
                  02247 			;
                  02248 			;#if __CoreSet__ < 1600
                  02249 			; #define genAdd(r,a) W=a; btsc(Carry); W=incsz(a); r+=W
                  02250 			; #define genSub(r,a) W=a; btss(Carry); W=incsz(a); r-=W
                  02251 			; #define genAddW(r,a) W=a; btsc(Carry); W=incsz(a); W=r+W
                  02252 			; #define genSubW(r,a) W=a; btss(Carry); W=incsz(a); W=r-W
                  02253 			;#else
                  02254 			; #define genAdd(r,a) W=a; r=addWFC(r)
                  02255 			; #define genSub(r,a) W=a; r=subWFB(r)
                  02256 			; #define genAddW(r,a) W=a; W=addWFC(r)
                  02257 			; #define genSubW(r,a) W=a; W=subWFB(r)
                  02258 			;#endif
                  02259 			;
                  02260 			;
                  02261 			;float24 log( sharedM float24 arg1f24)
                  02262 			;{
                  02263 log
                  02264 			;    sharedM float24 arg2f24;
                  02265 			;
                  02266 			;    if (arg1f24.mid8 & 0x80)  //  test for negative argument
                  02267 			;        goto _DOMERR32;
                  02268 			;    if (!arg1f24.high8)   //  test for zero argument
                  02269 			;        goto _DOMERR32;
                  02270 			;
                  02271 			;    char savedFlags = FpFlags;   //  save rounding flag
                  02272 			;    FpFlags |= 0x40;  //  enable rounding
                  02273 			;
                  02274 			;    char xexp = arg1f24.high8 - (FpBIAS-1);
                  02275 			;    arg1f24.high8 = FpBIAS-1;
                  02276 			;
                  02277 			;    arg2f24 = 1.0;
                  02278 			;
                  02279 			;    //  .70710678118655 = 7E3504F3
                  02280 			;    W = arg1f24.low8 - 0x05;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 39

ADDR   CODE       LINE  SOURCE

                  02281 			;    W = 0x35;
                  02282 			;    if (!Carry)
                  02283 			;        W = 0x35+1;
                  02284 			;    W = arg1f24.mid8 - W;
                  02285 			;
                  02286 			;    if (Carry)
                  02287 			;        arg1f24 -= arg2f24;
                  02288 			;    else  {
                  02289 			;        arg1f24.high8 += 1;  /* arg1f24 *= 2; */
                  02290 			;        arg1f24 -= arg2f24;
                  02291 			;        xexp -= 1;
                  02292 			;    }
                  02293 			;
                  02294 			;    float24 d = arg1f24;  //  save z
                  02295 			;
                  02296 			;    // POLL132  LOG32Q,2,0  ; Q(z)
                  02297 			;    arg1f24 += 0.33339502905E+1; /* LOG32Q1 */
                  02298 			;    arg1f24 *= d;
                  02299 			;    arg1f24 += 0.24993759223E1;  /* LOG32Q0 */
                  02300 			;    float24 c = arg1f24;
                  02301 			;
                  02302 			;     //   minimax rational approximation  z-.5*z*z+z*(z*z*P(z)/Q(z))
                  02303 			;    // POL32  LOG32P,1,0  ; P(z)
                  02304 			;    arg1f24 = d;
                  02305 			;    arg1f24 *= 0.48646956294; /* LOG32P1 */
                  02306 			;    arg1f24 += 0.83311400452; /* LOG32P0 */
                  02307 			;
                  02308 			;    c = arg1f24 / c;   //  P(z)/Q(z)
                  02309 			;
                  02310 			;    W = d.high8;  arg1f24.high8 = W;  arg2f24.high8 = W;
                  02311 			;    W = d.mid8;   arg1f24.mid8 = W;   arg2f24.mid8 = W;
                  02312 			;    W = d.low8;   arg1f24.low8 = W;   arg2f24.low8 = W;
                  02313 			;
                  02314 			;    arg1f24 *= arg2f24;       // z * z;
                  02315 			;
                  02316 			;    float24 e = arg1f24;
                  02317 			;    arg1f24 *= c;          //  z*z*P(z)/Q(z)
                  02318 			;    arg1f24 *= d;          //  z*(z*z*P(z)/Q(z))
                  02319 			;
                  02320 			;    arg2f24 = e;
                  02321 			;    if (arg2f24.high8)
                  02322 			;        arg2f24.high8 --;  // arg2f24 *= 0.5;
                  02323 			;    arg1f24 -= arg2f24;       //  -.5*z*z + z*(z*z*P(z)/Q(z))
                  02324 			;    arg1f24 += d;          //  z -.5*z*z + z*(z*z*P(z)/Q(z))
                  02325 			;
                  02326 			;    if (!xexp)
                  02327 			;        goto _RETURN_MF;
                  02328 			;
                  02329 			;    e = arg1f24;  //  save
                  02330 			;
                  02331 			;    // integer to floating point conversion
                  02332 			;    arg1f24 = (int8) xexp;
                  02333 			;
                  02334 			;    d = arg1f24;  //  save k
                  02335 			;
                  02336 			;    arg1f24 *= -0.000212194440055;
                  02337 			;
                  02338 			;    arg1f24 += e;   //  log(1+z) + k*log(2)
                  02339 			;
                  02340 			;    e = arg1f24;  //  save
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 40

ADDR   CODE       LINE  SOURCE

                  02341 			;
                  02342 			;    arg1f24 = d * 0.693359375;
                  02343 			;
                  02344 			;    arg1f24 += e;      //  log(1+z) + k*log(2)
                  02345 			;
                  02346 			;    if (!(savedFlags & 0x40))
                  02347 			;        FpFlags &= ~0x40;   //  restore rounding flag
                  02348 			;    goto _RETURN_MF;
                  02349 			;
                  02350 			;  _DOMERR32:
                  02351 			;    FpDomainError = 1;   //  domain error
                  02352 			;
                  02353 			;  _RETURN_MF:
                  02354 			;    return arg1f24;
                  02355 			;}
                  02356 			;
                  02357 			;
                  02358 			;
                  02359 			;float24 log10( sharedM float24 arg1f24)
                  02360 			;{
                  02361 log10
                  02362 			;    sharedM float24 arg2f24;      // allocation 'trick'
                  02363 			;
                  02364 			;    char flags = FpFlags;
                  02365 			;    FpFlags |= 0x40;
                  02366 			;
                  02367 			;    arg1f24 = log( arg1f24);
                  02368 			;
                  02369 			;    arg1f24 *= 0.43429448190325;  //  log10(e);
                  02370 			;
                  02371 			;    if (!(flags & 0x40))
                  02372 			;        FpFlags &= ~0x40;
                  02373 			;
                  02374 			;    return arg1f24;
                  02375 			;}
                  02376 			;
                  02377 			;
                  02378 			;
                  02379 			;char floorMaskTable24( char i)
                  02380 			;{
                  02381 floorMaskTable24
                  02382 			;    if (i & 4)  {
                  02383 			;        if (i & 2)  {
                  02384 			;            if (i & 1)
                  02385 			;                return 128;
                  02386 			;            return 192;
                  02387 			;        }
                  02388 			;        if (i & 1)
                  02389 			;            return 224;
                  02390 			;        return 240;
                  02391 			;    }
                  02392 			;    if (i & 2)  {
                  02393 			;        if (i & 1)
                  02394 			;            return 248;
                  02395 			;        return 252;
                  02396 			;    }
                  02397 			;    if (i & 1)
                  02398 			;        return 254;
                  02399 			;    return 255;
                  02400 			;}
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 41

ADDR   CODE       LINE  SOURCE

                  02401 			;
                  02402 			;float24 floor24( sharedM float24 arg1f24)
                  02403 			;{
                  02404 floor24
                  02405 			;    if (!arg1f24.high8)
                  02406 			;        goto _RETURN_MF;
                  02407 			;
                  02408 			;    uns16 ma = arg1f24.low16;  //  save mantissa
                  02409 			;
                  02410 			;    W = arg1f24.high8 - 127;
                  02411 			;    char tmp = W;      // OPM
                  02412 			;    if (tmp & 0x80)
                  02413 			;        goto FLOOR24ZERO;
                  02414 			;
                  02415 			;    //  save number of zero bits
                  02416 			;    W = 15 - W;
                  02417 			;
                  02418 			;    char tmpa = W;
                  02419 			;    tmp = W;
                  02420 			;
                  02421 			;    if (tmp & 0x8)  // LSB+3		; divide by eight
                  02422 			;        goto FLOOR24MASKH;
                  02423 			;
                  02424 			;
                  02425 			;    W = floorMaskTable24( tmpa);    //  get mask
                  02426 			;    arg1f24.low8 &= W;
                  02427 			;    if (!(arg1f24.mid8 & 0x80))  //  if negative, round down
                  02428 			;        goto _RETURN_MF;
                  02429 			;
                  02430 			;    char arg1B7 = W;
                  02431 			;    if (!(arg1f24.low8 - ma.low8))
                  02432 			;        goto _RETURN_MF;
                  02433 			;
                  02434 			;    tmp = ~arg1B7;
                  02435 			;    arg1f24.low8 += tmp + 1;
                  02436 			;    if (Zero_)
                  02437 			;        arg1f24.mid8 += 1;
                  02438 			;
                  02439 			;    //  has rounding caused carryout?
                  02440 			;    if (!Zero_)
                  02441 			;        goto _RETURN_MF;
                  02442 			;    arg1f24.mid8 = rr( arg1f24.mid8);
                  02443 			;    arg1f24.low8 = rr( arg1f24.low8);
                  02444 			;
                  02445 			;    //  check for overflow
                  02446 			;    arg1f24.high8 = incsz( arg1f24.high8);
                  02447 			;    goto _RETURN_MF;
                  02448 			;    goto OVERFLOW;
                  02449 			;
                  02450 			;
                  02451 			;  FLOOR24MASKH:
                  02452 			;    W = floorMaskTable24( tmpa);  //  get mask
                  02453 			;    arg1f24.mid8 &= W;
                  02454 			;    arg1f24.low8 = 0;
                  02455 			;
                  02456 			;    //  if negative, round down
                  02457 			;    if (!(arg1f24.mid8 & 0x80))
                  02458 			;        goto _RETURN_MF;
                  02459 			;
                  02460 			;    arg1B7 = W;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 42

ADDR   CODE       LINE  SOURCE

                  02461 			;    if (( arg1f24.low8 - ma.low8) != 0)
                  02462 			;        goto FLOOR24RNDH;
                  02463 			;    if (!(arg1f24.mid8 - ma.mid8))
                  02464 			;        goto _RETURN_MF;
                  02465 			;
                  02466 			;  FLOOR24RNDH:
                  02467 			;    tmp = ~arg1B7;
                  02468 			;    arg1f24.mid8 += tmp + 1;
                  02469 			;
                  02470 			;    //  has rounding caused carryout?
                  02471 			;    if (!Carry)
                  02472 			;        goto _RETURN_MF;
                  02473 			;    arg1f24.mid8 = rr( arg1f24.mid8);
                  02474 			;    arg1f24.low8 = rr( arg1f24.low8);
                  02475 			;
                  02476 			;    //  check for overflow
                  02477 			;    arg1f24.high8 = incsz( arg1f24.high8);
                  02478 			;    goto _RETURN_MF;
                  02479 			;    goto OVERFLOW;
                  02480 			;
                  02481 			;
                  02482 			;  FLOOR24ZERO:
                  02483 			;    if (!(arg1f24.mid8 & 0x80))
                  02484 			;        goto RES0;
                  02485 			;    return -1.0;
                  02486 			;
                  02487 			;  RES0:
                  02488 			;    W = 0;
                  02489 			;    goto ASSIGNW;
                  02490 			;
                  02491 			;  OVERFLOW:
                  02492 			;    FpOverflow = 1;
                  02493 			;    W = 0xFF;
                  02494 			;  ASSIGNW:
                  02495 			;    arg1f24.low8 = W;
                  02496 			;    arg1f24.mid8 = W;
                  02497 			;    arg1f24.high8 = W;
                  02498 			;
                  02499 			;  _RETURN_MF:
                  02500 			;    return arg1f24;
                  02501 			;}
                  02502 			;
                  02503 			;
                  02504 			;
                  02505 			;float24 exp10( sharedM float24 arg1f24)
                  02506 			;{
                  02507 exp10
                  02508 			;    sharedM float24 arg2f24;      // allocation 'trick'
                  02509 			;    float24 c, d;
                  02510 			;    char xexp;
                  02511 			;
                  02512 			;    if (( arg1f24.high8 - 100) & 0x80)
                  02513 			;        goto EXP1;   //  return e**x = 1
                  02514 			;
                  02515 			;    W = 132 - arg1f24.high8;
                  02516 			;    if (!Carry)
                  02517 			;        goto _DOMERR;
                  02518 			;    if (!Zero_)
                  02519 			;        goto ARGOK;
                  02520 			;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 43

ADDR   CODE       LINE  SOURCE

                  02521 			;    if (!(arg1f24.mid8 & 0x80))  {
                  02522 			;        //  positive domain check
                  02523 			;        W = 26 - arg1f24.mid8;
                  02524 			;        if (!Carry)
                  02525 			;            goto _DOMERR;
                  02526 			;        if (!Zero_)
                  02527 			;            goto ARGOK;
                  02528 			;
                  02529 			;        W = 33 - arg1f24.low8;
                  02530 			;        if (!Carry)
                  02531 			;            goto _DOMERR;
                  02532 			;    }
                  02533 			;    else  {
                  02534 			;
                  02535 			;        W = 151 - arg1f24.mid8;
                  02536 			;        if (!Carry)
                  02537 			;            goto _DOMERR;
                  02538 			;        if (!Zero_)
                  02539 			;            goto ARGOK;
                  02540 			;
                  02541 			;        W = 184 - arg1f24.low8;
                  02542 			;        if (!Carry)
                  02543 			;            goto _DOMERR;
                  02544 			;    }
                  02545 			;
                  02546 			;  ARGOK:
                  02547 			;
                  02548 			;    char savedFlags = FpFlags;
                  02549 			;    FpFlags |= 0x40;  //  enable rounding
                  02550 			;
                  02551 			;    c = arg1f24;  //  save x
                  02552 			;    arg1f24 *= 3.32192809489;  //  1/log10(2) = 3.32192809489
                  02553 			;    arg1f24 += 0.5;  //  k = [ x / log10(2) + .5 ]
                  02554 			;    arg1f24 = floor24( arg1f24);
                  02555 			;
                  02556 			;    float24 e = arg1f24; //  save float k
                  02557 			;    FpFlags &= ~0x40;
                  02558 			;    //floating point to integer conversion
                  02559 			;    xexp = arg1f24; //  k = [ x / ln(2) + .5 ]
                  02560 			;    FpFlags |= 0x40;
                  02561 			;    arg1f24 = e * -0.30078125; //  c1
                  02562 			;    d = arg1f24 + c;
                  02563 			;    arg1f24 = e * -2.487456637421670e-04;  // c2
                  02564 			;    arg1f24 += d;
                  02565 			;    d = arg1f24;  //  save f
                  02566 			;
                  02567 			;    if (!(d.mid8 & 0x80))  {
                  02568 			;        // POL32  EXP1032H,5,4   ; minimax approximation on [0,log10(2)/2]
                  02569 			;        arg1f24 *= 6.388992868121E-1;/* EXP1032H5 */
                  02570 			;        arg1f24 += 1.154596329197E0; /* EXP1032H4 */
                  02571 			;        arg1f24 *= d;
                  02572 			;        arg1f24 += 2.035920309947E0; /* EXP1032H3 */
                  02573 			;        arg1f24 *= d;
                  02574 			;        arg1f24 += 2.650909138708E0; /* EXP1032H2 */
                  02575 			;        arg1f24 *= d;
                  02576 			;        arg1f24 += 2.302585504840E0; /* EXP1032H1 */
                  02577 			;    }
                  02578 			;    else  {
                  02579 			;        // POL32 EXP1032L,5,4  ; minimax approximation on [-log10(2)/2,0]
                  02580 			;        arg1f24 *= 4.544952589676E-1;/* EXP1032L5 */
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 44

ADDR   CODE       LINE  SOURCE

                  02581 			;        arg1f24 += 1.157459289066E0; /* EXP1032L4 */
                  02582 			;        arg1f24 *= d;
                  02583 			;        arg1f24 += 2.033640565225E0; /* EXP1032L3 */
                  02584 			;        arg1f24 *= d;
                  02585 			;        arg1f24 += 2.650914554552E0; /* EXP1032L2 */
                  02586 			;        arg1f24 *= d;
                  02587 			;        arg1f24 += 2.302584716116E0; /* EXP1032L1 */
                  02588 			;    }
                  02589 			;    arg1f24 *= d;
                  02590 			;    if (!(savedFlags & 0x40))
                  02591 			;        FpFlags &= ~0x40;
                  02592 			;    arg1f24 += 1.0; /* EXP1032H0/EXP1032L0 */
                  02593 			;
                  02594 			;    arg1f24.high8 += xexp;
                  02595 			;    goto _RETURN_MF;
                  02596 			;
                  02597 			;  EXP1:
                  02598 			;    arg1f24 = 1.0;   //  return 10**x = 1.0
                  02599 			;    goto _RETURN_MF;
                  02600 			;
                  02601 			;  _DOMERR:
                  02602 			;    FpDomainError = 1;   //  domain error
                  02603 			;
                  02604 			;  _RETURN_MF:
                  02605 			;    return arg1f24;
                  02606 			;}
                  02607 			;
                  02608 			;
                  02609 			;
                  02610 			;float24 exp( sharedM float24 arg1f24)
                  02611 			;//     Maximum argument : 88.7228391117 = log(2**128)
                  02612 			;//     Minimum argument : -87.3365447506 = log(2**-126)
                  02613 			;{
                  02614 exp
                  02615 			;    sharedM float24 arg2f24;
                  02616 			;    float24 c, d;
                  02617 			;    char xexp;
                  02618 			;
                  02619 			;    if (( arg1f24.high8 - 94) & 0x80)
                  02620 			;        goto EXP1;   //  return e**x = 1
                  02621 			;
                  02622 			;    W = 133 - arg1f24.high8;
                  02623 			;    if (!Carry)
                  02624 			;        goto _DOMERR;
                  02625 			;    if (!Zero_)
                  02626 			;        goto ARGOK;
                  02627 			;
                  02628 			;    if (!(arg1f24.mid8 & 0x80))  {
                  02629 			;
                  02630 			;        W = 49 - arg1f24.mid8;
                  02631 			;        if (!Carry)
                  02632 			;            goto _DOMERR;
                  02633 			;        if (!Zero_)
                  02634 			;            goto ARGOK;
                  02635 			;
                  02636 			;        W = 114 - arg1f24.midL8;
                  02637 			;        if (!Carry)
                  02638 			;            goto _DOMERR;
                  02639 			;    }
                  02640 			;    else {
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 45

ADDR   CODE       LINE  SOURCE

                  02641 			;
                  02642 			;        W = 174 - arg1f24.mid8;
                  02643 			;        if (!Carry)
                  02644 			;            goto _DOMERR;
                  02645 			;        if (!Zero_)
                  02646 			;            goto ARGOK;
                  02647 			;
                  02648 			;        W = 172 - arg1f24.midL8;
                  02649 			;        if (!Carry)
                  02650 			;            goto _DOMERR;
                  02651 			;    }
                  02652 			;
                  02653 			;  ARGOK:
                  02654 			;
                  02655 			;    char savedFlags = FpFlags;
                  02656 			;    FpFlags |= 0x40;  //  enable rounding
                  02657 			;
                  02658 			;    c = arg1f24;  //  save x
                  02659 			;    arg1f24 *= 1.44269504089;
                  02660 			;    arg1f24 += 0.5; //  k = [ x / ln(2) + .5 ]
                  02661 			;    arg1f24 = floor24( arg1f24);
                  02662 			;
                  02663 			;    float24 e = arg1f24;
                  02664 			;    xexp = arg1f24;   //  k = [ x / ln(2) + .5 ]
                  02665 			;    arg1f24 = e * -0.69140625; // c1
                  02666 			;    d = arg1f24 + c;
                  02667 			;    arg1f24 = e * -1.740930559945286e-03;  // c2
                  02668 			;    arg1f24 += d;
                  02669 			;    d = arg1f24;  //  save f
                  02670 			;
                  02671 			;    if (!(d.mid8 & 0x80))  {
                  02672 			;        // POL32   EXP32H,5,0
                  02673 			;        arg1f24 *= 0.989943653774E-2; /* EXP32H5 */
                  02674 			;        arg1f24 += 0.410473706887E-1; /* EXP32H4 */
                  02675 			;        arg1f24 *= d;
                  02676 			;        arg1f24 += 0.166777360103;    /* EXP32H3 */
                  02677 			;        arg1f24 *= d;
                  02678 			;        arg1f24 += 0.499991163105;    /* EXP32H2 */
                  02679 			;        arg1f24 *= d;
                  02680 			;        arg1f24 += 1.00000025499;     /* EXP32H1 */
                  02681 			;    }
                  02682 			;    else  {
                  02683 			;        // POL32   EXP32L,5,0
                  02684 			;        arg1f24 *= 0.699995870637E-2; /* EXP32L5 */
                  02685 			;        arg1f24 += 0.411548782678E-1; /* EXP32L4 */
                  02686 			;        arg1f24 *= d;
                  02687 			;        arg1f24 += 0.166574299807;    /* EXP32L3 */
                  02688 			;        arg1f24 *= d;
                  02689 			;        arg1f24 += 0.499992371926;    /* EXP32L2 */
                  02690 			;        arg1f24 *= d;
                  02691 			;        arg1f24 += 0.999999766814;    /* EXP32L1 */
                  02692 			;    }
                  02693 			;    arg1f24 *= d;
                  02694 			;    arg1f24 += 1.0;   /* EXP32H0 or EXP32L0 */
                  02695 			;    arg1f24.high8 += xexp;
                  02696 			;
                  02697 			;    if (!(savedFlags & 0x40))
                  02698 			;        FpFlags &= ~0x40;   //  restore rounding flag
                  02699 			;    goto _RETURN_MF;
                  02700 			;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 46

ADDR   CODE       LINE  SOURCE

                  02701 			;  EXP1:
                  02702 			;    arg1f24 = 1.0;   //  return 10**x = 1.0
                  02703 			;    goto _RETURN_MF;
                  02704 			;
                  02705 			;  _DOMERR:
                  02706 			;    FpDomainError = 1;   //  domain error
                  02707 			;
                  02708 			;  _RETURN_MF:
                  02709 			;    return arg1f24;
                  02710 			;}
                  02711 			;
                  02712 			;
                  02713 			;
                  02714 			;
                  02715 			;
                  02716 			;
                  02717 			;float24 cosin24( sharedM float24 arg1f24, sharedM float24 arg2f24, char cosinus)
                  02718 			;{
                  02719 cosin24
                  02720 			;    float24 c, d;
                  02721 			;    char j;
                  02722 			;
                  02723 			;    char savedFlags = FpFlags;  //  save rounding flag
                  02724 			;    FpFlags |= 0x40;  //  enable rounding
                  02725 			;
                  02726 			;    char csign = 0;    //  initialize sign
                  02727 			;
                  02728 			;    if (!cosinus  &&  (arg1f24.mid8 & 0x80))
                  02729 			;        csign |= 0x80;
                  02730 			;
                  02731 			;    arg1f24.mid8 &= ~0x80;  //  use |x|
                  02732 			;
                  02733 			;    //  loss threshold check
                  02734 			;    // arg1f24 <= +512.0
                  02735 			;    // arg1f24 >= -512.0
                  02736 			;    if (arg1f24.high8 >= 0x88)
                  02737 			;        FpDomainError = 1;   //  domain error
                  02738 			;
                  02739 			;    c = arg1f24;  //  save |x|
                  02740 			;
                  02741 			;    // fixed point multiplication by 4/pi
                  02742 			;    arg1f24 *= 1.27323954474;   // 4/pi
                  02743 			;
                  02744 			;    FpFlags &= ~0x40;
                  02745 			;
                  02746 			;    //  y = [ |x| * (4/pi) ]
                  02747 			;    arg1f24.low16 = arg1f24;  // floating point to integer conversion
                  02748 			;
                  02749 			;    FpFlags |= 0x40;
                  02750 			;
                  02751 			;    if (arg1f24.low8 & 0x1)
                  02752 			;        arg1f24.low16 += 1;  // make arg1f24 even
                  02753 			;
                  02754 			;    //  j = y mod 8
                  02755 			;    j = arg1f24.low8 & 7;  // 0,2,4,6
                  02756 			;    if (j >= 4)  {
                  02757 			;        csign ^= 128;
                  02758 			;        j -= 4;
                  02759 			;    }
                  02760 			;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 47

ADDR   CODE       LINE  SOURCE

                  02761 			;    arg1f24 = arg1f24.low16;  // integer to floating point conversion
                  02762 			;
                  02763 			;    //  save y in DARG
                  02764 			;    W = arg1f24.high8;
                  02765 			;    d.high8 = W;
                  02766 			;   #if __CoreSet__ / 100 == 17
                  02767 			;    if (W == 0)  // NB17
                  02768 			;        goto ZEQX;
                  02769 			;   #else
                  02770 			;    if (Zero_)
                  02771 			;        goto ZEQX;
                  02772 			;   #endif
                  02773 			;    d.low16 = arg1f24.low16;
                  02774 			;
                  02775 			;    arg1f24 *= -7.851562500000000e-01;
                  02776 			;    c = arg1f24 + c;    //  z1 = |x| - y * (p1)
                  02777 			;    arg1f24 = d * -2.419133974475018e-04;
                  02778 			;    arg1f24 += c;
                  02779 			;
                  02780 			;    //  save z in c
                  02781 			;    W = arg1f24.high8;  c.high8 = W;  arg2f24.high8 = W;
                  02782 			;    W = arg1f24.mid8;   c.mid8 = W;   arg2f24.mid8 = W;
                  02783 			;    W = arg1f24.low8;   c.low8 = W;   arg2f24.low8 = W;
                  02784 			;
                  02785 			;    goto POLYNOM;
                  02786 			;
                  02787 			;   ZEQX:
                  02788 			;    W = c.high8;  arg1f24.high8 = W;  arg2f24.high8 = W;
                  02789 			;    W = c.mid8;   arg1f24.mid8 = W;   arg2f24.mid8 = W;
                  02790 			;    W = c.low8;   arg1f24.low8 = W;   arg2f24.low8 = W;
                  02791 			;
                  02792 			;   POLYNOM:
                  02793 			;
                  02794 			;    arg1f24 *= arg2f24;   // z * z
                  02795 			;    d = arg1f24;   //  save z * z
                  02796 			;
                  02797 			;    if ((( rr( j) ^ j) & 0x1) ^ cosinus)  {
                  02798 			;        // POL24  COS24,3,0
                  02799 			;
                  02800 			;        arg1f24 *= -1.35859090e-03;  // 117,178,18,191
                  02801 			;        arg1f24 += 4.16550264e-02;   // 122,42,158,118
                  02802 			;        arg1f24 *= d;
                  02803 			;        arg1f24 += -4.99998569e-01;  // 125,255,255,208
                  02804 			;        arg1f24 *= d;
                  02805 			;        arg1f24 += 1.0;
                  02806 			;    }
                  02807 			;    else  {
                  02808 			;        /// POL24  SIN24,2,0
                  02809 			;        arg1f24 *= 8.12155753e-03;   // 120,5,16,72
                  02810 			;        arg1f24 += -1.66601613e-01;  // 124,170,153,157
                  02811 			;        arg1f24 *= d;
                  02812 			;        arg1f24 += 9.99994993e-01;   // 126,127,255,172
                  02813 			;        arg1f24 *= c;
                  02814 			;    }
                  02815 			;
                  02816 			;    W = 128;  // LSB+1
                  02817 			;    if (cosinus  &&  (j & 0x2))   // NB17
                  02818 			;        csign ^= W;
                  02819 			;    if (csign & 0x80)
                  02820 			;        arg1f24.mid8 ^= W;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 48

ADDR   CODE       LINE  SOURCE

                  02821 			;
                  02822 			;    if (savedFlags & 0x40)
                  02823 			;        FpFlags |= 0x40;  //  restore rounding flag
                  02824 			;    return arg1f24;
                  02825 			;}
                  02826 			;
                  02827 			;
                  02828 			;float24 cos( sharedM float24 arg1f24)
                  02829 			;{
                  02830 cos
                  02831 			;    sharedM float24 arg2f24;      // allocation 'trick'
                  02832 			;    arg1f24 = cosin24( arg1f24, arg2f24, 1);
                  02833 			;    return arg1f24;
                  02834 			;}
                  02835 			;
                  02836 			;
                  02837 			;float24 sin( sharedM float24 arg1f24)
                  02838 			;{
                  02839 sin
                  02840 			;    sharedM float24 arg2f24;      // allocation 'trick'
                  02841 			;    arg1f24 = cosin24( arg1f24, arg2f24, 0);
                  02842 			;    return arg1f24;
                  02843 			;}
                  02844 			;
                  02845 			;
                  02846 			;
                  02847 			;#if !defined __CC8EFREE__
                  02848 			;
                  02849 			;float24 sqrt( float24 arg)
                  02850 			;// Copyright (c) Jim van Zee, Seattle, WA., 2004
                  02851 			;{
                  02852 			;    uns8 arg_exp @ arg.high8;    // arg exponent (offset by FpBIAS)
                  02853 			;    uns24 root = 0;              // result (treated as an integer)
                  02854 			;    float24 sqrtf @ root;        // result (treated as a float)
                  02855 			;    uns24 remain;
                  02856 			;    uns8 nr_bits;
                  02857 			;
                  02858 			;    if (arg.mid8 & 0x80) {  // test for negative argument
                  02859 			;        FpDomainError=1;
                  02860 			;        goto END;           // negative #s return '0'
                  02861 			;    }
                  02862 			;    if (!arg_exp)
                  02863 			;        goto END;           // 0->0 (all bytes are 0)
                  02864 			;
                  02865 			;    arg.15 = 1;             // restore hidden bit
                  02866 			;    remain = 0;             // clear remainder
                  02867 			;    nr_bits = 16;           // initialize bit count
                  02868 			;
                  02869 			;    // Here's a 'tricky bit': 'even' exponents work out OK, but 'odd'
                  02870 			;    // exponents need one less shift initially in order to align the
                  02871 			;    // bits in a 'powers-of-four' pattern (two-bits-at-a-time).
                  02872 			;
                  02873 			;    btss(arg_exp.0);          // skip if exponent is odd
                  02874 			;    do {
                  02875 			;        remain.23=1;          // set 2x shift flag
                  02876 			;        root = rl(root);        // exponent= 'spill byte'
                  02877 			;        root.0=1;               // add '1' to form '2N+1'
                  02878 			;        root.1=0;               // clear next root bit
                  02879 			;        do {
                  02880 			;            arg.low16 = rl(arg.low16); // shift mantissa into 'remain'
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 49

ADDR   CODE       LINE  SOURCE

                  02881 			;            remain = rl(remain);       // two-bits-at-a-time (add 0's)
                  02882 			;        } while(Carry);         // Carry=1 the first time
                  02883 			;        arg.0=0;                // clear the carry-in bit
                  02884 			;
                  02885 			;        // now compare root and remainder; if remain >= root, subtract
                  02886 			;        // to get the new remainder & set bit=1; otherwise leave bit=0.
                  02887 			;
                  02888 			;        //        if (remain >= root) // 3-byte compare
                  02889 			;        //        {   remain -= root; // update remainder
                  02890 			;        //            root.1 = 1;   } // set this bit = 1
                  02891 			;
                  02892 			;        W = remain.low8 - root.low8;  // compare remain w/root
                  02893 			;        genSubW( remain.mid8, root.mid8);
                  02894 			;        genSubW( remain.high8, root.high8);
                  02895 			;
                  02896 			;        // If remain >= root, the next bit is '1', otherwise '0'
                  02897 			;        if (Carry) {          // remain -= root;
                  02898 			;            remain.high8 = W;   // save 'spill byte'
                  02899 			;            remain.low8 -= root.low8;   // do subtraction
                  02900 			;            genSub( remain.mid8, root.mid8);
                  02901 			;            root.1 = 1; // note: lsb is bit1, not bit0!
                  02902 			;        }
                  02903 			;
                  02904 			;    } while (--nr_bits); // 16 bit mantissa
                  02905 			;
                  02906 			;    // Finally unshift root (only need to do 16 bits, since msb->0!)
                  02907 			;    root.low16 = rr(root.low16);       // '2N+1' -> 'N'
                  02908 			;    root.15 = 0;            // clear hidden bit
                  02909 			;
                  02910 			;    // and set exponent = arg_exp/2 (we used this as the spill byte)
                  02911 			;    arg_exp += FpBIAS;      // double the bias
                  02912 			;    root.high8=rr(arg_exp); // root exp = arg_exp/2+FpBIAS
                  02913 			;  END:
                  02914 			;    return sqrtf;           // neg & zero args return 0
                  02915 			;}
                  02916 			;
                  02917 			;#else
                  02918 			;
                  02919 			;float24 sqrt( sharedM float24 arg1f24)
                  02920 			;{
                  02921 sqrt
                  02922 			;    sharedM float24 arg2f24;      // allocation 'trick'
                  02923 			;
                  02924 			;    if (arg1f24.mid8 & 0x80)     // test for negative argument
00056A 0100       02925 	MOVLB 0
00056C BFB1       02926 	BTFSC arg1f24+1,7,1
                  02927 			;        goto _DOMERR;
00056E D0A1       02928 	BRA   m069
                  02929 			;    if (!arg1f24.high8)          // return if argument zero
000570 0100       02930 	MOVLB 0
000572 53B2       02931 	MOVF  arg1f24+2,1,1
000574 B4D8       02932 	BTFSC 0xFD8,Zero_,0
                  02933 			;        goto _RETURN_MF;
000576 D09F       02934 	BRA   m070
                  02935 			;
                  02936 			;    char cexp = arg1f24.high8;    // save exponent
000578 C0B2 F0B6  02937 	MOVFF arg1f24+2,cexp
                  02938 			;    char savedFLAGS = FpFlags;
00057C C0D8 F0B7  02939 	MOVFF FpFlags,savedFLAGS
                  02940 			;    FpFlags |= 0x40;           // enable rounding
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 50

ADDR   CODE       LINE  SOURCE

000580 0100       02941 	MOVLB 0
000582 8DD8       02942 	BSF   FpFlags,6,1
                  02943 			;
                  02944 			;    arg1f24.high8 = FpBIAS;   // compute z
000584 0E7F       02945 	MOVLW 127
000586 6FB2       02946 	MOVWF arg1f24+2,1
                  02947 			;    float24 d = arg1f24;
000588 C0B0 F0B8  02948 	MOVFF arg1f24,d_5
00058C C0B1 F0B9  02949 	MOVFF arg1f24+1,d_5+1
000590 C0B2 F0BA  02950 	MOVFF arg1f24+2,d_5+2
                  02951 			;
                  02952 			;    if (arg1f24.mid8 & 0x40)  {
000594 ADB1       02953 	BTFSS arg1f24+1,6,1
000596 D03D       02954 	BRA   m066
                  02955 			;        // POL24  SQRT24H,4,0
                  02956 			;        arg1f24 *= -5.6351436252E-3;  // SQRT24H4
000598 0EA7       02957 	MOVLW 167
00059A 6FB3       02958 	MOVWF arg2f24,1
00059C 0EB8       02959 	MOVLW 184
00059E 6FB4       02960 	MOVWF arg2f24+1,1
0005A0 0E77       02961 	MOVLW 119
0005A2 6FB5       02962 	MOVWF arg2f24+2,1
0005A4 DDD3       02963 	RCALL _fmul24
                  02964 			;        arg1f24 += 5.5047377031E-2; // SQRT24H3
0005A6 0E79       02965 	MOVLW 121
0005A8 0100       02966 	MOVLB 0
0005AA 6FB3       02967 	MOVWF arg2f24,1
0005AC 0E61       02968 	MOVLW 97
0005AE 6FB4       02969 	MOVWF arg2f24+1,1
0005B0 0E7A       02970 	MOVLW 122
0005B2 6FB5       02971 	MOVWF arg2f24+2,1
0005B4 DE2F       02972 	RCALL _fadd24
                  02973 			;        arg1f24 *= d;
0005B6 C0B8 F0B3  02974 	MOVFF d_5,arg2f24
0005BA C0B9 F0B4  02975 	MOVFF d_5+1,arg2f24+1
0005BE C0BA F0B5  02976 	MOVFF d_5+2,arg2f24+2
0005C2 DDC4       02977 	RCALL _fmul24
                  02978 			;        arg1f24 += -2.3944355047E-1;  // SQRT24H2
0005C4 0E31       02979 	MOVLW 49
0005C6 0100       02980 	MOVLB 0
0005C8 6FB3       02981 	MOVWF arg2f24,1
0005CA 0EF5       02982 	MOVLW 245
0005CC 6FB4       02983 	MOVWF arg2f24+1,1
0005CE 0E7C       02984 	MOVLW 124
0005D0 6FB5       02985 	MOVWF arg2f24+2,1
0005D2 DE20       02986 	RCALL _fadd24
                  02987 			;        arg1f24 *= d;
0005D4 C0B8 F0B3  02988 	MOVFF d_5,arg2f24
0005D8 C0B9 F0B4  02989 	MOVFF d_5+1,arg2f24+1
0005DC C0BA F0B5  02990 	MOVFF d_5+2,arg2f24+2
0005E0 DDB5       02991 	RCALL _fmul24
                  02992 			;        arg1f24 += 8.3106978456E-1; // SQRT24H1
0005E2 0EC1       02993 	MOVLW 193
0005E4 0100       02994 	MOVLB 0
0005E6 6FB3       02995 	MOVWF arg2f24,1
0005E8 0E54       02996 	MOVLW 84
0005EA 6FB4       02997 	MOVWF arg2f24+1,1
0005EC 0E7E       02998 	MOVLW 126
0005EE 6FB5       02999 	MOVWF arg2f24+2,1
0005F0 DE11       03000 	RCALL _fadd24
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 51

ADDR   CODE       LINE  SOURCE

                  03001 			;        arg1f24 *= d;
0005F2 C0B8 F0B3  03002 	MOVFF d_5,arg2f24
0005F6 C0B9 F0B4  03003 	MOVFF d_5+1,arg2f24+1
0005FA C0BA F0B5  03004 	MOVFF d_5+2,arg2f24+2
0005FE DDA6       03005 	RCALL _fmul24
                  03006 			;        arg1f24 += 3.5963132863E-1;  // SQRT24H0
000600 0E22       03007 	MOVLW 34
000602 0100       03008 	MOVLB 0
000604 6FB3       03009 	MOVWF arg2f24,1
000606 0E38       03010 	MOVLW 56
000608 6FB4       03011 	MOVWF arg2f24+1,1
00060A 0E7D       03012 	MOVLW 125
00060C 6FB5       03013 	MOVWF arg2f24+2,1
00060E DE02       03014 	RCALL _fadd24
                  03015 			;    }
                  03016 			;    else  {
000610 D03D       03017 	BRA   m067
                  03018 			;        // POL24  SQRT24L,4,0
                  03019 			;        arg1f24 *= -1.8702682470E-2;  // SQRT24L4
000612 0E36       03020 m066	MOVLW 54
000614 0100       03021 	MOVLB 0
000616 6FB3       03022 	MOVWF arg2f24,1
000618 0E99       03023 	MOVLW 153
00061A 6FB4       03024 	MOVWF arg2f24+1,1
00061C 0E79       03025 	MOVLW 121
00061E 6FB5       03026 	MOVWF arg2f24+2,1
000620 DD95       03027 	RCALL _fmul24
                  03028 			;        arg1f24 += 1.3009144111E-1; // SQRT24L3
000622 0E37       03029 	MOVLW 55
000624 0100       03030 	MOVLB 0
000626 6FB3       03031 	MOVWF arg2f24,1
000628 0E05       03032 	MOVLW 5
00062A 6FB4       03033 	MOVWF arg2f24+1,1
00062C 0E7C       03034 	MOVLW 124
00062E 6FB5       03035 	MOVWF arg2f24+2,1
000630 DDF1       03036 	RCALL _fadd24
                  03037 			;        arg1f24 *= d;
000632 C0B8 F0B3  03038 	MOVFF d_5,arg2f24
000636 C0B9 F0B4  03039 	MOVFF d_5+1,arg2f24+1
00063A C0BA F0B5  03040 	MOVFF d_5+2,arg2f24+2
00063E DD86       03041 	RCALL _fmul24
                  03042 			;        arg1f24 += -4.0192034196E-1;  // SQRT24L2
000640 0EC9       03043 	MOVLW 201
000642 0100       03044 	MOVLB 0
000644 6FB3       03045 	MOVWF arg2f24,1
000646 0ECD       03046 	MOVLW 205
000648 6FB4       03047 	MOVWF arg2f24+1,1
00064A 0E7D       03048 	MOVLW 125
00064C 6FB5       03049 	MOVWF arg2f24+2,1
00064E DDE2       03050 	RCALL _fadd24
                  03051 			;        arg1f24 *= d;
000650 C0B8 F0B3  03052 	MOVFF d_5,arg2f24
000654 C0B9 F0B4  03053 	MOVFF d_5+1,arg2f24+1
000658 C0BA F0B5  03054 	MOVFF d_5+2,arg2f24+2
00065C DD77       03055 	RCALL _fmul24
                  03056 			;        arg1f24 += 9.8831235597E-1;  // SQRT24L1
00065E 0E02       03057 	MOVLW 2
000660 0100       03058 	MOVLB 0
000662 6FB3       03059 	MOVWF arg2f24,1
000664 0E7D       03060 	MOVLW 125
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 52

ADDR   CODE       LINE  SOURCE

000666 6FB4       03061 	MOVWF arg2f24+1,1
000668 0E7E       03062 	MOVLW 126
00066A 6FB5       03063 	MOVWF arg2f24+2,1
00066C DDD3       03064 	RCALL _fadd24
                  03065 			;        arg1f24 *= d;
00066E C0B8 F0B3  03066 	MOVFF d_5,arg2f24
000672 C0B9 F0B4  03067 	MOVFF d_5+1,arg2f24+1
000676 C0BA F0B5  03068 	MOVFF d_5+2,arg2f24+2
00067A DD68       03069 	RCALL _fmul24
                  03070 			;        arg1f24 += 3.0221977303E-1;  // SQRT24L0
00067C 0EBD       03071 	MOVLW 189
00067E 0100       03072 	MOVLB 0
000680 6FB3       03073 	MOVWF arg2f24,1
000682 0E1A       03074 	MOVLW 26
000684 6FB4       03075 	MOVWF arg2f24+1,1
000686 0E7D       03076 	MOVLW 125
000688 6FB5       03077 	MOVWF arg2f24+2,1
00068A DDC4       03078 	RCALL _fadd24
                  03079 			;    }
                  03080 			;
                  03081 			;    if (!(cexp & 0x1))      // is cexp even or odd?
00068C 0100       03082 m067	MOVLB 0
00068E B1B6       03083 	BTFSC cexp,0,1
000690 D007       03084 	BRA   m068
                  03085 			;        arg1f24 *= 1.41421356237;  // sqrt(2)
000692 0E05       03086 	MOVLW 5
000694 6FB3       03087 	MOVWF arg2f24,1
000696 0E35       03088 	MOVLW 53
000698 6FB4       03089 	MOVWF arg2f24+1,1
00069A 0E7F       03090 	MOVLW 127
00069C 6FB5       03091 	MOVWF arg2f24+2,1
00069E DD56       03092 	RCALL _fmul24
                  03093 			;
                  03094 			;    // divide exponent by two
                  03095 			;    cexp += 127;
0006A0 0E7F       03096 m068	MOVLW 127
0006A2 0100       03097 	MOVLB 0
0006A4 27B6       03098 	ADDWF cexp,1,1
                  03099 			;    arg1f24.high8 = rr( cexp);
0006A6 31B6       03100 	RRCF  cexp,W,1
0006A8 6FB2       03101 	MOVWF arg1f24+2,1
                  03102 			;
                  03103 			;    if (!(savedFLAGS & 0x40))
0006AA BDB7       03104 	BTFSC savedFLAGS,6,1
0006AC D004       03105 	BRA   m070
                  03106 			;        FpFlags &= ~0x40;
0006AE 9DD8       03107 	BCF   FpFlags,6,1
                  03108 			;
                  03109 			;    goto _RETURN_MF;
0006B0 D002       03110 	BRA   m070
                  03111 			;
                  03112 			;  _DOMERR:
                  03113 			;    FpDomainError = 1;   //  domain error
0006B2 0100       03114 m069	MOVLB 0
0006B4 8BD8       03115 	BSF   0xD8,FpDomainError,1
                  03116 			;
                  03117 			;  _RETURN_MF:
                  03118 			;    return arg1f24;
0006B6 0100       03119 m070	MOVLB 0
0006B8 51B0       03120 	MOVF  arg1f24,W,1
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 53

ADDR   CODE       LINE  SOURCE

0006BA 0012       03121 	RETURN
                  03122 
                  03123   ; FILE Temporiz_64Mhz.h
                  03124 			;void retardo_20u(void){
                  03125 retardo_20u
                  03126 			;	
                  03127 			;		char PDel0;
                  03128 			;		#asm
                  03129 			;		;-------------------------------------------------------------
                  03130 			;		DEMORA  movlw     .78       ; 1 set numero de repeticion 
0006BC 0E4E       03131 	MOVLW 78
                  03132 			;		        movwf     PDel0     ; 1 |
0006BE 6FC5       03133 	MOVWF PDel0,1
                  03134 			;		PLoop0  clrwdt              ; 1 clear watchdog
0006C0 0004       03135 m071	CLRWDT
                  03136 			;		        decfsz    PDel0, 1  ; 1 + (1) es el tiempo 0  ?
0006C2 2FC5       03137 	DECFSZ PDel0,1,1
                  03138 			;		        goto      PLoop0    ; 2 no, loop
0006C4 EF60 F003  03139 	GOTO  m071
                  03140 			;		PDelL1  goto PDelL2         ; 2 ciclos delay
0006C8 EF66 F003  03141 	GOTO  m072
                  03142 			;		PDelL2  clrwdt              ; 1 ciclo delay
0006CC 0004       03143 m072	CLRWDT
                  03144 			;		        return              ; 2+2 Fin.
0006CE 0012       03145 	RETURN
                  03146 			;		;-------------------------------------------------------------
                  03147 			;		#endasm
                  03148 			;	
                  03149 			;}
                  03150 			;void retardo_1m(void){
                  03151 retardo_1m
                  03152 			;	char PDel0,PDel1;
                  03153 			;	#asm
                  03154 			;	;-------------------------------------------------------------
                  03155 			;	DEMORA  movlw     .15       ; 1 set numero de repeticion  (B)
0006D0 0E0F       03156 	MOVLW 15
                  03157 			;	        movwf     PDel0     ; 1 |
0006D2 6FC5       03158 	MOVWF PDel0_2,1
                  03159 			;	PLoop1  movlw     .177      ; 1 set numero de repeticion  (A)
0006D4 0EB1       03160 m073	MOVLW 177
                  03161 			;	        movwf     PDel1     ; 1 |
0006D6 6FC6       03162 	MOVWF PDel1,1
                  03163 			;	PLoop2  clrwdt              ; 1 clear watchdog
0006D8 0004       03164 m074	CLRWDT
                  03165 			;	PDelL1  goto PDelL2         ; 2 ciclos delay
0006DA EF6F F003  03166 	GOTO  m075
                  03167 			;	PDelL2  
                  03168 			;	        decfsz    PDel1, 1  ; 1 + (1) es el tiempo 0  ? (A)
0006DE 2FC6       03169 m075	DECFSZ PDel1,1,1
                  03170 			;	        goto      PLoop2    ; 2 no, loop
0006E0 EF6C F003  03171 	GOTO  m074
                  03172 			;	        decfsz    PDel0,  1 ; 1 + (1) es el tiempo 0  ? (B)
0006E4 2FC5       03173 	DECFSZ PDel0_2,1,1
                  03174 			;	        goto      PLoop1    ; 2 no, loop
0006E6 EF6A F003  03175 	GOTO  m073
                  03176 			;	PDelL3  goto PDelL4         ; 2 ciclos delay
0006EA EF77 F003  03177 	GOTO  m076
                  03178 			;	PDelL4  goto PDelL5         ; 2 ciclos delay
0006EE EF79 F003  03179 m076	GOTO  m077
                  03180 			;	PDelL5  clrwdt              ; 1 ciclo delay
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 54

ADDR   CODE       LINE  SOURCE

0006F2 0004       03181 m077	CLRWDT
                  03182 			;	        return              ; 2+2 Fin.
0006F4 0012       03183 	RETURN
                  03184 			;	;-------------------------------------------------------------
                  03185 			;	#endasm
                  03186 			;}
                  03187 			;void retardo_50m(void){
                  03188 retardo_50m
                  03189 			;	char PDel0,PDel1,PDel2;
                  03190 			;	#asm
                  03191 			;	;-------------------------------------------------------------
                  03192 			;	DEMORA  movlw     .18       ; 1 set numero de repeticion  (C)
0006F6 0E12       03193 	MOVLW 18
                  03194 			;	        movwf     PDel0     ; 1 |
0006F8 6E7F       03195 	MOVWF PDel0_3,0
                  03196 			;	PLoop0  movlw     .55       ; 1 set numero de repeticion  (B)
0006FA 0E37       03197 m078	MOVLW 55
                  03198 			;	        movwf     PDel1     ; 1 |
0006FC 6E7F       03199 	MOVWF PDel1_2,0
                  03200 			;	PLoop1  movlw     .201      ; 1 set numero de repeticion  (A)
0006FE 0EC9       03201 m079	MOVLW 201
                  03202 			;	        movwf     PDel2     ; 1 |
000700 6E7F       03203 	MOVWF PDel2,0
                  03204 			;	PLoop2  clrwdt              ; 1 clear watchdog
000702 0004       03205 m080	CLRWDT
                  03206 			;	        decfsz    PDel2, 1  ; 1 + (1) es el tiempo 0  ? (A)
000704 2E7F       03207 	DECFSZ PDel2,1,0
                  03208 			;	        goto      PLoop2    ; 2 no, loop
000706 EF81 F003  03209 	GOTO  m080
                  03210 			;	        decfsz    PDel1,  1 ; 1 + (1) es el tiempo 0  ? (B)
00070A 2E7F       03211 	DECFSZ PDel1_2,1,0
                  03212 			;	        goto      PLoop1    ; 2 no, loop
00070C EF7F F003  03213 	GOTO  m079
                  03214 			;	        decfsz    PDel0,  1 ; 1 + (1) es el tiempo 0  ? (C)
000710 2E7F       03215 	DECFSZ PDel0_3,1,0
                  03216 			;	        goto      PLoop0    ; 2 no, loop
000712 EF7D F003  03217 	GOTO  m078
                  03218 			;	PDelL1  goto PDelL2         ; 2 ciclos delay
000716 EF8D F003  03219 	GOTO  m081
                  03220 			;	PDelL2  clrwdt              ; 1 ciclo delay
00071A 0004       03221 m081	CLRWDT
                  03222 			;	        return              ; 2+2 Fin.
00071C 0012       03223 	RETURN
                  03224 			;	;-------------------------------------------------------------
                  03225 			;	#endasm
                  03226 			;}
                  03227 			;void retardo_100m(void){
                  03228 retardo_100m
                  03229 			;	char PDel0,PDel1,PDel2;
                  03230 			;	#asm
                  03231 			;	;-------------------------------------------------------------
                  03232 			;	DEMORA  movlw     .23       ; 1 set numero de repeticion  (C)
00071E 0E17       03233 	MOVLW 23
                  03234 			;	        movwf     PDel0     ; 1 |
000720 6E7F       03235 	MOVWF PDel0_4,0
                  03236 			;	PLoop0  movlw     .59       ; 1 set numero de repeticion  (B)
000722 0E3B       03237 m082	MOVLW 59
                  03238 			;	        movwf     PDel1     ; 1 |
000724 6E7F       03239 	MOVWF PDel1_3,0
                  03240 			;	PLoop1  movlw     .235      ; 1 set numero de repeticion  (A)
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 55

ADDR   CODE       LINE  SOURCE

000726 0EEB       03241 m083	MOVLW 235
                  03242 			;	        movwf     PDel2     ; 1 |
000728 6E7F       03243 	MOVWF PDel2_2,0
                  03244 			;	PLoop2  clrwdt              ; 1 clear watchdog
00072A 0004       03245 m084	CLRWDT
                  03246 			;	        clrwdt              ; 1 ciclo delay
00072C 0004       03247 	CLRWDT
                  03248 			;	        decfsz    PDel2, 1  ; 1 + (1) es el tiempo 0  ? (A)
00072E 2E7F       03249 	DECFSZ PDel2_2,1,0
                  03250 			;	        goto      PLoop2    ; 2 no, loop
000730 EF95 F003  03251 	GOTO  m084
                  03252 			;	        decfsz    PDel1,  1 ; 1 + (1) es el tiempo 0  ? (B)
000734 2E7F       03253 	DECFSZ PDel1_3,1,0
                  03254 			;	        goto      PLoop1    ; 2 no, loop
000736 EF93 F003  03255 	GOTO  m083
                  03256 			;	        decfsz    PDel0,  1 ; 1 + (1) es el tiempo 0  ? (C)
00073A 2E7F       03257 	DECFSZ PDel0_4,1,0
                  03258 			;	        goto      PLoop0    ; 2 no, loop
00073C EF91 F003  03259 	GOTO  m082
                  03260 			;	        return              ; 2+2 Fin.
000740 0012       03261 	RETURN
                  03262 			;	;-------------------------------------------------------------
                  03263 			;	#endasm
                  03264 			;}
                  03265 			;void retardo_500m(void){
                  03266 retardo_500m
                  03267 			;	char PDel0,PDel1,PDel2;
                  03268 			;	#asm
                  03269 			;	;-------------------------------------------------------------
                  03270 			;	DEMORA  movlw     .54       ; 1 set numero de repeticion  (C)
000742 0E36       03271 	MOVLW 54
                  03272 			;	        movwf     PDel0     ; 1 |
000744 6E7F       03273 	MOVWF PDel0_5,0
                  03274 			;	PLoop0  movlw     .188      ; 1 set numero de repeticion  (B)
000746 0EBC       03275 m085	MOVLW 188
                  03276 			;	        movwf     PDel1     ; 1 |
000748 6E7F       03277 	MOVWF PDel1_4,0
                  03278 			;	PLoop1  movlw     .196      ; 1 set numero de repeticion  (A)
00074A 0EC4       03279 m086	MOVLW 196
                  03280 			;	        movwf     PDel2     ; 1 |
00074C 6E7F       03281 	MOVWF PDel2_3,0
                  03282 			;	PLoop2  clrwdt              ; 1 clear watchdog
00074E 0004       03283 m087	CLRWDT
                  03284 			;	        decfsz    PDel2, 1  ; 1 + (1) es el tiempo 0  ? (A)
000750 2E7F       03285 	DECFSZ PDel2_3,1,0
                  03286 			;	        goto      PLoop2    ; 2 no, loop
000752 EFA7 F003  03287 	GOTO  m087
                  03288 			;	        decfsz    PDel1,  1 ; 1 + (1) es el tiempo 0  ? (B)
000756 2E7F       03289 	DECFSZ PDel1_4,1,0
                  03290 			;	        goto      PLoop1    ; 2 no, loop
000758 EFA5 F003  03291 	GOTO  m086
                  03292 			;	        decfsz    PDel0,  1 ; 1 + (1) es el tiempo 0  ? (C)
00075C 2E7F       03293 	DECFSZ PDel0_5,1,0
                  03294 			;	        goto      PLoop0    ; 2 no, loop
00075E EFA3 F003  03295 	GOTO  m085
                  03296 			;	PDelL1  goto PDelL2         ; 2 ciclos delay
000762 EFB3 F003  03297 	GOTO  m088
                  03298 			;	PDelL2  clrwdt              ; 1 ciclo delay
000766 0004       03299 m088	CLRWDT
                  03300 			;	        return              ; 2+2 Fin.
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 56

ADDR   CODE       LINE  SOURCE

000768 0012       03301 	RETURN
                  03302 			;	;-------------------------------------------------------------
                  03303 			;	#endasm
                  03304 
                  03305   ; FILE LCD_4bit.h
                  03306 			;
                  03307 			;/*
                  03308 			;	ESTA LIBRERIA NO SIRVE PARA LA PLACA DE PROTOTIPOS 
                  03309 			;	ES SOLO PARA LA PLACA DEL ONDULADOR!!!!!
                  03310 			;*/
                  03311 			;
                  03312 			;void envia_codigo_inicial (char codigo)
                  03313 			;{
                  03314 envia_codigo_inicial
00076A 0100       03315 	MOVLB 0
00076C 6FA8       03316 	MOVWF codigo,1
                  03317 			;	PORTB.5=0;nop();
00076E 9A81       03318 	BCF   PORTB,5,0
000770 0000       03319 	NOP  
                  03320 			;	PORTB.3 = codigo.4;
000772 A9A8       03321 	BTFSS codigo,4,1
000774 9681       03322 	BCF   PORTB,3,0
000776 B9A8       03323 	BTFSC codigo,4,1
000778 8681       03324 	BSF   PORTB,3,0
                  03325 			;	nop();
00077A 0000       03326 	NOP  
                  03327 			;	PORTB.2 = codigo.5;
00077C ABA8       03328 	BTFSS codigo,5,1
00077E 9481       03329 	BCF   PORTB,2,0
000780 BBA8       03330 	BTFSC codigo,5,1
000782 8481       03331 	BSF   PORTB,2,0
                  03332 			;	nop();
000784 0000       03333 	NOP  
                  03334 			;	PORTB.1 = codigo.6;
000786 ADA8       03335 	BTFSS codigo,6,1
000788 9281       03336 	BCF   PORTB,1,0
00078A BDA8       03337 	BTFSC codigo,6,1
00078C 8281       03338 	BSF   PORTB,1,0
                  03339 			;	nop();
00078E 0000       03340 	NOP  
                  03341 			;	PORTB.0 = codigo.7;
000790 AFA8       03342 	BTFSS codigo,7,1
000792 9081       03343 	BCF   PORTB,0,0
000794 BFA8       03344 	BTFSC codigo,7,1
000796 8081       03345 	BSF   PORTB,0,0
                  03346 			;	nop();
000798 0000       03347 	NOP  
                  03348 			;	PORTB.4 = 1; 
00079A 8881       03349 	BSF   PORTB,4,0
                  03350 			;	retardo_20u();
00079C DF8F       03351 	RCALL retardo_20u
                  03352 			;	PORTB.4 = 0; 
00079E 9881       03353 	BCF   PORTB,4,0
                  03354 			;
                  03355 			;	return;
0007A0 0012       03356 	RETURN
                  03357 			;}
                  03358 			; 
                  03359 			;void enviar_comando (char comando) 
                  03360 			;{
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 57

ADDR   CODE       LINE  SOURCE

                  03361 enviar_comando
0007A2 0100       03362 	MOVLB 0
0007A4 6FC4       03363 	MOVWF comando,1
                  03364 			;	
                  03365 			;	PORTB.3 =  comando.4;nop();
0007A6 A9C4       03366 	BTFSS comando,4,1
0007A8 9681       03367 	BCF   PORTB,3,0
0007AA B9C4       03368 	BTFSC comando,4,1
0007AC 8681       03369 	BSF   PORTB,3,0
0007AE 0000       03370 	NOP  
                  03371 			;	PORTB.2 =  comando.5;nop();
0007B0 ABC4       03372 	BTFSS comando,5,1
0007B2 9481       03373 	BCF   PORTB,2,0
0007B4 BBC4       03374 	BTFSC comando,5,1
0007B6 8481       03375 	BSF   PORTB,2,0
0007B8 0000       03376 	NOP  
                  03377 			;	PORTB.1 =  comando.6;nop();
0007BA ADC4       03378 	BTFSS comando,6,1
0007BC 9281       03379 	BCF   PORTB,1,0
0007BE BDC4       03380 	BTFSC comando,6,1
0007C0 8281       03381 	BSF   PORTB,1,0
0007C2 0000       03382 	NOP  
                  03383 			;	PORTB.0 =  comando.7;
0007C4 AFC4       03384 	BTFSS comando,7,1
0007C6 9081       03385 	BCF   PORTB,0,0
0007C8 BFC4       03386 	BTFSC comando,7,1
0007CA 8081       03387 	BSF   PORTB,0,0
                  03388 			;	retardo_1m ();
0007CC DF81       03389 	RCALL retardo_1m
                  03390 			;	PORTB.5 = 0;  									// Modo comando.
0007CE 9A81       03391 	BCF   PORTB,5,0
                  03392 			;	retardo_20u (); //
0007D0 DF75       03393 	RCALL retardo_20u
                  03394 			;	PORTB.4 = 1;  									// Breve pulso.
0007D2 8881       03395 	BSF   PORTB,4,0
                  03396 			;	retardo_20u ();
0007D4 DF73       03397 	RCALL retardo_20u
                  03398 			;	PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
0007D6 9881       03399 	BCF   PORTB,4,0
                  03400 			;	retardo_1m ();
0007D8 DF7B       03401 	RCALL retardo_1m
                  03402 			;	retardo_1m ();
0007DA DF7A       03403 	RCALL retardo_1m
                  03404 			;	comando = swap (comando);
0007DC 0100       03405 	MOVLB 0
0007DE 3BC4       03406 	SWAPF comando,1,1
                  03407 			;	PORTB.3 =  comando.4;nop();
0007E0 A9C4       03408 	BTFSS comando,4,1
0007E2 9681       03409 	BCF   PORTB,3,0
0007E4 B9C4       03410 	BTFSC comando,4,1
0007E6 8681       03411 	BSF   PORTB,3,0
0007E8 0000       03412 	NOP  
                  03413 			;	PORTB.2 =  comando.5;nop();
0007EA ABC4       03414 	BTFSS comando,5,1
0007EC 9481       03415 	BCF   PORTB,2,0
0007EE BBC4       03416 	BTFSC comando,5,1
0007F0 8481       03417 	BSF   PORTB,2,0
0007F2 0000       03418 	NOP  
                  03419 			;	PORTB.1 =  comando.6;nop();
0007F4 ADC4       03420 	BTFSS comando,6,1
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 58

ADDR   CODE       LINE  SOURCE

0007F6 9281       03421 	BCF   PORTB,1,0
0007F8 BDC4       03422 	BTFSC comando,6,1
0007FA 8281       03423 	BSF   PORTB,1,0
0007FC 0000       03424 	NOP  
                  03425 			;	PORTB.0 =  comando.7;nop();
0007FE AFC4       03426 	BTFSS comando,7,1
000800 9081       03427 	BCF   PORTB,0,0
000802 BFC4       03428 	BTFSC comando,7,1
000804 8081       03429 	BSF   PORTB,0,0
000806 0000       03430 	NOP  
                  03431 			;	retardo_1m ();
000808 DF63       03432 	RCALL retardo_1m
                  03433 			;	PORTB.5 = 0;  									// Modo comando.
00080A 9A81       03434 	BCF   PORTB,5,0
                  03435 			;	retardo_20u ();
00080C DF57       03436 	RCALL retardo_20u
                  03437 			;	PORTB.4 = 1;  									// Breve pulso.
00080E 8881       03438 	BSF   PORTB,4,0
                  03439 			;	retardo_20u ();
000810 DF55       03440 	RCALL retardo_20u
                  03441 			;	PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
000812 9881       03442 	BCF   PORTB,4,0
                  03443 			;	retardo_1m ();
000814 DF5D       03444 	RCALL retardo_1m
                  03445 			;	retardo_1m ();
000816 D75C       03446 	BRA   retardo_1m
                  03447 			;	//leds_OFF (10);
                  03448 			;	
                  03449 			;	
                  03450 			;	return;
                  03451 			;}    
                  03452 			;
                  03453 			;void enviar_literal (char dato) 
                  03454 			;{
                  03455 enviar_literal
000818 0100       03456 	MOVLB 0
00081A 6FA8       03457 	MOVWF dato,1
                  03458 			;    char i;
                  03459 			;
                  03460 			;	
                  03461 			;	PORTB.3 = dato.4;
00081C A9A8       03462 	BTFSS dato,4,1
00081E 9681       03463 	BCF   PORTB,3,0
000820 B9A8       03464 	BTFSC dato,4,1
000822 8681       03465 	BSF   PORTB,3,0
                  03466 			;	nop();
000824 0000       03467 	NOP  
                  03468 			;	PORTB.2 = dato.5;
000826 ABA8       03469 	BTFSS dato,5,1
000828 9481       03470 	BCF   PORTB,2,0
00082A BBA8       03471 	BTFSC dato,5,1
00082C 8481       03472 	BSF   PORTB,2,0
                  03473 			;	nop();
00082E 0000       03474 	NOP  
                  03475 			;	PORTB.1 = dato.6;
000830 ADA8       03476 	BTFSS dato,6,1
000832 9281       03477 	BCF   PORTB,1,0
000834 BDA8       03478 	BTFSC dato,6,1
000836 8281       03479 	BSF   PORTB,1,0
                  03480 			;	nop();
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 59

ADDR   CODE       LINE  SOURCE

000838 0000       03481 	NOP  
                  03482 			;	PORTB.0 = dato.7;
00083A AFA8       03483 	BTFSS dato,7,1
00083C 9081       03484 	BCF   PORTB,0,0
00083E BFA8       03485 	BTFSC dato,7,1
000840 8081       03486 	BSF   PORTB,0,0
                  03487 			;	nop();
000842 0000       03488 	NOP  
                  03489 			;	PORTB.5 = 1;  									// Modo dato.
000844 8A81       03490 	BSF   PORTB,5,0
                  03491 			;	retardo_20u ();
000846 DF3A       03492 	RCALL retardo_20u
                  03493 			;	PORTB.4 = 1;  									// Breve pulso.
000848 8881       03494 	BSF   PORTB,4,0
                  03495 			;	retardo_20u ();
00084A DF38       03496 	RCALL retardo_20u
                  03497 			;	PORTB.4 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
00084C 9881       03498 	BCF   PORTB,4,0
                  03499 			;	for (i = 1; i <= 6; i++) retardo_20u ();
00084E 0E01       03500 	MOVLW 1
000850 0100       03501 	MOVLB 0
000852 6FA9       03502 	MOVWF i_3,1
000854 0E07       03503 m089	MOVLW 7
000856 0100       03504 	MOVLB 0
000858 61A9       03505 	CPFSLT i_3,1
00085A D004       03506 	BRA   m090
00085C DF2F       03507 	RCALL retardo_20u
00085E 0100       03508 	MOVLB 0
000860 2BA9       03509 	INCF  i_3,1,1
000862 D7F8       03510 	BRA   m089
                  03511 			;	dato = swap (dato);
000864 0100       03512 m090	MOVLB 0
000866 3BA8       03513 	SWAPF dato,1,1
                  03514 			;	PORTB.3 = dato.4;nop();
000868 A9A8       03515 	BTFSS dato,4,1
00086A 9681       03516 	BCF   PORTB,3,0
00086C B9A8       03517 	BTFSC dato,4,1
00086E 8681       03518 	BSF   PORTB,3,0
000870 0000       03519 	NOP  
                  03520 			;	PORTB.2 = dato.5;nop();
000872 ABA8       03521 	BTFSS dato,5,1
000874 9481       03522 	BCF   PORTB,2,0
000876 BBA8       03523 	BTFSC dato,5,1
000878 8481       03524 	BSF   PORTB,2,0
00087A 0000       03525 	NOP  
                  03526 			;	PORTB.1 = dato.6;nop();
00087C ADA8       03527 	BTFSS dato,6,1
00087E 9281       03528 	BCF   PORTB,1,0
000880 BDA8       03529 	BTFSC dato,6,1
000882 8281       03530 	BSF   PORTB,1,0
000884 0000       03531 	NOP  
                  03532 			;	PORTB.0 = dato.7;nop();
000886 AFA8       03533 	BTFSS dato,7,1
000888 9081       03534 	BCF   PORTB,0,0
00088A BFA8       03535 	BTFSC dato,7,1
00088C 8081       03536 	BSF   PORTB,0,0
00088E 0000       03537 	NOP  
                  03538 			;	retardo_1m ();
000890 DF1F       03539 	RCALL retardo_1m
                  03540 			;	PORTB.5 = 1;  									// Modo dato.
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 60

ADDR   CODE       LINE  SOURCE

000892 8A81       03541 	BSF   PORTB,5,0
                  03542 			;	retardo_1m ();
000894 DF1D       03543 	RCALL retardo_1m
                  03544 			;	PORTB.4 = 1;  									// Breve pulso.
000896 8881       03545 	BSF   PORTB,4,0
                  03546 			;	retardo_20u ();
000898 DF11       03547 	RCALL retardo_20u
                  03548 			;	PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
00089A 9881       03549 	BCF   PORTB,4,0
                  03550 			;	for (i = 1; i<= 6; i++) retardo_20u ();
00089C 0E01       03551 	MOVLW 1
00089E 0100       03552 	MOVLB 0
0008A0 6FA9       03553 	MOVWF i_3,1
0008A2 0E07       03554 m091	MOVLW 7
0008A4 0100       03555 	MOVLB 0
0008A6 61A9       03556 	CPFSLT i_3,1
0008A8 D004       03557 	BRA   m092
0008AA DF08       03558 	RCALL retardo_20u
0008AC 0100       03559 	MOVLB 0
0008AE 2BA9       03560 	INCF  i_3,1,1
0008B0 D7F8       03561 	BRA   m091
                  03562 			;	enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.	
0008B2 0E0C       03563 m092	MOVLW 12
0008B4 D776       03564 	BRA   enviar_comando
                  03565 			;	return;
                  03566 			;}   
                  03567 			;
                  03568 			;void enviar_cifra (char dato) 
                  03569 			;{
                  03570 enviar_cifra
0008B6 6E7F       03571 	MOVWF dato_2,0
                  03572 			;    char i;
                  03573 			;	dato = dato + 0x30; 							// Convierto el nmero en su equivalente ASCII literal. 
0008B8 0E30       03574 	MOVLW 48
0008BA 267F       03575 	ADDWF dato_2,1,0
                  03576 			;	PORTB.3 = dato.4;
0008BC A87F       03577 	BTFSS dato_2,4,0
0008BE 9681       03578 	BCF   PORTB,3,0
0008C0 B87F       03579 	BTFSC dato_2,4,0
0008C2 8681       03580 	BSF   PORTB,3,0
                  03581 			;	nop();
0008C4 0000       03582 	NOP  
                  03583 			;	PORTB.2 = dato.5;
0008C6 AA7F       03584 	BTFSS dato_2,5,0
0008C8 9481       03585 	BCF   PORTB,2,0
0008CA BA7F       03586 	BTFSC dato_2,5,0
0008CC 8481       03587 	BSF   PORTB,2,0
                  03588 			;	nop();
0008CE 0000       03589 	NOP  
                  03590 			;	PORTB.1 = dato.6;
0008D0 AC7F       03591 	BTFSS dato_2,6,0
0008D2 9281       03592 	BCF   PORTB,1,0
0008D4 BC7F       03593 	BTFSC dato_2,6,0
0008D6 8281       03594 	BSF   PORTB,1,0
                  03595 			;	nop();
0008D8 0000       03596 	NOP  
                  03597 			;	PORTB.0 = dato.7;
0008DA AE7F       03598 	BTFSS dato_2,7,0
0008DC 9081       03599 	BCF   PORTB,0,0
0008DE BE7F       03600 	BTFSC dato_2,7,0
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 61

ADDR   CODE       LINE  SOURCE

0008E0 8081       03601 	BSF   PORTB,0,0
                  03602 			;	nop();
0008E2 0000       03603 	NOP  
                  03604 			;	PORTB.5 = 1;  									// Modo dato.
0008E4 8A81       03605 	BSF   PORTB,5,0
                  03606 			;	retardo_20u ();
0008E6 DEEA       03607 	RCALL retardo_20u
                  03608 			;	PORTB.4 = 1;  									// Breve pulso.
0008E8 8881       03609 	BSF   PORTB,4,0
                  03610 			;	retardo_20u ();
0008EA DEE8       03611 	RCALL retardo_20u
                  03612 			;	PORTB.4 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
0008EC 9881       03613 	BCF   PORTB,4,0
                  03614 			;	for (i = 1; i <= 6; i++) retardo_20u ();
0008EE 0E01       03615 	MOVLW 1
0008F0 6E7F       03616 	MOVWF i_4,0
0008F2 0E07       03617 m093	MOVLW 7
0008F4 607F       03618 	CPFSLT i_4,0
0008F6 D003       03619 	BRA   m094
0008F8 DEE1       03620 	RCALL retardo_20u
0008FA 2A7F       03621 	INCF  i_4,1,0
0008FC D7FA       03622 	BRA   m093
                  03623 			;	dato = swap (dato);
0008FE 3A7F       03624 m094	SWAPF dato_2,1,0
                  03625 			;	PORTB.3 = dato.4;
000900 A87F       03626 	BTFSS dato_2,4,0
000902 9681       03627 	BCF   PORTB,3,0
000904 B87F       03628 	BTFSC dato_2,4,0
000906 8681       03629 	BSF   PORTB,3,0
                  03630 			;	nop();
000908 0000       03631 	NOP  
                  03632 			;	PORTB.2 = dato.5;
00090A AA7F       03633 	BTFSS dato_2,5,0
00090C 9481       03634 	BCF   PORTB,2,0
00090E BA7F       03635 	BTFSC dato_2,5,0
000910 8481       03636 	BSF   PORTB,2,0
                  03637 			;	nop();
000912 0000       03638 	NOP  
                  03639 			;	PORTB.1 = dato.6;
000914 AC7F       03640 	BTFSS dato_2,6,0
000916 9281       03641 	BCF   PORTB,1,0
000918 BC7F       03642 	BTFSC dato_2,6,0
00091A 8281       03643 	BSF   PORTB,1,0
                  03644 			;	nop();
00091C 0000       03645 	NOP  
                  03646 			;	PORTB.0 = dato.7;
00091E AE7F       03647 	BTFSS dato_2,7,0
000920 9081       03648 	BCF   PORTB,0,0
000922 BE7F       03649 	BTFSC dato_2,7,0
000924 8081       03650 	BSF   PORTB,0,0
                  03651 			;	retardo_1m ();
000926 DED4       03652 	RCALL retardo_1m
                  03653 			;	PORTB.5 = 1;  									// Modo dato.
000928 8A81       03654 	BSF   PORTB,5,0
                  03655 			;	retardo_1m ();
00092A DED2       03656 	RCALL retardo_1m
                  03657 			;	PORTB.4 = 1;  									// Breve pulso.
00092C 8881       03658 	BSF   PORTB,4,0
                  03659 			;	retardo_20u ();
00092E DEC6       03660 	RCALL retardo_20u
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 62

ADDR   CODE       LINE  SOURCE

                  03661 			;	PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
000930 9881       03662 	BCF   PORTB,4,0
                  03663 			;	for (i = 1; i<= 6; i++) retardo_20u ();
000932 0E01       03664 	MOVLW 1
000934 6E7F       03665 	MOVWF i_4,0
000936 0E07       03666 m095	MOVLW 7
000938 607F       03667 	CPFSLT i_4,0
00093A D003       03668 	BRA   m096
00093C DEBF       03669 	RCALL retardo_20u
00093E 2A7F       03670 	INCF  i_4,1,0
000940 D7FA       03671 	BRA   m095
                  03672 			;	enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.
000942 0E0C       03673 m096	MOVLW 12
000944 D72E       03674 	BRA   enviar_comando
                  03675 			;	return;
                  03676 			;} 
                  03677 			;
                  03678 			;void inicializar_lcd (void) 
                  03679 			;{
                  03680 inicializar_lcd
                  03681 			;	char i;
                  03682 			;	clrwdt () ;	
000946 0004       03683 	CLRWDT
                  03684 			;	for (i = 1; i < 21; i++) retardo_1m ();    
000948 0E01       03685 	MOVLW 1
00094A 0100       03686 	MOVLB 0
00094C 6FA7       03687 	MOVWF i_5,1
00094E 0E15       03688 m097	MOVLW 21
000950 0100       03689 	MOVLB 0
000952 61A7       03690 	CPFSLT i_5,1
000954 D004       03691 	BRA   m098
000956 DEBC       03692 	RCALL retardo_1m
000958 0100       03693 	MOVLB 0
00095A 2BA7       03694 	INCF  i_5,1,1
00095C D7F8       03695 	BRA   m097
                  03696 			;	envia_codigo_inicial (0b.00.11.0000);
00095E 0E30       03697 m098	MOVLW 48
000960 DF04       03698 	RCALL envia_codigo_inicial
                  03699 			;	for (i = 1; i < 6; i++) retardo_1m ();
000962 0E01       03700 	MOVLW 1
000964 0100       03701 	MOVLB 0
000966 6FA7       03702 	MOVWF i_5,1
000968 0E06       03703 m099	MOVLW 6
00096A 0100       03704 	MOVLB 0
00096C 61A7       03705 	CPFSLT i_5,1
00096E D004       03706 	BRA   m100
000970 DEAF       03707 	RCALL retardo_1m
000972 0100       03708 	MOVLB 0
000974 2BA7       03709 	INCF  i_5,1,1
000976 D7F8       03710 	BRA   m099
                  03711 			;    envia_codigo_inicial (0b.00.11.0000);	
000978 0E30       03712 m100	MOVLW 48
00097A DEF7       03713 	RCALL envia_codigo_inicial
                  03714 			;	for (i = 1; i< 11; i++) retardo_20u ();
00097C 0E01       03715 	MOVLW 1
00097E 0100       03716 	MOVLB 0
000980 6FA7       03717 	MOVWF i_5,1
000982 0E0B       03718 m101	MOVLW 11
000984 0100       03719 	MOVLB 0
000986 61A7       03720 	CPFSLT i_5,1
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 63

ADDR   CODE       LINE  SOURCE

000988 D004       03721 	BRA   m102
00098A DE98       03722 	RCALL retardo_20u
00098C 0100       03723 	MOVLB 0
00098E 2BA7       03724 	INCF  i_5,1,1
000990 D7F8       03725 	BRA   m101
                  03726 			;    envia_codigo_inicial (0b.00.11.0000);
000992 0E30       03727 m102	MOVLW 48
000994 DEEA       03728 	RCALL envia_codigo_inicial
                  03729 			;	for (i = 1; i < 11; i++) retardo_20u ();
000996 0E01       03730 	MOVLW 1
000998 0100       03731 	MOVLB 0
00099A 6FA7       03732 	MOVWF i_5,1
00099C 0E0B       03733 m103	MOVLW 11
00099E 0100       03734 	MOVLB 0
0009A0 61A7       03735 	CPFSLT i_5,1
0009A2 D004       03736 	BRA   m104
0009A4 DE8B       03737 	RCALL retardo_20u
0009A6 0100       03738 	MOVLB 0
0009A8 2BA7       03739 	INCF  i_5,1,1
0009AA D7F8       03740 	BRA   m103
                  03741 			;	envia_codigo_inicial (0b.00.10.0000);			// A 4 bits.
0009AC 0E20       03742 m104	MOVLW 32
0009AE DEDD       03743 	RCALL envia_codigo_inicial
                  03744 			;	enviar_comando (0b.0010.1000);					// A 4 bits, doble lnea, caracteres 5x7.
0009B0 0E28       03745 	MOVLW 40
0009B2 DEF7       03746 	RCALL enviar_comando
                  03747 			;	enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.
0009B4 0E0C       03748 	MOVLW 12
0009B6 DEF5       03749 	RCALL enviar_comando
                  03750 			;	enviar_comando (0b.0000.0010);  				// Cursor en home, inicio de primera linea.
0009B8 0E02       03751 	MOVLW 2
0009BA D6F3       03752 	BRA   enviar_comando
                  03753 			;	return;
                  03754 			;}
                  03755 			;
                  03756 			;void escribir_posicion (char linea, char columna)
                  03757 			;{
                  03758 escribir_posicion
0009BC 0100       03759 	MOVLB 0
0009BE 6FA8       03760 	MOVWF columna,1
                  03761 			;	
                  03762 			;	switch (linea) 									// (se resta una unidad a la coordenada lnea para que la posicin colum
                           na inicial sea 1 y no 0).
0009C0 51A7       03763 	MOVF  linea,W,1
0009C2 0A01       03764 	XORLW 1
0009C4 B4D8       03765 	BTFSC 0xFD8,Zero_,0
0009C6 D00A       03766 	BRA   m105
0009C8 0A03       03767 	XORLW 3
0009CA B4D8       03768 	BTFSC 0xFD8,Zero_,0
0009CC D00C       03769 	BRA   m106
0009CE 0A01       03770 	XORLW 1
0009D0 B4D8       03771 	BTFSC 0xFD8,Zero_,0
0009D2 D00E       03772 	BRA   m107
0009D4 0A07       03773 	XORLW 7
0009D6 B4D8       03774 	BTFSC 0xFD8,Zero_,0
0009D8 D010       03775 	BRA   m108
0009DA D016       03776 	BRA   m109
                  03777 			;		{
                  03778 			;			case 1:
                  03779 			;				enviar_comando (127 + columna); 	// Inicio primera linea.
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 64

ADDR   CODE       LINE  SOURCE

0009DC 0E7F       03780 m105	MOVLW 127
0009DE 0100       03781 	MOVLB 0
0009E0 25A8       03782 	ADDWF columna,W,1
0009E2 DEDF       03783 	RCALL enviar_comando
                  03784 			;			break;
0009E4 D011       03785 	BRA   m109
                  03786 			;						
                  03787 			;			case 2:
                  03788 			;				enviar_comando (191 + columna); 	// Inicio segunda lnea.
0009E6 0EBF       03789 m106	MOVLW 191
0009E8 0100       03790 	MOVLB 0
0009EA 25A8       03791 	ADDWF columna,W,1
0009EC DEDA       03792 	RCALL enviar_comando
                  03793 			;			break;			
0009EE D00C       03794 	BRA   m109
                  03795 			;
                  03796 			;			case 3:
                  03797 			;				enviar_comando (147 + columna);		// Inicio tercera lnea (cursor en posicin 20 de la primera lnea).
0009F0 0E93       03798 m107	MOVLW 147
0009F2 0100       03799 	MOVLB 0
0009F4 25A8       03800 	ADDWF columna,W,1
0009F6 DED5       03801 	RCALL enviar_comando
                  03802 			;			break;				
0009F8 D007       03803 	BRA   m109
                  03804 			;			
                  03805 			;			case 4:
                  03806 			;				enviar_comando (211 + columna); 	// Inicio cuarta lnea (cursor en posicin 20 de la segunda lnea).
0009FA 0ED3       03807 m108	MOVLW 211
0009FC 0100       03808 	MOVLB 0
0009FE 25A8       03809 	ADDWF columna,W,1
000A00 DED0       03810 	RCALL enviar_comando
                  03811 			;			break;
000A02 D002       03812 	BRA   m109
                  03813 			;			enviar_comando (0b.0000.1100);			// Pantalla encendida, sin cursor.
000A04 0E0C       03814 	MOVLW 12
000A06 D6CD       03815 	BRA   enviar_comando
                  03816 			;		}
                  03817 			;	
                  03818 			;	
                  03819 			;}
000A08 0012       03820 m109	RETURN
                  03821 			;
                  03822 			;void borrar_linea (char linea)
                  03823 			;{
                  03824 borrar_linea
000A0A 6E7F       03825 	MOVWF linea_2,0
                  03826 			;	char i;
                  03827 			;		
                  03828 			;	switch (linea) 									// (se resta una unidad a la coordenada lnea para que la posicin colum
                           na inicial sea 1 y no 0).
000A0C 507F       03829 	MOVF  linea_2,W,0
000A0E 0A01       03830 	XORLW 1
000A10 B4D8       03831 	BTFSC 0xFD8,Zero_,0
000A12 D00A       03832 	BRA   m110
000A14 0A03       03833 	XORLW 3
000A16 B4D8       03834 	BTFSC 0xFD8,Zero_,0
000A18 D00A       03835 	BRA   m111
000A1A 0A01       03836 	XORLW 1
000A1C B4D8       03837 	BTFSC 0xFD8,Zero_,0
000A1E D00A       03838 	BRA   m112
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 65

ADDR   CODE       LINE  SOURCE

000A20 0A07       03839 	XORLW 7
000A22 B4D8       03840 	BTFSC 0xFD8,Zero_,0
000A24 D00A       03841 	BRA   m113
000A26 D00B       03842 	BRA   m114
                  03843 			;		{
                  03844 			;			case 1:
                  03845 			;				enviar_comando (128); 				// Inicio primera linea.
000A28 0E80       03846 m110	MOVLW 128
000A2A DEBB       03847 	RCALL enviar_comando
                  03848 			;			break;
000A2C D008       03849 	BRA   m114
                  03850 			;						
                  03851 			;			case 2:
                  03852 			;				enviar_comando (192); 				// Inicio segunda lnea.
000A2E 0EC0       03853 m111	MOVLW 192
000A30 DEB8       03854 	RCALL enviar_comando
                  03855 			;			break;			
000A32 D005       03856 	BRA   m114
                  03857 			;
                  03858 			;			case 3:
                  03859 			;				enviar_comando (148); 				// Inicio tercera lnea (cursor en posicin 20 de la primera lnea).
000A34 0E94       03860 m112	MOVLW 148
000A36 DEB5       03861 	RCALL enviar_comando
                  03862 			;			break;				
000A38 D002       03863 	BRA   m114
                  03864 			;			
                  03865 			;			case 4:
                  03866 			;				enviar_comando (212); 				// Inicio cuarta lnea (cursor en posicin 20 de la segunda lnea).
000A3A 0ED4       03867 m113	MOVLW 212
000A3C DEB2       03868 	RCALL enviar_comando
                  03869 			;			break;
                  03870 			;		}
                  03871 			;	for (i = 1; i < 21; i++) enviar_literal (' '); 	// Envio 20 carcteres en blanco y posiciono en la siguiente lnea.
000A3E 0E01       03872 m114	MOVLW 1
000A40 6E7F       03873 	MOVWF i_6,0
000A42 0E15       03874 m115	MOVLW 21
000A44 607F       03875 	CPFSLT i_6,0
000A46 D004       03876 	BRA   m116
000A48 0E20       03877 	MOVLW 32
000A4A DEE6       03878 	RCALL enviar_literal
000A4C 2A7F       03879 	INCF  i_6,1,0
000A4E D7F9       03880 	BRA   m115
                  03881 			;	enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.	
000A50 0E0C       03882 m116	MOVLW 12
000A52 D6A7       03883 	BRA   enviar_comando
                  03884 			;}
                  03885 			;
                  03886 			;void borrar_lcd (void)
                  03887 			;{
                  03888 borrar_lcd
                  03889 			;	enviar_comando (0b.0000.0001);  				// Borrado del display y cursor en la posicin inicial.	
000A54 0E01       03890 	MOVLW 1
000A56 D6A5       03891 	BRA   enviar_comando
                  03892 			;}
                  03893 			;
                  03894 			;void Enviar_lcd (char linea, char columna, uns16 dato, bit bd, bit dp, bit xi,bit ndp)
                  03895 			;            //fila , col , uns16 , bd -> si 0 posa espai si "0" a l'esquerra ,, dp -> si "0"--> posa punt decimal
                  03896 			;{
                  03897 Enviar_lcd
                  03898 			;// Aquesta funcio, posiciona Fila i Columna d'un LCD 4x20 i envia una xifra uns16 descomposant-la i posant 
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 66

ADDR   CODE       LINE  SOURCE

                  03899 			;//  decimal o no, segons sigui dp, si "0"--> posa punt decimal , si dp "1" -> no posa dp
                  03900 			;//  si bd = "0" -> posa espai, si bd = "1"  --> No  posa espai i posa el 0.
                  03901 			;// si xi = 0 -> 3 xifres,, si xi = 1  -> 4 xifres
                  03902 			;// Atencio, amb dp S'UTILIZA un ESPAI MES
                  03903 			;// amb 4 xifres, tambe es representen 3, pero es gasta un espai de mes.
                  03904 			;// ESPI utilitzat...3 per 3 xifres,, 4 per 3xifres + dp   O 4xifres s/dp ,, 5 per 4 xifres + dp
                  03905 			;// ndp ..si "0"...1decimal... si "1"   2 decimals
                  03906 			;	uns16 num, u_milers, cent;
                  03907 			;	char dec, unid, resto1;
                  03908 			;	char i, xx, yy, dat,xy;
                  03909 			;	
                  03910 			;	//CON_LCD ();
                  03911 			;	//posiciono
                  03912 			;	switch (linea) 									// (se resta una unidad a la coordenada lnea para que la posicin colum
                           na inicial sea 1 y no 0).
000A58 507F       03913 	MOVF  linea_3,W,0
000A5A 0A01       03914 	XORLW 1
000A5C B4D8       03915 	BTFSC 0xFD8,Zero_,0
000A5E D00A       03916 	BRA   m117
000A60 0A03       03917 	XORLW 3
000A62 B4D8       03918 	BTFSC 0xFD8,Zero_,0
000A64 D00B       03919 	BRA   m118
000A66 0A01       03920 	XORLW 1
000A68 B4D8       03921 	BTFSC 0xFD8,Zero_,0
000A6A D00C       03922 	BRA   m119
000A6C 0A07       03923 	XORLW 7
000A6E B4D8       03924 	BTFSC 0xFD8,Zero_,0
000A70 D00D       03925 	BRA   m120
000A72 D012       03926 	BRA   m121
                  03927 			;		{
                  03928 			;			case 1:	enviar_comando (127 + columna); 	// inicio primera linea.
000A74 0E7F       03929 m117	MOVLW 127
000A76 247F       03930 	ADDWF columna_2,W,0
000A78 DE94       03931 	RCALL enviar_comando
                  03932 			;			break;	
000A7A D00E       03933 	BRA   m121
                  03934 			;			case 2:	enviar_comando (191 + columna); 	// inicio segunda lnea.
000A7C 0EBF       03935 m118	MOVLW 191
000A7E 247F       03936 	ADDWF columna_2,W,0
000A80 DE90       03937 	RCALL enviar_comando
                  03938 			;			break;			
000A82 D00A       03939 	BRA   m121
                  03940 			;			case 3:	enviar_comando (147 + columna); 	// inicio tercera lnea (cursor en posicin 20 de la primera lnea).
000A84 0E93       03941 m119	MOVLW 147
000A86 247F       03942 	ADDWF columna_2,W,0
000A88 DE8C       03943 	RCALL enviar_comando
                  03944 			;			break;				
000A8A D006       03945 	BRA   m121
                  03946 			;			case 4:	enviar_comando (211 + columna); 	// inicio cuarta lnea (cursor en posicin 20 de la segunda lnea).
000A8C 0ED3       03947 m120	MOVLW 211
000A8E 247F       03948 	ADDWF columna_2,W,0
000A90 DE88       03949 	RCALL enviar_comando
                  03950 			;			break;	
000A92 D002       03951 	BRA   m121
                  03952 			;			enviar_comando (0b.0000.1100);			// pantalla encendida, sin cursor
000A94 0E0C       03953 	MOVLW 12
000A96 DE85       03954 	RCALL enviar_comando
                  03955 			;		}				
                  03956 			;		if (!xi)
000A98 B07F       03957 m121	BTFSC 0xF7F,xi,0
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 67

ADDR   CODE       LINE  SOURCE

000A9A D011       03958 	BRA   m122
                  03959 			;		{
                  03960 			;			xy = 2;
000A9C 0E02       03961 	MOVLW 2
000A9E 6E7F       03962 	MOVWF xy,0
                  03963 			;			u_milers = 0;
000AA0 6A7F       03964 	CLRF  u_milers,0
000AA2 6A7F       03965 	CLRF  u_milers+1,0
                  03966 			;			if (dato > 999) { enviar_literal ('>');enviar_literal ('E');enviar_literal ('r'); goto so; }
000AA4 0EE8       03967 	MOVLW 232
000AA6 5C7F       03968 	SUBWF dato_3,W,0
000AA8 0E03       03969 	MOVLW 3
000AAA 587F       03970 	SUBWFB dato_3+1,W,0
000AAC A0D8       03971 	BTFSS 0xFD8,Carry,0
000AAE D036       03972 	BRA   m124
000AB0 0E3E       03973 	MOVLW 62
000AB2 DEB2       03974 	RCALL enviar_literal
000AB4 0E45       03975 	MOVLW 69
000AB6 DEB0       03976 	RCALL enviar_literal
000AB8 0E72       03977 	MOVLW 114
000ABA DEAE       03978 	RCALL enviar_literal
000ABC D0F9       03979 	BRA   m144
                  03980 			;		    else goto sa;
                  03981 			;		}
                  03982 			;		else
                  03983 			;		{
                  03984 			;			xy = 1;
000ABE 0E01       03985 m122	MOVLW 1
000AC0 6E7F       03986 	MOVWF xy,0
                  03987 			;			if (dato > 9999) { enviar_literal ('>');enviar_literal ('E');enviar_literal ('r'); goto so; }
000AC2 0E10       03988 	MOVLW 16
000AC4 5C7F       03989 	SUBWF dato_3,W,0
000AC6 0E27       03990 	MOVLW 39
000AC8 587F       03991 	SUBWFB dato_3+1,W,0
000ACA A0D8       03992 	BTFSS 0xFD8,Carry,0
000ACC D007       03993 	BRA   m123
000ACE 0E3E       03994 	MOVLW 62
000AD0 DEA3       03995 	RCALL enviar_literal
000AD2 0E45       03996 	MOVLW 69
000AD4 DEA1       03997 	RCALL enviar_literal
000AD6 0E72       03998 	MOVLW 114
000AD8 DE9F       03999 	RCALL enviar_literal
000ADA D0EA       04000 	BRA   m144
                  04001 			;		}
                  04002 			;			// Separo per 4 xifres
                  04003 			;			num = dato; // per 4 xifres
000ADC CF7F FF7F  04004 m123	MOVFF dato_3,num
000AE0 CF7F FF7F  04005 	MOVFF dato_3+1,num+1
                  04006 			;			u_milers = num / 1000;
000AE4 CF7F F0C4  04007 	MOVFF num,arg1_2
000AE8 CF7F F0C5  04008 	MOVFF num+1,arg1_2+1
000AEC 0EE8       04009 	MOVLW 232
000AEE 0100       04010 	MOVLB 0
000AF0 6FC6       04011 	MOVWF arg2_2,1
000AF2 0E03       04012 	MOVLW 3
000AF4 6FC7       04013 	MOVWF arg2_2+1,1
000AF6 DCEE       04014 	RCALL _divU16_16
000AF8 C0C4 FF7F  04015 	MOVFF arg1_2,u_milers
000AFC C0C5 FF7F  04016 	MOVFF arg1_2+1,u_milers+1
                  04017 			;			dato = num % 1000;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 68

ADDR   CODE       LINE  SOURCE

000B00 CF7F F0C4  04018 	MOVFF num,arg1_6
000B04 CF7F F0C5  04019 	MOVFF num+1,arg1_6+1
000B08 0EE8       04020 	MOVLW 232
000B0A 0100       04021 	MOVLB 0
000B0C 6FC6       04022 	MOVWF arg2_6,1
000B0E 0E03       04023 	MOVLW 3
000B10 6FC7       04024 	MOVWF arg2_6+1,1
000B12 DD12       04025 	RCALL _remU16_16
000B14 C0C8 FF7F  04026 	MOVFF rm_6,dato_3
000B18 C0C9 FF7F  04027 	MOVFF rm_6+1,dato_3+1
                  04028 			;			// Separo per 3 xifres
                  04029 			;sa:			cent   = dato   / 100;   	
000B1C CF7F F0C4  04030 m124	MOVFF dato_3,arg1
000B20 CF7F F0C5  04031 	MOVFF dato_3+1,arg1+1
000B24 0E64       04032 	MOVLW 100
000B26 DCBE       04033 	RCALL _divU16_8
000B28 C0C4 FF7F  04034 	MOVFF arg1,cent
000B2C C0C5 FF7F  04035 	MOVFF arg1+1,cent+1
                  04036 			;			resto1 = dato   % 100;
000B30 CF7F F0C4  04037 	MOVFF dato_3,arg1_5
000B34 CF7F F0C5  04038 	MOVFF dato_3+1,arg1_5+1
000B38 0E64       04039 	MOVLW 100
000B3A DCE7       04040 	RCALL _remU16_8
000B3C 6E7F       04041 	MOVWF resto1,0
                  04042 			;			dec    = resto1 /  10;  
000B3E CF7F F0C4  04043 	MOVFF resto1,arg1
000B42 0100       04044 	MOVLB 0
000B44 6BC5       04045 	CLRF  arg1+1,1
000B46 0E0A       04046 	MOVLW 10
000B48 DCAD       04047 	RCALL _divU16_8
000B4A C0C4 FF7F  04048 	MOVFF arg1,dec
                  04049 			;			unid   = resto1 %  10; 		
000B4E CF7F F0C4  04050 	MOVFF resto1,arg1_5
000B52 0100       04051 	MOVLB 0
000B54 6BC5       04052 	CLRF  arg1_5+1,1
000B56 0E0A       04053 	MOVLW 10
000B58 DCD8       04054 	RCALL _remU16_8
000B5A 6E7F       04055 	MOVWF unid,0
                  04056 			;		// Envio
                  04057 			;		for (xx = xy; xx < 7; xx++)
000B5C CF7F FF7F  04058 	MOVFF xy,xx
000B60 0E07       04059 m125	MOVLW 7
000B62 607F       04060 	CPFSLT xx,0
000B64 D0A5       04061 	BRA   m144
                  04062 			;		{
                  04063 			;			clrwdt () ;
000B66 0004       04064 	CLRWDT
                  04065 			;			if (xx == 1) 
000B68 2C7F       04066 	DECFSZ xx,W,0
000B6A D00B       04067 	BRA   m127
                  04068 			;			{
                  04069 			;				if ((u_milers==0)&&(!bd)) dat = ' '; // bd =0 --> espai
000B6C 507F       04070 	MOVF  u_milers,W,0
000B6E 107F       04071 	IORWF u_milers+1,W,0
000B70 A4D8       04072 	BTFSS 0xFD8,Zero_,0
000B72 D005       04073 	BRA   m126
000B74 B07F       04074 	BTFSC 0xF7F,bd,0
000B76 D003       04075 	BRA   m126
000B78 0E20       04076 	MOVLW 32
000B7A 6E7F       04077 	MOVWF dat,0
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 69

ADDR   CODE       LINE  SOURCE

                  04078 			;				else dat = u_milers;
000B7C D002       04079 	BRA   m127
000B7E CF7F FF7F  04080 m126	MOVFF u_milers,dat
                  04081 			;			}
                  04082 			;			if (xx == 2) 
000B82 0E02       04083 m127	MOVLW 2
000B84 627F       04084 	CPFSEQ xx,0
000B86 D00F       04085 	BRA   m129
                  04086 			;			{
                  04087 			;				if ((u_milers==0)&&(cent==0)&&(!bd)) dat = ' '; // bd =0 --> espai
000B88 507F       04088 	MOVF  u_milers,W,0
000B8A 107F       04089 	IORWF u_milers+1,W,0
000B8C A4D8       04090 	BTFSS 0xFD8,Zero_,0
000B8E D009       04091 	BRA   m128
000B90 507F       04092 	MOVF  cent,W,0
000B92 107F       04093 	IORWF cent+1,W,0
000B94 A4D8       04094 	BTFSS 0xFD8,Zero_,0
000B96 D005       04095 	BRA   m128
000B98 B07F       04096 	BTFSC 0xF7F,bd,0
000B9A D003       04097 	BRA   m128
000B9C 0E20       04098 	MOVLW 32
000B9E 6E7F       04099 	MOVWF dat,0
                  04100 			;				else dat = cent;
000BA0 D002       04101 	BRA   m129
000BA2 CF7F FF7F  04102 m128	MOVFF cent,dat
                  04103 			;			}
                  04104 			;			if (xx == 3) 
000BA6 0E03       04105 m129	MOVLW 3
000BA8 627F       04106 	CPFSEQ xx,0
000BAA D00A       04107 	BRA   m132
                  04108 			;			{
                  04109 			;				if(ndp) { if (dp==0) dat = '.';
000BAC A07F       04110 	BTFSS 0xF7F,ndp,0
000BAE D007       04111 	BRA   m131
000BB0 B07F       04112 	BTFSC 0xF7F,dp,0
000BB2 D003       04113 	BRA   m130
000BB4 0E2E       04114 	MOVLW 46
000BB6 6E7F       04115 	MOVWF dat,0
                  04116 			;				          else xx++;  
000BB8 D003       04117 	BRA   m132
000BBA 2A7F       04118 m130	INCF  xx,1,0
                  04119 			;				        }
                  04120 			;				else xx++;		
000BBC D001       04121 	BRA   m132
000BBE 2A7F       04122 m131	INCF  xx,1,0
                  04123 			;			}
                  04124 			;			if (xx == 4)
000BC0 0E04       04125 m132	MOVLW 4
000BC2 627F       04126 	CPFSEQ xx,0
000BC4 D012       04127 	BRA   m134
                  04128 			;			{
                  04129 			;				if ((u_milers==0)&&(cent==0)&&(dec==0)&&(!bd)) dat = ' ';
000BC6 507F       04130 	MOVF  u_milers,W,0
000BC8 107F       04131 	IORWF u_milers+1,W,0
000BCA A4D8       04132 	BTFSS 0xFD8,Zero_,0
000BCC D00C       04133 	BRA   m133
000BCE 507F       04134 	MOVF  cent,W,0
000BD0 107F       04135 	IORWF cent+1,W,0
000BD2 A4D8       04136 	BTFSS 0xFD8,Zero_,0
000BD4 D008       04137 	BRA   m133
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 70

ADDR   CODE       LINE  SOURCE

000BD6 507F       04138 	MOVF  dec,W,0
000BD8 A4D8       04139 	BTFSS 0xFD8,Zero_,0
000BDA D005       04140 	BRA   m133
000BDC B07F       04141 	BTFSC 0xF7F,bd,0
000BDE D003       04142 	BRA   m133
000BE0 0E20       04143 	MOVLW 32
000BE2 6E7F       04144 	MOVWF dat,0
                  04145 			;				else dat = dec ;
000BE4 D002       04146 	BRA   m134
000BE6 CF7F FF7F  04147 m133	MOVFF dec,dat
                  04148 			;			}
                  04149 			;			if (xx == 5)
000BEA 0E05       04150 m134	MOVLW 5
000BEC 627F       04151 	CPFSEQ xx,0
000BEE D00A       04152 	BRA   m137
                  04153 			;			{
                  04154 			;				if(!ndp) { if (dp==0) dat = '.';	
000BF0 B07F       04155 	BTFSC 0xF7F,ndp,0
000BF2 D007       04156 	BRA   m136
000BF4 B07F       04157 	BTFSC 0xF7F,dp,0
000BF6 D003       04158 	BRA   m135
000BF8 0E2E       04159 	MOVLW 46
000BFA 6E7F       04160 	MOVWF dat,0
                  04161 			;				           else xx++;
000BFC D003       04162 	BRA   m137
000BFE 2A7F       04163 m135	INCF  xx,1,0
                  04164 			;						 }
                  04165 			;				else xx++;		 
000C00 D001       04166 	BRA   m137
000C02 2A7F       04167 m136	INCF  xx,1,0
                  04168 			;			}
                  04169 			;			if (xx == 6) dat = unid;
000C04 0E06       04170 m137	MOVLW 6
000C06 627F       04171 	CPFSEQ xx,0
000C08 D002       04172 	BRA   m138
000C0A CF7F FF7F  04173 	MOVFF unid,dat
                  04174 			;						
                  04175 			;			if ((dat!='.')&&(dat!=' ')) dat = dat + 0x30;
000C0E 507F       04176 m138	MOVF  dat,W,0
000C10 0A2E       04177 	XORLW 46
000C12 B4D8       04178 	BTFSC 0xFD8,Zero_,0
000C14 D006       04179 	BRA   m139
000C16 507F       04180 	MOVF  dat,W,0
000C18 0A20       04181 	XORLW 32
000C1A B4D8       04182 	BTFSC 0xFD8,Zero_,0
000C1C D002       04183 	BRA   m139
000C1E 0E30       04184 	MOVLW 48
000C20 267F       04185 	ADDWF dat,1,0
                  04186 			;
                  04187 			;			PORTB.3 = dat.4;nop();
000C22 A87F       04188 m139	BTFSS dat,4,0
000C24 9681       04189 	BCF   PORTB,3,0
000C26 B87F       04190 	BTFSC dat,4,0
000C28 8681       04191 	BSF   PORTB,3,0
000C2A 0000       04192 	NOP  
                  04193 			;			PORTB.2 = dat.5;nop();
000C2C AA7F       04194 	BTFSS dat,5,0
000C2E 9481       04195 	BCF   PORTB,2,0
000C30 BA7F       04196 	BTFSC dat,5,0
000C32 8481       04197 	BSF   PORTB,2,0
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 71

ADDR   CODE       LINE  SOURCE

000C34 0000       04198 	NOP  
                  04199 			;			PORTB.1 = dat.6;nop();
000C36 AC7F       04200 	BTFSS dat,6,0
000C38 9281       04201 	BCF   PORTB,1,0
000C3A BC7F       04202 	BTFSC dat,6,0
000C3C 8281       04203 	BSF   PORTB,1,0
000C3E 0000       04204 	NOP  
                  04205 			;			PORTB.0 = dat.7;nop();
000C40 AE7F       04206 	BTFSS dat,7,0
000C42 9081       04207 	BCF   PORTB,0,0
000C44 BE7F       04208 	BTFSC dat,7,0
000C46 8081       04209 	BSF   PORTB,0,0
000C48 0000       04210 	NOP  
                  04211 			;			PORTB.5 = 1;  									// Modo dato.
000C4A 8A81       04212 	BSF   PORTB,5,0
                  04213 			;			retardo_20u ();
000C4C DD37       04214 	RCALL retardo_20u
                  04215 			;			PORTB.4 = 1;  									// Breve pulso.
000C4E 8881       04216 	BSF   PORTB,4,0
                  04217 			;			retardo_20u ();
000C50 DD35       04218 	RCALL retardo_20u
                  04219 			;			PORTB.4 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
000C52 9881       04220 	BCF   PORTB,4,0
                  04221 			;			for (i = 1; i <= 6; i++) retardo_20u ();
000C54 0E01       04222 	MOVLW 1
000C56 6E7F       04223 	MOVWF i_7,0
000C58 0E07       04224 m140	MOVLW 7
000C5A 607F       04225 	CPFSLT i_7,0
000C5C D003       04226 	BRA   m141
000C5E DD2E       04227 	RCALL retardo_20u
000C60 2A7F       04228 	INCF  i_7,1,0
000C62 D7FA       04229 	BRA   m140
                  04230 			;			dat = swap (dat);
000C64 3A7F       04231 m141	SWAPF dat,1,0
                  04232 			;			PORTB.3 = dat.4;nop();
000C66 A87F       04233 	BTFSS dat,4,0
000C68 9681       04234 	BCF   PORTB,3,0
000C6A B87F       04235 	BTFSC dat,4,0
000C6C 8681       04236 	BSF   PORTB,3,0
000C6E 0000       04237 	NOP  
                  04238 			;			PORTB.2 = dat.5;nop();
000C70 AA7F       04239 	BTFSS dat,5,0
000C72 9481       04240 	BCF   PORTB,2,0
000C74 BA7F       04241 	BTFSC dat,5,0
000C76 8481       04242 	BSF   PORTB,2,0
000C78 0000       04243 	NOP  
                  04244 			;			PORTB.1 = dat.6;nop();
000C7A AC7F       04245 	BTFSS dat,6,0
000C7C 9281       04246 	BCF   PORTB,1,0
000C7E BC7F       04247 	BTFSC dat,6,0
000C80 8281       04248 	BSF   PORTB,1,0
000C82 0000       04249 	NOP  
                  04250 			;			PORTB.0 = dat.7;
000C84 AE7F       04251 	BTFSS dat,7,0
000C86 9081       04252 	BCF   PORTB,0,0
000C88 BE7F       04253 	BTFSC dat,7,0
000C8A 8081       04254 	BSF   PORTB,0,0
                  04255 			;			retardo_1m ();
000C8C DD21       04256 	RCALL retardo_1m
                  04257 			;			PORTB.5 = 1;  									// Modo dato.
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 72

ADDR   CODE       LINE  SOURCE

000C8E 8A81       04258 	BSF   PORTB,5,0
                  04259 			;			retardo_1m ();
000C90 DD1F       04260 	RCALL retardo_1m
                  04261 			;			PORTB.4 = 1;  									// Breve pulso.
000C92 8881       04262 	BSF   PORTB,4,0
                  04263 			;			retardo_20u ();
000C94 DD13       04264 	RCALL retardo_20u
                  04265 			;			PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
000C96 9881       04266 	BCF   PORTB,4,0
                  04267 			;			for (i = 1; i<= 6; i++) retardo_20u ();
000C98 0E01       04268 	MOVLW 1
000C9A 6E7F       04269 	MOVWF i_7,0
000C9C 0E07       04270 m142	MOVLW 7
000C9E 607F       04271 	CPFSLT i_7,0
000CA0 D003       04272 	BRA   m143
000CA2 DD0C       04273 	RCALL retardo_20u
000CA4 2A7F       04274 	INCF  i_7,1,0
000CA6 D7FA       04275 	BRA   m142
                  04276 			;			enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.			
000CA8 0E0C       04277 m143	MOVLW 12
000CAA DD7B       04278 	RCALL enviar_comando
                  04279 			;		}
000CAC 2A7F       04280 	INCF  xx,1,0
000CAE D758       04281 	BRA   m125
                  04282 			;so:	//DESCON_LCD ();
                  04283 			;	return;
000CB0 0012       04284 m144	RETURN
                  04285 			;}
                  04286 			;
                  04287 			;void Enviar_uns16(char linea,char columna,uns16 dato){
                  04288 Enviar_uns16
                  04289 			;	//utilizaremos esta funcion en caso de necesitar un numero entero hasta 65536(16bits)
                  04290 			;	uns16 num, u_milers, cent, d_milers;
                  04291 			;	char dec, unid, resto1;
                  04292 			;	char i, xx, yy, dat,xy;
                  04293 			;
                  04294 			;	switch (linea) 									// (se resta una unidad a la coordenada lnea para que la posicin colum
                           na inicial sea 1 y no 0).
000CB2 0100       04295 	MOVLB 0
000CB4 51B0       04296 	MOVF  linea_4,W,1
000CB6 0A01       04297 	XORLW 1
000CB8 B4D8       04298 	BTFSC 0xFD8,Zero_,0
000CBA D00A       04299 	BRA   m145
000CBC 0A03       04300 	XORLW 3
000CBE B4D8       04301 	BTFSC 0xFD8,Zero_,0
000CC0 D00C       04302 	BRA   m146
000CC2 0A01       04303 	XORLW 1
000CC4 B4D8       04304 	BTFSC 0xFD8,Zero_,0
000CC6 D00E       04305 	BRA   m147
000CC8 0A07       04306 	XORLW 7
000CCA B4D8       04307 	BTFSC 0xFD8,Zero_,0
000CCC D010       04308 	BRA   m148
000CCE D016       04309 	BRA   m149
                  04310 			;		{
                  04311 			;			case 1:	enviar_comando (127 + columna); 	// inicio primera linea.
000CD0 0E7F       04312 m145	MOVLW 127
000CD2 0100       04313 	MOVLB 0
000CD4 25B1       04314 	ADDWF columna_3,W,1
000CD6 DD65       04315 	RCALL enviar_comando
                  04316 			;			break;	
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 73

ADDR   CODE       LINE  SOURCE

000CD8 D011       04317 	BRA   m149
                  04318 			;			case 2:	enviar_comando (191 + columna); 	// inicio segunda lnea.
000CDA 0EBF       04319 m146	MOVLW 191
000CDC 0100       04320 	MOVLB 0
000CDE 25B1       04321 	ADDWF columna_3,W,1
000CE0 DD60       04322 	RCALL enviar_comando
                  04323 			;			break;			
000CE2 D00C       04324 	BRA   m149
                  04325 			;			case 3:	enviar_comando (147 + columna); 	// inicio tercera lnea (cursor en posicin 20 de la primera lnea).
000CE4 0E93       04326 m147	MOVLW 147
000CE6 0100       04327 	MOVLB 0
000CE8 25B1       04328 	ADDWF columna_3,W,1
000CEA DD5B       04329 	RCALL enviar_comando
                  04330 			;			break;				
000CEC D007       04331 	BRA   m149
                  04332 			;			case 4:	enviar_comando (211 + columna); 	// inicio cuarta lnea (cursor en posicin 20 de la segunda lnea).
000CEE 0ED3       04333 m148	MOVLW 211
000CF0 0100       04334 	MOVLB 0
000CF2 25B1       04335 	ADDWF columna_3,W,1
000CF4 DD56       04336 	RCALL enviar_comando
                  04337 			;			break;	
000CF6 D002       04338 	BRA   m149
                  04339 			;			enviar_comando (0b.0000.1100);			// pantalla encendida, sin cursor
000CF8 0E0C       04340 	MOVLW 12
000CFA DD53       04341 	RCALL enviar_comando
                  04342 			;		}				
                  04343 			;	
                  04344 			;			
                  04345 			;			num = dato; 
000CFC C0B2 F0B4  04346 m149	MOVFF dato_4,num_2
000D00 C0B3 F0B5  04347 	MOVFF dato_4+1,num_2+1
                  04348 			;			d_milers =num/10000;
000D04 C0B4 F0C4  04349 	MOVFF num_2,arg1_2
000D08 C0B5 F0C5  04350 	MOVFF num_2+1,arg1_2+1
000D0C 0E10       04351 	MOVLW 16
000D0E 0100       04352 	MOVLB 0
000D10 6FC6       04353 	MOVWF arg2_2,1
000D12 0E27       04354 	MOVLW 39
000D14 6FC7       04355 	MOVWF arg2_2+1,1
000D16 EC6A F002  04356 	CALL  _divU16_16
000D1A C0C4 F0BA  04357 	MOVFF arg1_2,d_milers
000D1E C0C5 F0BB  04358 	MOVFF arg1_2+1,d_milers+1
                  04359 			;			num= num%10000;
000D22 C0B4 F0C4  04360 	MOVFF num_2,arg1_6
000D26 C0B5 F0C5  04361 	MOVFF num_2+1,arg1_6+1
000D2A 0E10       04362 	MOVLW 16
000D2C 0100       04363 	MOVLB 0
000D2E 6FC6       04364 	MOVWF arg2_6,1
000D30 0E27       04365 	MOVLW 39
000D32 6FC7       04366 	MOVWF arg2_6+1,1
000D34 DC01       04367 	RCALL _remU16_16
000D36 C0C8 F0B4  04368 	MOVFF rm_6,num_2
000D3A C0C9 F0B5  04369 	MOVFF rm_6+1,num_2+1
                  04370 			;			u_milers = num / 1000;
000D3E C0B4 F0C4  04371 	MOVFF num_2,arg1_2
000D42 C0B5 F0C5  04372 	MOVFF num_2+1,arg1_2+1
000D46 0EE8       04373 	MOVLW 232
000D48 0100       04374 	MOVLB 0
000D4A 6FC6       04375 	MOVWF arg2_2,1
000D4C 0E03       04376 	MOVLW 3
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 74

ADDR   CODE       LINE  SOURCE

000D4E 6FC7       04377 	MOVWF arg2_2+1,1
000D50 EC6A F002  04378 	CALL  _divU16_16
000D54 C0C4 F0B6  04379 	MOVFF arg1_2,u_milers_2
000D58 C0C5 F0B7  04380 	MOVFF arg1_2+1,u_milers_2+1
                  04381 			;			dato = num % 1000;
000D5C C0B4 F0C4  04382 	MOVFF num_2,arg1_6
000D60 C0B5 F0C5  04383 	MOVFF num_2+1,arg1_6+1
000D64 0EE8       04384 	MOVLW 232
000D66 0100       04385 	MOVLB 0
000D68 6FC6       04386 	MOVWF arg2_6,1
000D6A 0E03       04387 	MOVLW 3
000D6C 6FC7       04388 	MOVWF arg2_6+1,1
000D6E EC9C F002  04389 	CALL  _remU16_16
000D72 C0C8 F0B2  04390 	MOVFF rm_6,dato_4
000D76 C0C9 F0B3  04391 	MOVFF rm_6+1,dato_4+1
                  04392 			;
                  04393 			;			cent   = dato   / 100;   	
000D7A C0B2 F0C4  04394 	MOVFF dato_4,arg1
000D7E C0B3 F0C5  04395 	MOVFF dato_4+1,arg1+1
000D82 0E64       04396 	MOVLW 100
000D84 EC52 F002  04397 	CALL  _divU16_8
000D88 C0C4 F0B8  04398 	MOVFF arg1,cent_2
000D8C C0C5 F0B9  04399 	MOVFF arg1+1,cent_2+1
                  04400 			;			resto1 = dato   % 100;
000D90 C0B2 F0C4  04401 	MOVFF dato_4,arg1_5
000D94 C0B3 F0C5  04402 	MOVFF dato_4+1,arg1_5+1
000D98 0E64       04403 	MOVLW 100
000D9A EC85 F002  04404 	CALL  _remU16_8
000D9E 0100       04405 	MOVLB 0
000DA0 6FBE       04406 	MOVWF resto1_2,1
                  04407 			;			dec    = resto1 /  10;  
000DA2 C0BE F0C4  04408 	MOVFF resto1_2,arg1
000DA6 6BC5       04409 	CLRF  arg1+1,1
000DA8 0E0A       04410 	MOVLW 10
000DAA EC52 F002  04411 	CALL  _divU16_8
000DAE C0C4 F0BC  04412 	MOVFF arg1,dec_2
                  04413 			;			unid   = resto1 %  10; 		
000DB2 C0BE F0C4  04414 	MOVFF resto1_2,arg1_5
000DB6 0100       04415 	MOVLB 0
000DB8 6BC5       04416 	CLRF  arg1_5+1,1
000DBA 0E0A       04417 	MOVLW 10
000DBC EC85 F002  04418 	CALL  _remU16_8
000DC0 0100       04419 	MOVLB 0
000DC2 6FBD       04420 	MOVWF unid_2,1
                  04421 			;		// Envio
                  04422 			;		for (xx=0 ; xx < 5; xx++)
000DC4 6BC0       04423 	CLRF  xx_2,1
000DC6 0E05       04424 m150	MOVLW 5
000DC8 0100       04425 	MOVLB 0
000DCA 61C0       04426 	CPFSLT xx_2,1
000DCC D0B1       04427 	BRA   m166
                  04428 			;		{
                  04429 			;			switch(xx){
000DCE 51C0       04430 	MOVF  xx_2,W,1
000DD0 B4D8       04431 	BTFSC 0xFD8,Zero_,0
000DD2 D00D       04432 	BRA   m151
000DD4 0A01       04433 	XORLW 1
000DD6 B4D8       04434 	BTFSC 0xFD8,Zero_,0
000DD8 D015       04435 	BRA   m153
000DDA 0A03       04436 	XORLW 3
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 75

ADDR   CODE       LINE  SOURCE

000DDC B4D8       04437 	BTFSC 0xFD8,Zero_,0
000DDE D021       04438 	BRA   m155
000DE0 0A01       04439 	XORLW 1
000DE2 B4D8       04440 	BTFSC 0xFD8,Zero_,0
000DE4 D031       04441 	BRA   m157
000DE6 0A07       04442 	XORLW 7
000DE8 B4D8       04443 	BTFSC 0xFD8,Zero_,0
000DEA D044       04444 	BRA   m159
000DEC D045       04445 	BRA   m160
                  04446 			;				case 0:
                  04447 			;					if (d_milers==0) dat = ' '; 
000DEE 0100       04448 m151	MOVLB 0
000DF0 51BA       04449 	MOVF  d_milers,W,1
000DF2 11BB       04450 	IORWF d_milers+1,W,1
000DF4 A4D8       04451 	BTFSS 0xFD8,Zero_,0
000DF6 D003       04452 	BRA   m152
000DF8 0E20       04453 	MOVLW 32
000DFA 6FC2       04454 	MOVWF dat_2,1
                  04455 			;					else dat = d_milers;
000DFC D03D       04456 	BRA   m160
000DFE C0BA F0C2  04457 m152	MOVFF d_milers,dat_2
                  04458 			;					break;
000E02 D03A       04459 	BRA   m160
                  04460 			;				case 1:
                  04461 			;					if ((u_milers==0)&&(d_milers==0)) dat = ' ';
000E04 0100       04462 m153	MOVLB 0
000E06 51B6       04463 	MOVF  u_milers_2,W,1
000E08 11B7       04464 	IORWF u_milers_2+1,W,1
000E0A A4D8       04465 	BTFSS 0xFD8,Zero_,0
000E0C D007       04466 	BRA   m154
000E0E 51BA       04467 	MOVF  d_milers,W,1
000E10 11BB       04468 	IORWF d_milers+1,W,1
000E12 A4D8       04469 	BTFSS 0xFD8,Zero_,0
000E14 D003       04470 	BRA   m154
000E16 0E20       04471 	MOVLW 32
000E18 6FC2       04472 	MOVWF dat_2,1
                  04473 			;					else dat = u_milers;
000E1A D02E       04474 	BRA   m160
000E1C C0B6 F0C2  04475 m154	MOVFF u_milers_2,dat_2
                  04476 			;					break;
000E20 D02B       04477 	BRA   m160
                  04478 			;				case 2:
                  04479 			;					if ((d_milers==0)&&(u_milers==0)&&(cent==0)) dat = ' '; 
000E22 0100       04480 m155	MOVLB 0
000E24 51BA       04481 	MOVF  d_milers,W,1
000E26 11BB       04482 	IORWF d_milers+1,W,1
000E28 A4D8       04483 	BTFSS 0xFD8,Zero_,0
000E2A D00B       04484 	BRA   m156
000E2C 51B6       04485 	MOVF  u_milers_2,W,1
000E2E 11B7       04486 	IORWF u_milers_2+1,W,1
000E30 A4D8       04487 	BTFSS 0xFD8,Zero_,0
000E32 D007       04488 	BRA   m156
000E34 51B8       04489 	MOVF  cent_2,W,1
000E36 11B9       04490 	IORWF cent_2+1,W,1
000E38 A4D8       04491 	BTFSS 0xFD8,Zero_,0
000E3A D003       04492 	BRA   m156
000E3C 0E20       04493 	MOVLW 32
000E3E 6FC2       04494 	MOVWF dat_2,1
                  04495 			;					else dat = cent;
000E40 D01B       04496 	BRA   m160
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 76

ADDR   CODE       LINE  SOURCE

000E42 C0B8 F0C2  04497 m156	MOVFF cent_2,dat_2
                  04498 			;					break;
000E46 D018       04499 	BRA   m160
                  04500 			;				case 3:
                  04501 			;					if ((u_milers==0)&&(cent==0)&&(dec==0)&&(d_milers==0)) dat = ' ';
000E48 0100       04502 m157	MOVLB 0
000E4A 51B6       04503 	MOVF  u_milers_2,W,1
000E4C 11B7       04504 	IORWF u_milers_2+1,W,1
000E4E A4D8       04505 	BTFSS 0xFD8,Zero_,0
000E50 D00E       04506 	BRA   m158
000E52 51B8       04507 	MOVF  cent_2,W,1
000E54 11B9       04508 	IORWF cent_2+1,W,1
000E56 A4D8       04509 	BTFSS 0xFD8,Zero_,0
000E58 D00A       04510 	BRA   m158
000E5A 53BC       04511 	MOVF  dec_2,1,1
000E5C A4D8       04512 	BTFSS 0xFD8,Zero_,0
000E5E D007       04513 	BRA   m158
000E60 51BA       04514 	MOVF  d_milers,W,1
000E62 11BB       04515 	IORWF d_milers+1,W,1
000E64 A4D8       04516 	BTFSS 0xFD8,Zero_,0
000E66 D003       04517 	BRA   m158
000E68 0E20       04518 	MOVLW 32
000E6A 6FC2       04519 	MOVWF dat_2,1
                  04520 			;					else dat = dec ;
000E6C D005       04521 	BRA   m160
000E6E C0BC F0C2  04522 m158	MOVFF dec_2,dat_2
                  04523 			;					break;
000E72 D002       04524 	BRA   m160
                  04525 			;				case 4:
                  04526 			;					dat = unid;
000E74 C0BD F0C2  04527 m159	MOVFF unid_2,dat_2
                  04528 			;					break;
                  04529 			;			}		
                  04530 			;			if (dat!=' ') dat = dat + 0x30;
000E78 0100       04531 m160	MOVLB 0
000E7A 51C2       04532 	MOVF  dat_2,W,1
000E7C 0A20       04533 	XORLW 32
000E7E B4D8       04534 	BTFSC 0xFD8,Zero_,0
000E80 D002       04535 	BRA   m161
000E82 0E30       04536 	MOVLW 48
000E84 27C2       04537 	ADDWF dat_2,1,1
                  04538 			;			PORTB.3 = dat.4;nop();
000E86 0100       04539 m161	MOVLB 0
000E88 A9C2       04540 	BTFSS dat_2,4,1
000E8A 9681       04541 	BCF   PORTB,3,0
000E8C B9C2       04542 	BTFSC dat_2,4,1
000E8E 8681       04543 	BSF   PORTB,3,0
000E90 0000       04544 	NOP  
                  04545 			;			PORTB.2 = dat.5;nop();
000E92 ABC2       04546 	BTFSS dat_2,5,1
000E94 9481       04547 	BCF   PORTB,2,0
000E96 BBC2       04548 	BTFSC dat_2,5,1
000E98 8481       04549 	BSF   PORTB,2,0
000E9A 0000       04550 	NOP  
                  04551 			;			PORTB.1 = dat.6;nop();
000E9C ADC2       04552 	BTFSS dat_2,6,1
000E9E 9281       04553 	BCF   PORTB,1,0
000EA0 BDC2       04554 	BTFSC dat_2,6,1
000EA2 8281       04555 	BSF   PORTB,1,0
000EA4 0000       04556 	NOP  
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 77

ADDR   CODE       LINE  SOURCE

                  04557 			;			PORTB.0 = dat.7;nop();
000EA6 AFC2       04558 	BTFSS dat_2,7,1
000EA8 9081       04559 	BCF   PORTB,0,0
000EAA BFC2       04560 	BTFSC dat_2,7,1
000EAC 8081       04561 	BSF   PORTB,0,0
000EAE 0000       04562 	NOP  
                  04563 			;			PORTB.5 = 1;  									// Modo dato.
000EB0 8A81       04564 	BSF   PORTB,5,0
                  04565 			;			retardo_20u ();
000EB2 DC04       04566 	RCALL retardo_20u
                  04567 			;			PORTB.4 = 1;  									// Breve pulso.
000EB4 8881       04568 	BSF   PORTB,4,0
                  04569 			;			retardo_20u ();
000EB6 DC02       04570 	RCALL retardo_20u
                  04571 			;			PORTB.4 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
000EB8 9881       04572 	BCF   PORTB,4,0
                  04573 			;			for (i = 1; i <= 6; i++) retardo_20u ();
000EBA 0E01       04574 	MOVLW 1
000EBC 0100       04575 	MOVLB 0
000EBE 6FBF       04576 	MOVWF i_8,1
000EC0 0E07       04577 m162	MOVLW 7
000EC2 0100       04578 	MOVLB 0
000EC4 61BF       04579 	CPFSLT i_8,1
000EC6 D005       04580 	BRA   m163
000EC8 EC5E F003  04581 	CALL  retardo_20u
000ECC 0100       04582 	MOVLB 0
000ECE 2BBF       04583 	INCF  i_8,1,1
000ED0 D7F7       04584 	BRA   m162
                  04585 			;			dat = swap (dat);
000ED2 0100       04586 m163	MOVLB 0
000ED4 3BC2       04587 	SWAPF dat_2,1,1
                  04588 			;			PORTB.3 = dat.4;nop();
000ED6 A9C2       04589 	BTFSS dat_2,4,1
000ED8 9681       04590 	BCF   PORTB,3,0
000EDA B9C2       04591 	BTFSC dat_2,4,1
000EDC 8681       04592 	BSF   PORTB,3,0
000EDE 0000       04593 	NOP  
                  04594 			;			PORTB.2 = dat.5;nop();
000EE0 ABC2       04595 	BTFSS dat_2,5,1
000EE2 9481       04596 	BCF   PORTB,2,0
000EE4 BBC2       04597 	BTFSC dat_2,5,1
000EE6 8481       04598 	BSF   PORTB,2,0
000EE8 0000       04599 	NOP  
                  04600 			;			PORTB.1 = dat.6;nop();
000EEA ADC2       04601 	BTFSS dat_2,6,1
000EEC 9281       04602 	BCF   PORTB,1,0
000EEE BDC2       04603 	BTFSC dat_2,6,1
000EF0 8281       04604 	BSF   PORTB,1,0
000EF2 0000       04605 	NOP  
                  04606 			;			PORTB.0 = dat.7;
000EF4 AFC2       04607 	BTFSS dat_2,7,1
000EF6 9081       04608 	BCF   PORTB,0,0
000EF8 BFC2       04609 	BTFSC dat_2,7,1
000EFA 8081       04610 	BSF   PORTB,0,0
                  04611 			;			retardo_1m ();
000EFC EC68 F003  04612 	CALL  retardo_1m
                  04613 			;			PORTB.5 = 1;  									// Modo dato.
000F00 8A81       04614 	BSF   PORTB,5,0
                  04615 			;			retardo_1m ();
000F02 EC68 F003  04616 	CALL  retardo_1m
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 78

ADDR   CODE       LINE  SOURCE

                  04617 			;			PORTB.4 = 1;  									// Breve pulso.
000F06 8881       04618 	BSF   PORTB,4,0
                  04619 			;			retardo_20u ();
000F08 EC5E F003  04620 	CALL  retardo_20u
                  04621 			;			PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
000F0C 9881       04622 	BCF   PORTB,4,0
                  04623 			;			for (i = 1; i<= 6; i++) retardo_20u ();
000F0E 0E01       04624 	MOVLW 1
000F10 0100       04625 	MOVLB 0
000F12 6FBF       04626 	MOVWF i_8,1
000F14 0E07       04627 m164	MOVLW 7
000F16 0100       04628 	MOVLB 0
000F18 61BF       04629 	CPFSLT i_8,1
000F1A D005       04630 	BRA   m165
000F1C EC5E F003  04631 	CALL  retardo_20u
000F20 0100       04632 	MOVLB 0
000F22 2BBF       04633 	INCF  i_8,1,1
000F24 D7F7       04634 	BRA   m164
                  04635 			;			enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.			
000F26 0E0C       04636 m165	MOVLW 12
000F28 DC3C       04637 	RCALL enviar_comando
                  04638 			;		}
000F2A 0100       04639 	MOVLB 0
000F2C 2BC0       04640 	INCF  xx_2,1,1
000F2E D74B       04641 	BRA   m150
                  04642 			;
                  04643 			;	return;
000F30 0012       04644 m166	RETURN
                  04645 			;
                  04646 			;}
                  04647 			;
                  04648 			;
                  04649 			;
                  04650 			;void Enviar_char(char linea,char columna,char dato){
                  04651 Enviar_char
000F32 0100       04652 	MOVLB 0
000F34 6FB2       04653 	MOVWF dato_5,1
                  04654 			;	//utilizaremos esta funcion en caso de necesitar un numero entero hasta 65536(16bits)
                  04655 			;	char num, cent;
                  04656 			;	char dec, unid, resto1;
                  04657 			;	char i, xx, yy, dat,xy;
                  04658 			;
                  04659 			;	switch (linea) 									// (se resta una unidad a la coordenada lnea para que la posicin colum
                           na inicial sea 1 y no 0).
000F36 51B0       04660 	MOVF  linea_5,W,1
000F38 0A01       04661 	XORLW 1
000F3A B4D8       04662 	BTFSC 0xFD8,Zero_,0
000F3C D00A       04663 	BRA   m167
000F3E 0A03       04664 	XORLW 3
000F40 B4D8       04665 	BTFSC 0xFD8,Zero_,0
000F42 D00C       04666 	BRA   m168
000F44 0A01       04667 	XORLW 1
000F46 B4D8       04668 	BTFSC 0xFD8,Zero_,0
000F48 D00E       04669 	BRA   m169
000F4A 0A07       04670 	XORLW 7
000F4C B4D8       04671 	BTFSC 0xFD8,Zero_,0
000F4E D010       04672 	BRA   m170
000F50 D016       04673 	BRA   m171
                  04674 			;		{
                  04675 			;			case 1:	enviar_comando (127 + columna); 	// inicio primera linea.
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 79

ADDR   CODE       LINE  SOURCE

000F52 0E7F       04676 m167	MOVLW 127
000F54 0100       04677 	MOVLB 0
000F56 25B1       04678 	ADDWF columna_4,W,1
000F58 DC24       04679 	RCALL enviar_comando
                  04680 			;			break;	
000F5A D011       04681 	BRA   m171
                  04682 			;			case 2:	enviar_comando (191 + columna); 	// inicio segunda lnea.
000F5C 0EBF       04683 m168	MOVLW 191
000F5E 0100       04684 	MOVLB 0
000F60 25B1       04685 	ADDWF columna_4,W,1
000F62 DC1F       04686 	RCALL enviar_comando
                  04687 			;			break;			
000F64 D00C       04688 	BRA   m171
                  04689 			;			case 3:	enviar_comando (147 + columna); 	// inicio tercera lnea (cursor en posicin 20 de la primera lnea).
000F66 0E93       04690 m169	MOVLW 147
000F68 0100       04691 	MOVLB 0
000F6A 25B1       04692 	ADDWF columna_4,W,1
000F6C DC1A       04693 	RCALL enviar_comando
                  04694 			;			break;				
000F6E D007       04695 	BRA   m171
                  04696 			;			case 4:	enviar_comando (211 + columna); 	// inicio cuarta lnea (cursor en posicin 20 de la segunda lnea).
000F70 0ED3       04697 m170	MOVLW 211
000F72 0100       04698 	MOVLB 0
000F74 25B1       04699 	ADDWF columna_4,W,1
000F76 DC15       04700 	RCALL enviar_comando
                  04701 			;			break;	
000F78 D002       04702 	BRA   m171
                  04703 			;			enviar_comando (0b.0000.1100);			// pantalla encendida, sin cursor
000F7A 0E0C       04704 	MOVLW 12
000F7C DC12       04705 	RCALL enviar_comando
                  04706 			;		}				
                  04707 			;
                  04708 			;			cent   = dato   / 100;   	
000F7E C0B2 F0C4  04709 m171	MOVFF dato_5,arg1
000F82 0100       04710 	MOVLB 0
000F84 6BC5       04711 	CLRF  arg1+1,1
000F86 0E64       04712 	MOVLW 100
000F88 EC52 F002  04713 	CALL  _divU16_8
000F8C C0C4 F0B4  04714 	MOVFF arg1,cent_3
                  04715 			;			resto1 = dato   % 100;
000F90 C0B2 F0C4  04716 	MOVFF dato_5,arg1_5
000F94 0100       04717 	MOVLB 0
000F96 6BC5       04718 	CLRF  arg1_5+1,1
000F98 0E64       04719 	MOVLW 100
000F9A EC85 F002  04720 	CALL  _remU16_8
000F9E 0100       04721 	MOVLB 0
000FA0 6FB7       04722 	MOVWF resto1_3,1
                  04723 			;			dec    = resto1 /  10;  
000FA2 C0B7 F0C4  04724 	MOVFF resto1_3,arg1
000FA6 6BC5       04725 	CLRF  arg1+1,1
000FA8 0E0A       04726 	MOVLW 10
000FAA EC52 F002  04727 	CALL  _divU16_8
000FAE C0C4 F0B5  04728 	MOVFF arg1,dec_3
                  04729 			;			unid   = resto1 %  10; 		
000FB2 C0B7 F0C4  04730 	MOVFF resto1_3,arg1_5
000FB6 0100       04731 	MOVLB 0
000FB8 6BC5       04732 	CLRF  arg1_5+1,1
000FBA 0E0A       04733 	MOVLW 10
000FBC EC85 F002  04734 	CALL  _remU16_8
000FC0 0100       04735 	MOVLB 0
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 80

ADDR   CODE       LINE  SOURCE

000FC2 6FB6       04736 	MOVWF unid_3,1
                  04737 			;		// Envio
                  04738 			;		for (xx=0 ; xx < 3; xx++)
000FC4 6BB9       04739 	CLRF  xx_3,1
000FC6 0E03       04740 m172	MOVLW 3
000FC8 0100       04741 	MOVLB 0
000FCA 61B9       04742 	CPFSLT xx_3,1
000FCC D082       04743 	BRA   m184
                  04744 			;		{
                  04745 			;			switch(xx){
000FCE 51B9       04746 	MOVF  xx_3,W,1
000FD0 B4D8       04747 	BTFSC 0xFD8,Zero_,0
000FD2 D007       04748 	BRA   m173
000FD4 0A01       04749 	XORLW 1
000FD6 B4D8       04750 	BTFSC 0xFD8,Zero_,0
000FD8 D00E       04751 	BRA   m175
000FDA 0A03       04752 	XORLW 3
000FDC B4D8       04753 	BTFSC 0xFD8,Zero_,0
000FDE D018       04754 	BRA   m177
000FE0 D019       04755 	BRA   m178
                  04756 			;				case 0:
                  04757 			;					if (cent==0) dat = ' '; 
000FE2 0100       04758 m173	MOVLB 0
000FE4 53B4       04759 	MOVF  cent_3,1,1
000FE6 A4D8       04760 	BTFSS 0xFD8,Zero_,0
000FE8 D003       04761 	BRA   m174
000FEA 0E20       04762 	MOVLW 32
000FEC 6FBB       04763 	MOVWF dat_3,1
                  04764 			;					else dat = cent;
000FEE D012       04765 	BRA   m178
000FF0 C0B4 F0BB  04766 m174	MOVFF cent_3,dat_3
                  04767 			;					break;
000FF4 D00F       04768 	BRA   m178
                  04769 			;				case 1:
                  04770 			;					if ((cent==0)&&(dec==0)) dat = ' ';
000FF6 0100       04771 m175	MOVLB 0
000FF8 53B4       04772 	MOVF  cent_3,1,1
000FFA A4D8       04773 	BTFSS 0xFD8,Zero_,0
000FFC D006       04774 	BRA   m176
000FFE 53B5       04775 	MOVF  dec_3,1,1
001000 A4D8       04776 	BTFSS 0xFD8,Zero_,0
001002 D003       04777 	BRA   m176
001004 0E20       04778 	MOVLW 32
001006 6FBB       04779 	MOVWF dat_3,1
                  04780 			;					else dat = dec ;
001008 D005       04781 	BRA   m178
00100A C0B5 F0BB  04782 m176	MOVFF dec_3,dat_3
                  04783 			;					break;
00100E D002       04784 	BRA   m178
                  04785 			;				case 2 :
                  04786 			;					dat = unid;
001010 C0B6 F0BB  04787 m177	MOVFF unid_3,dat_3
                  04788 			;					break;
                  04789 			;			}		
                  04790 			;			if (dat!=' ') dat = dat + 0x30;
001014 0100       04791 m178	MOVLB 0
001016 51BB       04792 	MOVF  dat_3,W,1
001018 0A20       04793 	XORLW 32
00101A B4D8       04794 	BTFSC 0xFD8,Zero_,0
00101C D002       04795 	BRA   m179
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 81

ADDR   CODE       LINE  SOURCE

00101E 0E30       04796 	MOVLW 48
001020 27BB       04797 	ADDWF dat_3,1,1
                  04798 			;			PORTB.3 = dat.4;nop();
001022 0100       04799 m179	MOVLB 0
001024 A9BB       04800 	BTFSS dat_3,4,1
001026 9681       04801 	BCF   PORTB,3,0
001028 B9BB       04802 	BTFSC dat_3,4,1
00102A 8681       04803 	BSF   PORTB,3,0
00102C 0000       04804 	NOP  
                  04805 			;			PORTB.2 = dat.5;nop();
00102E ABBB       04806 	BTFSS dat_3,5,1
001030 9481       04807 	BCF   PORTB,2,0
001032 BBBB       04808 	BTFSC dat_3,5,1
001034 8481       04809 	BSF   PORTB,2,0
001036 0000       04810 	NOP  
                  04811 			;			PORTB.1 = dat.6;nop();
001038 ADBB       04812 	BTFSS dat_3,6,1
00103A 9281       04813 	BCF   PORTB,1,0
00103C BDBB       04814 	BTFSC dat_3,6,1
00103E 8281       04815 	BSF   PORTB,1,0
001040 0000       04816 	NOP  
                  04817 			;			PORTB.0 = dat.7;nop();
001042 AFBB       04818 	BTFSS dat_3,7,1
001044 9081       04819 	BCF   PORTB,0,0
001046 BFBB       04820 	BTFSC dat_3,7,1
001048 8081       04821 	BSF   PORTB,0,0
00104A 0000       04822 	NOP  
                  04823 			;			PORTB.5 = 1;  									// Modo dato.
00104C 8A81       04824 	BSF   PORTB,5,0
                  04825 			;			retardo_20u ();
00104E EC5E F003  04826 	CALL  retardo_20u
                  04827 			;			PORTB.4 = 1;  									// Breve pulso.
001052 8881       04828 	BSF   PORTB,4,0
                  04829 			;			retardo_20u ();
001054 EC5E F003  04830 	CALL  retardo_20u
                  04831 			;			PORTB.4 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
001058 9881       04832 	BCF   PORTB,4,0
                  04833 			;			for (i = 1; i <= 6; i++) retardo_20u ();
00105A 0E01       04834 	MOVLW 1
00105C 0100       04835 	MOVLB 0
00105E 6FB8       04836 	MOVWF i_9,1
001060 0E07       04837 m180	MOVLW 7
001062 0100       04838 	MOVLB 0
001064 61B8       04839 	CPFSLT i_9,1
001066 D005       04840 	BRA   m181
001068 EC5E F003  04841 	CALL  retardo_20u
00106C 0100       04842 	MOVLB 0
00106E 2BB8       04843 	INCF  i_9,1,1
001070 D7F7       04844 	BRA   m180
                  04845 			;			dat = swap (dat);
001072 0100       04846 m181	MOVLB 0
001074 3BBB       04847 	SWAPF dat_3,1,1
                  04848 			;			PORTB.3 = dat.4;nop();
001076 A9BB       04849 	BTFSS dat_3,4,1
001078 9681       04850 	BCF   PORTB,3,0
00107A B9BB       04851 	BTFSC dat_3,4,1
00107C 8681       04852 	BSF   PORTB,3,0
00107E 0000       04853 	NOP  
                  04854 			;			PORTB.2 = dat.5;nop();
001080 ABBB       04855 	BTFSS dat_3,5,1
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 82

ADDR   CODE       LINE  SOURCE

001082 9481       04856 	BCF   PORTB,2,0
001084 BBBB       04857 	BTFSC dat_3,5,1
001086 8481       04858 	BSF   PORTB,2,0
001088 0000       04859 	NOP  
                  04860 			;			PORTB.1 = dat.6;nop();
00108A ADBB       04861 	BTFSS dat_3,6,1
00108C 9281       04862 	BCF   PORTB,1,0
00108E BDBB       04863 	BTFSC dat_3,6,1
001090 8281       04864 	BSF   PORTB,1,0
001092 0000       04865 	NOP  
                  04866 			;			PORTB.0 = dat.7;
001094 AFBB       04867 	BTFSS dat_3,7,1
001096 9081       04868 	BCF   PORTB,0,0
001098 BFBB       04869 	BTFSC dat_3,7,1
00109A 8081       04870 	BSF   PORTB,0,0
                  04871 			;			retardo_1m ();
00109C EC68 F003  04872 	CALL  retardo_1m
                  04873 			;			PORTB.5 = 1;  									// Modo dato.
0010A0 8A81       04874 	BSF   PORTB,5,0
                  04875 			;			retardo_1m ();
0010A2 EC68 F003  04876 	CALL  retardo_1m
                  04877 			;			PORTB.4 = 1;  									// Breve pulso.
0010A6 8881       04878 	BSF   PORTB,4,0
                  04879 			;			retardo_20u ();
0010A8 EC5E F003  04880 	CALL  retardo_20u
                  04881 			;			PORTB.4 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
0010AC 9881       04882 	BCF   PORTB,4,0
                  04883 			;			for (i = 1; i<= 6; i++) retardo_20u ();
0010AE 0E01       04884 	MOVLW 1
0010B0 0100       04885 	MOVLB 0
0010B2 6FB8       04886 	MOVWF i_9,1
0010B4 0E07       04887 m182	MOVLW 7
0010B6 0100       04888 	MOVLB 0
0010B8 61B8       04889 	CPFSLT i_9,1
0010BA D005       04890 	BRA   m183
0010BC EC5E F003  04891 	CALL  retardo_20u
0010C0 0100       04892 	MOVLB 0
0010C2 2BB8       04893 	INCF  i_9,1,1
0010C4 D7F7       04894 	BRA   m182
                  04895 			;			enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.			
0010C6 0E0C       04896 m183	MOVLW 12
0010C8 ECD1 F003  04897 	CALL  enviar_comando
                  04898 			;		}
0010CC 0100       04899 	MOVLB 0
0010CE 2BB9       04900 	INCF  xx_3,1,1
0010D0 D77A       04901 	BRA   m172
                  04902 			;
                  04903 			;	return;
0010D2 0012       04904 m184	RETURN
                  04905 			;
                  04906 			;}
                  04907 			;
                  04908 			;//***********************************************************************************************
                  04909 			;//***********************************************************************************************
                  04910 			;// Definicio caracter especial : PROCES  -> posar x, on volguem el pixel ,pes 16 8 4 2 1  Rtat Hexa
                  04911 			;//                         -  contar pesos ( veure exple, per Ah)              xx   0x0C
                  04912 			;//                             -  de dalt a baix, es el codi a posar          x  x  0x12
                  04913 			;//                                                en el vector.               xxxx  0x1E
                  04914 			;//                   - Al inici cridar funcio per ecriure CGRAM               x  x  0x12
                  04915 			;//                    - Hi caben 8 carac especials de 64 a 120                  x   0x00
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 83

ADDR   CODE       LINE  SOURCE

                  04916 			;//                       de 8 e 8,  64 , 72, 80, 88, 96,104.112,120             xxx 0x04
                  04917 			;//                   - Despres d'escriure la CGRAM, cal fer un                  x x 0x07
                  04918 			;//                     comando, per no apuntar a la CGRAM                       x x 0x05
                  04919 			;// Per escriure simbol .... fer :   enviar_literal(3);enviar_literal(4);
                  04920 			;//************IMPORTANTE****************************************
                  04921 			;//******Poner despues de inicializar_lcd();*********************
                  04922 			;void RAM_LCD (void)
                  04923 			;{
                  04924 RAM_LCD
                  04925 			;	static const char Carac_1[] = {0x0C,0x10,0x08,0x04,0x1B,0x04,0x04,0x03};//caracter micro 	//escribir_literal(0);
                  04926 			;	static const char Carac_2[] = {0xEE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};	//escribir_literal(1); BAT_FULL
                  04927 			;	static const char Carac_3[] = {0xEE,0xFF,0xF1,0xFF,0xFF,0xFF,0xFF,0xFF};	// ""...               BAT_75
                  04928 			;	static const char Carac_4[] = {0xEE,0xFF,0xF1,0xF1,0xFF,0xFF,0xFF,0xFF};					    // BAT_50
                  04929 			;	static const char Carac_5[] = {0xEE,0xFF,0xF1,0xF1,0xF1,0xFF,0xFF,0xFF};					    // BAT_25
                  04930 			;	static const char Carac_6[] = {0xEE,0xFF,0xF1,0xF1,0xF1,0xF1,0xFF,0xFF};					    // BAT_10
                  04931 			;	static const char Carac_7[] = {0xEE,0xFF,0xF1,0xF1,0xF1,0xF1,0xF1,0xFF};					    // BAT_LW
                  04932 			;	static const char Carac_8[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
                  04933 			;	// 1era posicio CGRAM es la 64 , 72, 80, 88, 96,104.112,120
                  04934 			;	char i;
                  04935 			;	
                  04936 			;	enviar_comando (64);// primera posicio del Carac_1, els altres seran consecutius
0010D4 0E40       04937 	MOVLW 64
0010D6 ECD1 F003  04938 	CALL  enviar_comando
                  04939 			;	retardo_20u ();
0010DA EC5E F003  04940 	CALL  retardo_20u
                  04941 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_1[i]); retardo_20u (); retardo_20u ();}
0010DE 0100       04942 	MOVLB 0
0010E0 6BA7       04943 	CLRF  i_10,1
0010E2 0E08       04944 m185	MOVLW 8
0010E4 0100       04945 	MOVLB 0
0010E6 61A7       04946 	CPFSLT i_10,1
0010E8 D00D       04947 	BRA   m186
0010EA 0E1A       04948 	MOVLW 26
0010EC 25A7       04949 	ADDWF i_10,W,1
0010EE EC62 F00D  04950 	CALL  _const1
0010F2 EC0C F004  04951 	CALL  enviar_literal
0010F6 EC5E F003  04952 	CALL  retardo_20u
0010FA EC5E F003  04953 	CALL  retardo_20u
0010FE 0100       04954 	MOVLB 0
001100 2BA7       04955 	INCF  i_10,1,1
001102 D7EF       04956 	BRA   m185
                  04957 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_2[i]); retardo_20u (); retardo_20u ();}
001104 0100       04958 m186	MOVLB 0
001106 6BA7       04959 	CLRF  i_10,1
001108 0E08       04960 m187	MOVLW 8
00110A 0100       04961 	MOVLB 0
00110C 61A7       04962 	CPFSLT i_10,1
00110E D00D       04963 	BRA   m188
001110 0E22       04964 	MOVLW 34
001112 25A7       04965 	ADDWF i_10,W,1
001114 EC62 F00D  04966 	CALL  _const1
001118 EC0C F004  04967 	CALL  enviar_literal
00111C EC5E F003  04968 	CALL  retardo_20u
001120 EC5E F003  04969 	CALL  retardo_20u
001124 0100       04970 	MOVLB 0
001126 2BA7       04971 	INCF  i_10,1,1
001128 D7EF       04972 	BRA   m187
                  04973 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_3[i]); retardo_20u (); retardo_20u ();}
00112A 0100       04974 m188	MOVLB 0
00112C 6BA7       04975 	CLRF  i_10,1
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 84

ADDR   CODE       LINE  SOURCE

00112E 0E08       04976 m189	MOVLW 8
001130 0100       04977 	MOVLB 0
001132 61A7       04978 	CPFSLT i_10,1
001134 D00D       04979 	BRA   m190
001136 0E2A       04980 	MOVLW 42
001138 25A7       04981 	ADDWF i_10,W,1
00113A EC62 F00D  04982 	CALL  _const1
00113E EC0C F004  04983 	CALL  enviar_literal
001142 EC5E F003  04984 	CALL  retardo_20u
001146 EC5E F003  04985 	CALL  retardo_20u
00114A 0100       04986 	MOVLB 0
00114C 2BA7       04987 	INCF  i_10,1,1
00114E D7EF       04988 	BRA   m189
                  04989 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_4[i]); retardo_20u (); retardo_20u ();}
001150 0100       04990 m190	MOVLB 0
001152 6BA7       04991 	CLRF  i_10,1
001154 0E08       04992 m191	MOVLW 8
001156 0100       04993 	MOVLB 0
001158 61A7       04994 	CPFSLT i_10,1
00115A D00D       04995 	BRA   m192
00115C 0E32       04996 	MOVLW 50
00115E 25A7       04997 	ADDWF i_10,W,1
001160 EC62 F00D  04998 	CALL  _const1
001164 EC0C F004  04999 	CALL  enviar_literal
001168 EC5E F003  05000 	CALL  retardo_20u
00116C EC5E F003  05001 	CALL  retardo_20u
001170 0100       05002 	MOVLB 0
001172 2BA7       05003 	INCF  i_10,1,1
001174 D7EF       05004 	BRA   m191
                  05005 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_5[i]); retardo_20u (); retardo_20u ();}
001176 0100       05006 m192	MOVLB 0
001178 6BA7       05007 	CLRF  i_10,1
00117A 0E08       05008 m193	MOVLW 8
00117C 0100       05009 	MOVLB 0
00117E 61A7       05010 	CPFSLT i_10,1
001180 D00D       05011 	BRA   m194
001182 0E3A       05012 	MOVLW 58
001184 25A7       05013 	ADDWF i_10,W,1
001186 EC62 F00D  05014 	CALL  _const1
00118A EC0C F004  05015 	CALL  enviar_literal
00118E EC5E F003  05016 	CALL  retardo_20u
001192 EC5E F003  05017 	CALL  retardo_20u
001196 0100       05018 	MOVLB 0
001198 2BA7       05019 	INCF  i_10,1,1
00119A D7EF       05020 	BRA   m193
                  05021 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_6[i]); retardo_20u (); retardo_20u ();}
00119C 0100       05022 m194	MOVLB 0
00119E 6BA7       05023 	CLRF  i_10,1
0011A0 0E08       05024 m195	MOVLW 8
0011A2 0100       05025 	MOVLB 0
0011A4 61A7       05026 	CPFSLT i_10,1
0011A6 D00D       05027 	BRA   m196
0011A8 0E42       05028 	MOVLW 66
0011AA 25A7       05029 	ADDWF i_10,W,1
0011AC EC62 F00D  05030 	CALL  _const1
0011B0 EC0C F004  05031 	CALL  enviar_literal
0011B4 EC5E F003  05032 	CALL  retardo_20u
0011B8 EC5E F003  05033 	CALL  retardo_20u
0011BC 0100       05034 	MOVLB 0
0011BE 2BA7       05035 	INCF  i_10,1,1
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 85

ADDR   CODE       LINE  SOURCE

0011C0 D7EF       05036 	BRA   m195
                  05037 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_7[i]); retardo_20u (); retardo_20u ();}
0011C2 0100       05038 m196	MOVLB 0
0011C4 6BA7       05039 	CLRF  i_10,1
0011C6 0E08       05040 m197	MOVLW 8
0011C8 0100       05041 	MOVLB 0
0011CA 61A7       05042 	CPFSLT i_10,1
0011CC D00D       05043 	BRA   m198
0011CE 0E4A       05044 	MOVLW 74
0011D0 25A7       05045 	ADDWF i_10,W,1
0011D2 EC62 F00D  05046 	CALL  _const1
0011D6 EC0C F004  05047 	CALL  enviar_literal
0011DA EC5E F003  05048 	CALL  retardo_20u
0011DE EC5E F003  05049 	CALL  retardo_20u
0011E2 0100       05050 	MOVLB 0
0011E4 2BA7       05051 	INCF  i_10,1,1
0011E6 D7EF       05052 	BRA   m197
                  05053 			;	for(i=0;i<=7;i++) { enviar_literal (Carac_8[i]); retardo_20u (); retardo_20u ();}	
0011E8 0100       05054 m198	MOVLB 0
0011EA 6BA7       05055 	CLRF  i_10,1
0011EC 0E08       05056 m199	MOVLW 8
0011EE 0100       05057 	MOVLB 0
0011F0 61A7       05058 	CPFSLT i_10,1
0011F2 D00D       05059 	BRA   m200
0011F4 0E52       05060 	MOVLW 82
0011F6 25A7       05061 	ADDWF i_10,W,1
0011F8 EC62 F00D  05062 	CALL  _const1
0011FC EC0C F004  05063 	CALL  enviar_literal
001200 EC5E F003  05064 	CALL  retardo_20u
001204 EC5E F003  05065 	CALL  retardo_20u
001208 0100       05066 	MOVLB 0
00120A 2BA7       05067 	INCF  i_10,1,1
00120C D7EF       05068 	BRA   m199
                  05069 			;	enviar_comando (0b.0000.0010);
00120E 0E02       05070 m200	MOVLW 2
001210 EFD1 F003  05071 	GOTO  enviar_comando
                  05072 			;	
                  05073 			;	return;
                  05074 
                  05075   ; FILE medir_18F4XK20.h
                  05076 			;/*función void medir (char, char)
                  05077 			;recibe como parámetros:
                  05078 			;Primer parámetro: el canal A/D a convertir  (0...4,8...13) . Si está fuera del rango, toma 0 por defecto
                  05079 			;Segundo parámetro: solo admite 8 o 10 (bits del resultado). si el parámetro no es 8 o 10,
                  05080 			;interpreta automáticamente a 10.
                  05081 			;Siempre. se configura automáticamente la entrada analógica solicitada. Fosc/32
                  05082 			;Requiere la función retardo_20u()  (en retardos.h)
                  05083 			;resultado: en ADRESH:ADRESL
                  05084 			;*/
                  05085 			;uns16 medir (char canal, char bits)
                  05086 			;{
                  05087 medir
001214 0100       05088 	MOVLB 0
001216 6FAD       05089 	MOVWF bits,1
                  05090 			;	uns16 resultado;
                  05091 			;	switch (canal)
001218 51AC       05092 	MOVF  canal,W,1
00121A B4D8       05093 	BTFSC 0xFD8,Zero_,0
00121C D028       05094 	BRA   m201
00121E 0A01       05095 	XORLW 1
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 86

ADDR   CODE       LINE  SOURCE

001220 B4D8       05096 	BTFSC 0xFD8,Zero_,0
001222 D028       05097 	BRA   m202
001224 0A03       05098 	XORLW 3
001226 B4D8       05099 	BTFSC 0xFD8,Zero_,0
001228 D028       05100 	BRA   m203
00122A 0A01       05101 	XORLW 1
00122C B4D8       05102 	BTFSC 0xFD8,Zero_,0
00122E D028       05103 	BRA   m204
001230 0A07       05104 	XORLW 7
001232 B4D8       05105 	BTFSC 0xFD8,Zero_,0
001234 D028       05106 	BRA   m205
001236 0A01       05107 	XORLW 1
001238 B4D8       05108 	BTFSC 0xFD8,Zero_,0
00123A D028       05109 	BRA   m206
00123C 0A03       05110 	XORLW 3
00123E B4D8       05111 	BTFSC 0xFD8,Zero_,0
001240 D028       05112 	BRA   m207
001242 0A01       05113 	XORLW 1
001244 B4D8       05114 	BTFSC 0xFD8,Zero_,0
001246 D028       05115 	BRA   m208
001248 0A0F       05116 	XORLW 15
00124A B4D8       05117 	BTFSC 0xFD8,Zero_,0
00124C D028       05118 	BRA   m209
00124E 0A01       05119 	XORLW 1
001250 B4D8       05120 	BTFSC 0xFD8,Zero_,0
001252 D028       05121 	BRA   m210
001254 0A03       05122 	XORLW 3
001256 B4D8       05123 	BTFSC 0xFD8,Zero_,0
001258 D028       05124 	BRA   m211
00125A 0A01       05125 	XORLW 1
00125C B4D8       05126 	BTFSC 0xFD8,Zero_,0
00125E D028       05127 	BRA   m212
001260 0A07       05128 	XORLW 7
001262 B4D8       05129 	BTFSC 0xFD8,Zero_,0
001264 D028       05130 	BRA   m213
001266 0A01       05131 	XORLW 1
001268 B4D8       05132 	BTFSC 0xFD8,Zero_,0
00126A D028       05133 	BRA   m214
00126C D02A       05134 	BRA   m215
                  05135 			;	{
                  05136 			;		//del 0 al 4, están en el PORTA
                  05137 			;		case 0: 	ADCON0 = 0b.00.0000.01;		break;
00126E 0E01       05138 m201	MOVLW 1
001270 6EC2       05139 	MOVWF ADCON0,0
001272 D029       05140 	BRA   m216
                  05141 			;		case 1:		ADCON0 = 0b.00.0001.01;		break;
001274 0E05       05142 m202	MOVLW 5
001276 6EC2       05143 	MOVWF ADCON0,0
001278 D026       05144 	BRA   m216
                  05145 			;		case 2:		ADCON0 = 0b.00.0010.01;		break;
00127A 0E09       05146 m203	MOVLW 9
00127C 6EC2       05147 	MOVWF ADCON0,0
00127E D023       05148 	BRA   m216
                  05149 			;		case 3:		ADCON0 = 0b.00.0011.01;		break;
001280 0E0D       05150 m204	MOVLW 13
001282 6EC2       05151 	MOVWF ADCON0,0
001284 D020       05152 	BRA   m216
                  05153 			;		case 4:		ADCON0 = 0b.00.0100.01;		break;
001286 0E11       05154 m205	MOVLW 17
001288 6EC2       05155 	MOVWF ADCON0,0
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 87

ADDR   CODE       LINE  SOURCE

00128A D01D       05156 	BRA   m216
                  05157 			;		case 5:		ADCON0 = 0b.00.0101.01;		break;
00128C 0E15       05158 m206	MOVLW 21
00128E 6EC2       05159 	MOVWF ADCON0,0
001290 D01A       05160 	BRA   m216
                  05161 			;		case 6:		ADCON0 = 0b.00.0110.01;		break;
001292 0E19       05162 m207	MOVLW 25
001294 6EC2       05163 	MOVWF ADCON0,0
001296 D017       05164 	BRA   m216
                  05165 			;		case 7:		ADCON0 = 0b.00.0111.01;		break;
001298 0E1D       05166 m208	MOVLW 29
00129A 6EC2       05167 	MOVWF ADCON0,0
00129C D014       05168 	BRA   m216
                  05169 			;		case 8:		ADCON0 = 0b.00.1000.01;		break;
00129E 0E21       05170 m209	MOVLW 33
0012A0 6EC2       05171 	MOVWF ADCON0,0
0012A2 D011       05172 	BRA   m216
                  05173 			;		case 9:		ADCON0 = 0b.00.1001.01;		break;
0012A4 0E25       05174 m210	MOVLW 37
0012A6 6EC2       05175 	MOVWF ADCON0,0
0012A8 D00E       05176 	BRA   m216
                  05177 			;		case 10:	ADCON0 = 0b.00.1010.01;		break;
0012AA 0E29       05178 m211	MOVLW 41
0012AC 6EC2       05179 	MOVWF ADCON0,0
0012AE D00B       05180 	BRA   m216
                  05181 			;		case 11:	ADCON0 = 0b.00.1011.01;		break;
0012B0 0E2D       05182 m212	MOVLW 45
0012B2 6EC2       05183 	MOVWF ADCON0,0
0012B4 D008       05184 	BRA   m216
                  05185 			;		case 12:	ADCON0 = 0b.00.1100.01;		break;
0012B6 0E31       05186 m213	MOVLW 49
0012B8 6EC2       05187 	MOVWF ADCON0,0
0012BA D005       05188 	BRA   m216
                  05189 			;		case 13:	ADCON0 = 0b.00.1101.01;		break;
0012BC 0E35       05190 m214	MOVLW 53
0012BE 6EC2       05191 	MOVWF ADCON0,0
0012C0 D002       05192 	BRA   m216
                  05193 			;		default:	ADCON0 = 0b.00.0000.01;
0012C2 0E01       05194 m215	MOVLW 1
0012C4 6EC2       05195 	MOVWF ADCON0,0
                  05196 			;	}
                  05197 			;	if (bits == 8){ADFM=0;GO = 1;  while(GO);resultado = ADRESH;}
0012C6 0E08       05198 m216	MOVLW 8
0012C8 0100       05199 	MOVLB 0
0012CA 63AD       05200 	CPFSEQ bits,1
0012CC D009       05201 	BRA   m218
0012CE 9EC0       05202 	BCF   0xFC0,ADFM,0
0012D0 82C2       05203 	BSF   0xFC2,GO,0
0012D2 B2C2       05204 m217	BTFSC 0xFC2,GO,0
0012D4 D7FE       05205 	BRA   m217
0012D6 CFC4 F0AE  05206 	MOVFF ADRESH,resultado
0012DA 0100       05207 	MOVLB 0
0012DC 6BAF       05208 	CLRF  resultado+1,1
                  05209 			;	else 		  {ADFM=1;GO = 1;  while(GO);resultado.low8 = ADRESL;resultado.high8 = ADRESH;}
0012DE D008       05210 	BRA   m220
0012E0 8EC0       05211 m218	BSF   0xFC0,ADFM,0
0012E2 82C2       05212 	BSF   0xFC2,GO,0
0012E4 B2C2       05213 m219	BTFSC 0xFC2,GO,0
0012E6 D7FE       05214 	BRA   m219
0012E8 CFC3 F0AE  05215 	MOVFF ADRESL,resultado
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 88

ADDR   CODE       LINE  SOURCE

0012EC CFC4 F0AF  05216 	MOVFF ADRESH,resultado+1
                  05217 			;   	
                  05218 			;   	return resultado;
0012F0 0100       05219 m220	MOVLB 0
0012F2 51AE       05220 	MOVF  resultado,W,1
0012F4 0012       05221 	RETURN
                  05222 
                  05223   ; FILE ondulador_float.c
                  05224 			;
                  05225 			;
                  05226 			; //**************************************************************************************//
                  05227 			; //*******************  I N C L U D E S    Y    F U N C I O N E S ***********************//
                  05228 			; //**************************************************************************************//
                  05229 			;#include "MATH24F.H"
                  05230 			;#include "MATH16.H"
                  05231 			;#include "MATH24LB.H"
                  05232 			;#include "Temporiz_64Mhz.h"
                  05233 			;#include "LCD_4bit.h"
                  05234 			;#include "medir_18F4XK20.h"
                  05235 			;
                  05236 			;
                  05237 			;void configuraPic (void);
                  05238 			;
                  05239 			; //**************************************************************************************//
                  05240 			; //******************** M E N S A J E S   Y   A R R A Y S *******************************//
                  05241 			; //**************************************************************************************//
                  05242 			;
                  05243 			;static const char mensaje1[19] ="ONDULADOR 50HZ  by ";
                  05244 			;static const char mensaje2[3] ="VAC";
                  05245 			;static const char mensaje3[5] ="VMAX:";
                  05246 			;static const char mensaje4[4] ="RAIZ";
                  05247 			;
                  05248 			; //**************************************************************************************//
                  05249 			; //************************  P R O G R A M A   P R I N C I P A L ************************//
                  05250 			; //**************************************************************************************//
                  05251 			;
                  05252 			;void main (void)
                  05253 			;{
                  05254 main
                  05255 			;
                  05256 			;	
                  05257 			;	configuraPic (); 				// Configuramos todos los puertos y PWM
0012F6 DBCC       05258 	RCALL configuraPic
                  05259 			;
                  05260 			;
                  05261 			;	char p,h=0;
0012F8 0100       05262 	MOVLB 0
0012FA 6B6E       05263 	CLRF  h,1
                  05264 			;
                  05265 			;	OSCTUNE=0b.01.000000; //PLL enable 
0012FC 0E40       05266 	MOVLW 64
0012FE 6E9B       05267 	MOVWF OSCTUNE,0
                  05268 			;	
                  05269 			;	RCON = 0b.01111111; //C18 pag 80 i 167  Causes del RESET i IPEN (priority Enabled o no)
001300 0E7F       05270 	MOVLW 127
001302 6ED0       05271 	MOVWF RCON,0
                  05272 			;	OSCCON    = 0b.0.111.0.0.00;
001304 0E70       05273 	MOVLW 112
001306 6ED3       05274 	MOVWF OSCCON,0
                  05275 			;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 89

ADDR   CODE       LINE  SOURCE

                  05276 			;	inicializar_lcd(); 
001308 ECA3 F004  05277 	CALL  inicializar_lcd
                  05278 			;	borrar_lcd();
00130C EC2A F005  05279 	CALL  borrar_lcd
                  05280 			;//	retardo_100m();
                  05281 			;	RAM_LCD();
001310 DEE1       05282 	RCALL RAM_LCD
                  05283 			;
                  05284 			;	borrar_lcd();
001312 EC2A F005  05285 	CALL  borrar_lcd
                  05286 			;	escribir_posicion (1, 1);
001316 0E01       05287 	MOVLW 1
001318 0100       05288 	MOVLB 0
00131A 6FA7       05289 	MOVWF linea,1
00131C 0E01       05290 	MOVLW 1
00131E ECDE F004  05291 	CALL  escribir_posicion
                  05292 			;	
                  05293 			;	//for(p=0;p<19;p++ )enviar_literal(mensaje1[p]);
                  05294 			;	//enviar_literal(LOGO_SC);
                  05295 			;
                  05296 			;	T0CON   = 0b.01000.001; //(PIC 18F4550)	// Equivale junto con INTCON2 al OPTION_REG del 16F88x).							
                           	
001322 0E41       05297 	MOVLW 65
001324 6ED5       05298 	MOVWF T0CON,0
                  05299 			;	INTCON2 = 0b.0000.0100; //(PIC 18F4550)	// Equivale junto con T0CON al OPTION_REG del 16F88x).	
001326 0E04       05300 	MOVLW 4
001328 6EF1       05301 	MOVWF INTCON2,0
                  05302 			;	TMR0IF = 0;   //T0IF = 0; (PIC 16F88x)	// Ponemos el flanco de interrupciones a cero (aun no se ha efectuado ninguna).
00132A 94F2       05303 	BCF   0xFF2,TMR0IF,0
                  05304 			;   // w1   =   0;								// Reseteamos la variable índice de la tabla.
                  05305 			;	LATD.0 =0;           
00132C 908C       05306 	BCF   LATD,0,0
                  05307 			;
                  05308 			;	Vmax = 3.0; //2 el pwm maximo en 
00132E 0100       05309 	MOVLB 0
001330 6BD0       05310 	CLRF  Vmax,1
001332 0E40       05311 	MOVLW 64
001334 6FD1       05312 	MOVWF Vmax+1,1
001336 0E80       05313 	MOVLW 128
001338 6FD2       05314 	MOVWF Vmax+2,1
                  05315 			;
                  05316 			;	INTCON = 0b.0100.0000;				// Interrupciones globales (bit 7) e interrupción por Timer0 (bit 5) activadas.
00133A 0E40       05317 	MOVLW 64
00133C 6EF2       05318 	MOVWF INTCON,0
                  05319 			;
                  05320 			;	// COMENÇO AL PAS PER 0, AMB 2 CICLES DE PWM A Ton=0 --> SON 100uS
                  05321 			;	T=0;
00133E 6BD5       05322 	CLRF  T,1
                  05323 			;	ancho_pwm =0; 
001340 6BCC       05324 	CLRF  ancho_pwm,1
001342 6BCD       05325 	CLRF  ancho_pwm+1,1
                  05326 			;	bUdw=1;	// Començo carregant 0
001344 81CB       05327 	BSF   0xCB,bUdw,1
                  05328 			;	for (p = 1; p <= 6; p ++)  ancho_pwm = rl (ancho_pwm);
001346 0E01       05329 	MOVLW 1
001348 6F6D       05330 	MOVWF p,1
00134A 0E07       05331 m221	MOVLW 7
00134C 0100       05332 	MOVLB 0
00134E 616D       05333 	CPFSLT p,1
001350 D004       05334 	BRA   m222
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 90

ADDR   CODE       LINE  SOURCE

001352 37CC       05335 	RLCF  ancho_pwm,1,1
001354 37CD       05336 	RLCF  ancho_pwm+1,1,1
001356 2B6D       05337 	INCF  p,1,1
001358 D7F8       05338 	BRA   m221
                  05339 			;	CCPR1L = ancho_pwm.high8;
00135A C0CD FFBE  05340 m222	MOVFF ancho_pwm+1,CCPR1L
                  05341 			;	CCP1CON.5 = ancho_pwm.7;
00135E 0100       05342 	MOVLB 0
001360 AFCC       05343 	BTFSS ancho_pwm,7,1
001362 9ABD       05344 	BCF   CCP1CON,5,0
001364 BFCC       05345 	BTFSC ancho_pwm,7,1
001366 8ABD       05346 	BSF   CCP1CON,5,0
                  05347 			;	CCP1CON.4 = ancho_pwm.6; // PWM carregat a 0
001368 ADCC       05348 	BTFSS ancho_pwm,6,1
00136A 98BD       05349 	BCF   CCP1CON,4,0
00136C BDCC       05350 	BTFSC ancho_pwm,6,1
00136E 88BD       05351 	BSF   CCP1CON,4,0
                  05352 			;	TMR2IF=0;	
001370 929E       05353 	BCF   0xF9E,TMR2IF,0
                  05354 			;	TMR2IE=1; 
001372 829D       05355 	BSF   0xF9D,TMR2IE,0
                  05356 			;	TMR2ON  = 1;
001374 84CA       05357 	BSF   0xFCA,TMR2ON,0
                  05358 			;	T++; SENO = sen[T];		
001376 2BD5       05359 	INCF  T,1,1
001378 51D5       05360 	MOVF  T,W,1
00137A DBA4       05361 	RCALL _const1
00137C 0100       05362 	MOVLB 0
00137E 6FD3       05363 	MOVWF SENO,1
001380 6BD4       05364 	CLRF  SENO+1,1
                  05365 			;	ancho_pwm = (uns16)SENO*Vmax; // PREPARO SEGUENT VALOR
001382 C0D3 F0B0  05366 	MOVFF SENO,arg1f24
001386 C0D4 F0B1  05367 	MOVFF SENO+1,arg1f24+1
00138A 6BB2       05368 	CLRF  arg1f24+2,1
00138C ECB8 F001  05369 	CALL  _int24ToFloat24
001390 C0D0 F0B3  05370 	MOVFF Vmax,arg2f24
001394 C0D1 F0B4  05371 	MOVFF Vmax+1,arg2f24+1
001398 C0D2 F0B5  05372 	MOVFF Vmax+2,arg2f24+2
00139C ECA6 F000  05373 	CALL  _fmul24
0013A0 ECFD F001  05374 	CALL  _float24ToInt24
0013A4 C0B0 F0CC  05375 	MOVFF rval_3,ancho_pwm
0013A8 C0B1 F0CD  05376 	MOVFF rval_3+1,ancho_pwm+1
                  05377 			; //**************************************************************************************//
                  05378 			; //*******************  V A R I A B L E S   L O C A L E L E S ***************************//
                  05379 			; //**************************************************************************************//
                  05380 			;	estado=LECTURA_VAC; //empieza por LECTURA_VAC
0013AC 0100       05381 	MOVLB 0
0013AE 6BD7       05382 	CLRF  estado,1
                  05383 			;	uns8 x;
                  05384 			;	uns8 vac[16],ac;    //variables para guardar temporalmente las arrays
                  05385 			;	uns8 iac[16],ic;
                  05386 			;	char vbat,o=0,vuelta=0; 
0013B0 6B93       05387 	CLRF  o,1
0013B2 6B94       05388 	CLRF  vuelta,1
                  05389 			;	bit lectura=0;
0013B4 91A6       05390 	BCF   0xA6,lectura,1
                  05391 			;	float raiz,errorAcu;
                  05392 			;	uns16 Mac0,Mac1;
                  05393 			;	uns16 q,a;//debug
                  05394 			;	float ProbaVmax;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 91

ADDR   CODE       LINE  SOURCE

                  05395 			;	
                  05396 			;	escribir_posicion (2, 1);
0013B6 0E02       05397 	MOVLW 2
0013B8 6FA7       05398 	MOVWF linea,1
0013BA 0E01       05399 	MOVLW 1
0013BC ECDE F004  05400 	CALL  escribir_posicion
                  05401 			; 	//for(p=0; p<3; p++)enviar_literal(mensaje2[p]);
                  05402 			; 	escribir_posicion (4, 1);
0013C0 0E04       05403 	MOVLW 4
0013C2 0100       05404 	MOVLB 0
0013C4 6FA7       05405 	MOVWF linea,1
0013C6 0E01       05406 	MOVLW 1
0013C8 ECDE F004  05407 	CALL  escribir_posicion
                  05408 			; 	//for(p=0; p<5; p++)enviar_literal(mensaje3[p]);
                  05409 			; 	escribir_posicion (4, 10);
0013CC 0E04       05410 	MOVLW 4
0013CE 0100       05411 	MOVLB 0
0013D0 6FA7       05412 	MOVWF linea,1
0013D2 0E0A       05413 	MOVLW 10
0013D4 ECDE F004  05414 	CALL  escribir_posicion
                  05415 			;	//for(p=0; p<4; p++)enviar_literal(mensaje4[p]);
                  05416 			; 	GIE=1;
0013D8 8EF2       05417 	BSF   0xFF2,GIE,0
                  05418 			;	ADCON1=0b.0000.0000;
0013DA 6AC1       05419 	CLRF  ADCON1,0
                  05420 			;	ADCON2=0b.10.001.110;
0013DC 0E8E       05421 	MOVLW 142
0013DE 6EC0       05422 	MOVWF ADCON2,0
                  05423 			;
                  05424 			; //**************************************************************************************//
                  05425 			; //**************************  B U C L E   I N F I N I T O  *****************************//
                  05426 			; //**************************************************************************************//
                  05427 			;	while (1)       					
                  05428 			;	{
                  05429 			;		switch(estado){
0013E0 0100       05430 m223	MOVLB 0
0013E2 51D7       05431 	MOVF  estado,W,1
0013E4 B4D8       05432 	BTFSC 0xFD8,Zero_,0
0013E6 D00D       05433 	BRA   m224
0013E8 0A01       05434 	XORLW 1
0013EA B4D8       05435 	BTFSC 0xFD8,Zero_,0
0013EC D0FE       05436 	BRA   m239
0013EE 0A03       05437 	XORLW 3
0013F0 B4D8       05438 	BTFSC 0xFD8,Zero_,0
0013F2 D1D3       05439 	BRA   m245
0013F4 0A01       05440 	XORLW 1
0013F6 B4D8       05441 	BTFSC 0xFD8,Zero_,0
0013F8 D1D4       05442 	BRA   m246
0013FA 0A07       05443 	XORLW 7
0013FC B4D8       05444 	BTFSC 0xFD8,Zero_,0
0013FE D240       05445 	BRA   m255
001400 D7EF       05446 	BRA   m223
                  05447 			;			case LECTURA_VAC:
                  05448 			;				x=0;
001402 0100       05449 m224	MOVLB 0
001404 6B6F       05450 	CLRF  x,1
                  05451 			;				if(!lectura){
001406 B1A6       05452 	BTFSC 0xA6,lectura,1
001408 D071       05453 	BRA   m231
                  05454 			;					while(LATD.0==1){   
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 92

ADDR   CODE       LINE  SOURCE

00140A A08C       05455 m225	BTFSS LATD,0,0
00140C D06F       05456 	BRA   m231
                  05457 			;						r= Vmax;
00140E C0D0 F0B0  05458 	MOVFF Vmax,arg1f24
001412 C0D1 F0B1  05459 	MOVFF Vmax+1,arg1f24+1
001416 C0D2 F0B2  05460 	MOVFF Vmax+2,arg1f24+2
00141A ECFD F001  05461 	CALL  _float24ToInt24
00141E C0B0 F0CE  05462 	MOVFF rval_3,r
001422 C0B1 F0CF  05463 	MOVFF rval_3+1,r+1
                  05464 			;						if (((T == 5)&&((x==0)||(x==7))) || ((T == 10 )&&((x==1)||(x==6))) || ((T == 15)&&((x==2)||(x==5)))||((T ==20)&&
                           ((x==3)||(x==4)))) {
001426 0E05       05465 	MOVLW 5
001428 0100       05466 	MOVLB 0
00142A 63D5       05467 	CPFSEQ T,1
00142C D007       05468 	BRA   m226
00142E 536F       05469 	MOVF  x,1,1
001430 B4D8       05470 	BTFSC 0xFD8,Zero_,0
001432 D025       05471 	BRA   m229
001434 516F       05472 	MOVF  x,W,1
001436 0A07       05473 	XORLW 7
001438 B4D8       05474 	BTFSC 0xFD8,Zero_,0
00143A D021       05475 	BRA   m229
00143C 0E0A       05476 m226	MOVLW 10
00143E 0100       05477 	MOVLB 0
001440 63D5       05478 	CPFSEQ T,1
001442 D006       05479 	BRA   m227
001444 4D6F       05480 	DCFSNZ x,W,1
001446 D01B       05481 	BRA   m229
001448 516F       05482 	MOVF  x,W,1
00144A 0A06       05483 	XORLW 6
00144C B4D8       05484 	BTFSC 0xFD8,Zero_,0
00144E D017       05485 	BRA   m229
001450 0E0F       05486 m227	MOVLW 15
001452 0100       05487 	MOVLB 0
001454 63D5       05488 	CPFSEQ T,1
001456 D008       05489 	BRA   m228
001458 516F       05490 	MOVF  x,W,1
00145A 0A02       05491 	XORLW 2
00145C B4D8       05492 	BTFSC 0xFD8,Zero_,0
00145E D00F       05493 	BRA   m229
001460 516F       05494 	MOVF  x,W,1
001462 0A05       05495 	XORLW 5
001464 B4D8       05496 	BTFSC 0xFD8,Zero_,0
001466 D00B       05497 	BRA   m229
001468 0E14       05498 m228	MOVLW 20
00146A 0100       05499 	MOVLB 0
00146C 63D5       05500 	CPFSEQ T,1
00146E D03B       05501 	BRA   m230
001470 516F       05502 	MOVF  x,W,1
001472 0A03       05503 	XORLW 3
001474 B4D8       05504 	BTFSC 0xFD8,Zero_,0
001476 D003       05505 	BRA   m229
001478 0E04       05506 	MOVLW 4
00147A 636F       05507 	CPFSEQ x,1
00147C D034       05508 	BRA   m230
                  05509 			;						PORTC.3=1;
00147E 8682       05510 m229	BSF   PORTC,3,0
                  05511 			;						ac=medir(LEO_VAC,8);
001480 0100       05512 	MOVLB 0
001482 6BAC       05513 	CLRF  canal,1
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 93

ADDR   CODE       LINE  SOURCE

001484 0E08       05514 	MOVLW 8
001486 DEC6       05515 	RCALL medir
001488 C0AE F080  05516 	MOVFF resultado,ac
                  05517 			;						ic=medir(LEO_IAC,8);
00148C 0E02       05518 	MOVLW 2
00148E 0100       05519 	MOVLB 0
001490 6FAC       05520 	MOVWF canal,1
001492 0E08       05521 	MOVLW 8
001494 DEBF       05522 	RCALL medir
001496 C0AE F091  05523 	MOVFF resultado,ic
                  05524 			;						PORTC.3=0;
00149A 9682       05525 	BCF   PORTC,3,0
                  05526 			;						vac[x]=127-ac;
00149C 6AEA       05527 	CLRF  FSR0+1,0
00149E 0E70       05528 	MOVLW 112
0014A0 0100       05529 	MOVLB 0
0014A2 256F       05530 	ADDWF x,W,1
0014A4 6EE9       05531 	MOVWF FSR0,0
0014A6 5180       05532 	MOVF  ac,W,1
0014A8 087F       05533 	SUBLW 127
0014AA 6EEF       05534 	MOVWF INDF0,0
                  05535 			;						iac[x]=ic;
0014AC 6AEA       05536 	CLRF  FSR0+1,0
0014AE 0E81       05537 	MOVLW 129
0014B0 256F       05538 	ADDWF x,W,1
0014B2 6EE9       05539 	MOVWF FSR0,0
0014B4 C091 FFEF  05540 	MOVFF ic,INDF0
                  05541 			;						x++;	
0014B8 2B6F       05542 	INCF  x,1,1
                  05543 			;						if ((T==20&&x==4)) {
0014BA 0E14       05544 	MOVLW 20
0014BC 63D5       05545 	CPFSEQ T,1
0014BE D013       05546 	BRA   m230
0014C0 0E04       05547 	MOVLW 4
0014C2 636F       05548 	CPFSEQ x,1
0014C4 D010       05549 	BRA   m230
                  05550 			;							retardo_20u();retardo_20u();retardo_20u();retardo_20u();
0014C6 EC5E F003  05551 	CALL  retardo_20u
0014CA EC5E F003  05552 	CALL  retardo_20u
0014CE EC5E F003  05553 	CALL  retardo_20u
0014D2 EC5E F003  05554 	CALL  retardo_20u
                  05555 			;							retardo_20u();retardo_20u();retardo_20u();retardo_20u();}
0014D6 EC5E F003  05556 	CALL  retardo_20u
0014DA EC5E F003  05557 	CALL  retardo_20u
0014DE EC5E F003  05558 	CALL  retardo_20u
0014E2 EC5E F003  05559 	CALL  retardo_20u
                  05560 			;						}	
                  05561 			;						lectura=1;	
0014E6 0100       05562 m230	MOVLB 0
0014E8 81A6       05563 	BSF   0xA6,lectura,1
                  05564 			;					}
0014EA D78F       05565 	BRA   m225
                  05566 			;				}
                  05567 			;				if(lectura){
0014EC 0100       05568 m231	MOVLB 0
0014EE A1A6       05569 	BTFSS 0xA6,lectura,1
0014F0 D074       05570 	BRA   m238
                  05571 			;					r= Vmax; // ponemos aqui para hacerlo efectivo al paso por cero,se intentó en la interrupcion pero daba problemas el co
                           mpilador
0014F2 C0D0 F0B0  05572 	MOVFF Vmax,arg1f24
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 94

ADDR   CODE       LINE  SOURCE

0014F6 C0D1 F0B1  05573 	MOVFF Vmax+1,arg1f24+1
0014FA C0D2 F0B2  05574 	MOVFF Vmax+2,arg1f24+2
0014FE ECFD F001  05575 	CALL  _float24ToInt24
001502 C0B0 F0CE  05576 	MOVFF rval_3,r
001506 C0B1 F0CF  05577 	MOVFF rval_3+1,r+1
                  05578 			;					while(LATD.0==0){
00150A B08C       05579 m232	BTFSC LATD,0,0
00150C D066       05580 	BRA   m238
                  05581 			;						if  (((T == 5)&&((x==8)||(x==15))) || ((T == 10 )&&((x==9)||(x==14))) || ((T == 15)&&((x==10)||(x==13)))||((T ==
                           20)&&((x==11)||(x==12)))) {
00150E 0E05       05582 	MOVLW 5
001510 0100       05583 	MOVLB 0
001512 63D5       05584 	CPFSEQ T,1
001514 D008       05585 	BRA   m233
001516 516F       05586 	MOVF  x,W,1
001518 0A08       05587 	XORLW 8
00151A B4D8       05588 	BTFSC 0xFD8,Zero_,0
00151C D027       05589 	BRA   m236
00151E 516F       05590 	MOVF  x,W,1
001520 0A0F       05591 	XORLW 15
001522 B4D8       05592 	BTFSC 0xFD8,Zero_,0
001524 D023       05593 	BRA   m236
001526 0E0A       05594 m233	MOVLW 10
001528 0100       05595 	MOVLB 0
00152A 63D5       05596 	CPFSEQ T,1
00152C D008       05597 	BRA   m234
00152E 516F       05598 	MOVF  x,W,1
001530 0A09       05599 	XORLW 9
001532 B4D8       05600 	BTFSC 0xFD8,Zero_,0
001534 D01B       05601 	BRA   m236
001536 516F       05602 	MOVF  x,W,1
001538 0A0E       05603 	XORLW 14
00153A B4D8       05604 	BTFSC 0xFD8,Zero_,0
00153C D017       05605 	BRA   m236
00153E 0E0F       05606 m234	MOVLW 15
001540 0100       05607 	MOVLB 0
001542 63D5       05608 	CPFSEQ T,1
001544 D008       05609 	BRA   m235
001546 516F       05610 	MOVF  x,W,1
001548 0A0A       05611 	XORLW 10
00154A B4D8       05612 	BTFSC 0xFD8,Zero_,0
00154C D00F       05613 	BRA   m236
00154E 516F       05614 	MOVF  x,W,1
001550 0A0D       05615 	XORLW 13
001552 B4D8       05616 	BTFSC 0xFD8,Zero_,0
001554 D00B       05617 	BRA   m236
001556 0E14       05618 m235	MOVLW 20
001558 0100       05619 	MOVLB 0
00155A 63D5       05620 	CPFSEQ T,1
00155C D03B       05621 	BRA   m237
00155E 516F       05622 	MOVF  x,W,1
001560 0A0B       05623 	XORLW 11
001562 B4D8       05624 	BTFSC 0xFD8,Zero_,0
001564 D003       05625 	BRA   m236
001566 0E0C       05626 	MOVLW 12
001568 636F       05627 	CPFSEQ x,1
00156A D034       05628 	BRA   m237
                  05629 			;						PORTC.3=1;
00156C 8682       05630 m236	BSF   PORTC,3,0
                  05631 			;						ac=medir(LEO_VAC,8);
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 95

ADDR   CODE       LINE  SOURCE

00156E 0100       05632 	MOVLB 0
001570 6BAC       05633 	CLRF  canal,1
001572 0E08       05634 	MOVLW 8
001574 DE4F       05635 	RCALL medir
001576 C0AE F080  05636 	MOVFF resultado,ac
                  05637 			;						ic=medir(LEO_IAC,8);
00157A 0E02       05638 	MOVLW 2
00157C 0100       05639 	MOVLB 0
00157E 6FAC       05640 	MOVWF canal,1
001580 0E08       05641 	MOVLW 8
001582 DE48       05642 	RCALL medir
001584 C0AE F091  05643 	MOVFF resultado,ic
                  05644 			;						PORTC=0;
001588 6A82       05645 	CLRF  PORTC,0
                  05646 			;						vac[x]=ac-127;
00158A 6AEA       05647 	CLRF  FSR0+1,0
00158C 0E70       05648 	MOVLW 112
00158E 0100       05649 	MOVLB 0
001590 256F       05650 	ADDWF x,W,1
001592 6EE9       05651 	MOVWF FSR0,0
001594 0E7F       05652 	MOVLW 127
001596 5D80       05653 	SUBWF ac,W,1
001598 6EEF       05654 	MOVWF INDF0,0
                  05655 			;						iac[x]=ic;
00159A 6AEA       05656 	CLRF  FSR0+1,0
00159C 0E81       05657 	MOVLW 129
00159E 256F       05658 	ADDWF x,W,1
0015A0 6EE9       05659 	MOVWF FSR0,0
0015A2 C091 FFEF  05660 	MOVFF ic,INDF0
                  05661 			;						x++;	
0015A6 2B6F       05662 	INCF  x,1,1
                  05663 			;						if ((T==20&&x==12)) {
0015A8 0E14       05664 	MOVLW 20
0015AA 63D5       05665 	CPFSEQ T,1
0015AC D013       05666 	BRA   m237
0015AE 0E0C       05667 	MOVLW 12
0015B0 636F       05668 	CPFSEQ x,1
0015B2 D010       05669 	BRA   m237
                  05670 			;							retardo_20u();retardo_20u();retardo_20u();retardo_20u();
0015B4 EC5E F003  05671 	CALL  retardo_20u
0015B8 EC5E F003  05672 	CALL  retardo_20u
0015BC EC5E F003  05673 	CALL  retardo_20u
0015C0 EC5E F003  05674 	CALL  retardo_20u
                  05675 			;							retardo_20u();retardo_20u();retardo_20u();retardo_20u();}
0015C4 EC5E F003  05676 	CALL  retardo_20u
0015C8 EC5E F003  05677 	CALL  retardo_20u
0015CC EC5E F003  05678 	CALL  retardo_20u
0015D0 EC5E F003  05679 	CALL  retardo_20u
                  05680 			;						}			
                  05681 			;						lectura=0;
0015D4 0100       05682 m237	MOVLB 0
0015D6 91A6       05683 	BCF   0xA6,lectura,1
                  05684 			;					}
0015D8 D798       05685 	BRA   m232
                  05686 			;				}
                  05687 			;				estado = CALCULOS_VAC;
0015DA 0E01       05688 m238	MOVLW 1
0015DC 0100       05689 	MOVLB 0
0015DE 6FD7       05690 	MOVWF estado,1
                  05691 			;				if(x<=15) estado = LECTURA_VAC;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 96

ADDR   CODE       LINE  SOURCE

0015E0 0E10       05692 	MOVLW 16
0015E2 616F       05693 	CPFSLT x,1
0015E4 D6FD       05694 	BRA   m223
0015E6 6BD7       05695 	CLRF  estado,1
                  05696 			;			break;
0015E8 D6FB       05697 	BRA   m223
                  05698 			;
                  05699 			;			case CALCULOS_VAC:
                  05700 			;
                  05701 			;				Mac0=0;
0015EA 0100       05702 m239	MOVLB 0
0015EC 6B9B       05703 	CLRF  Mac0,1
0015EE 6B9C       05704 	CLRF  Mac0+1,1
                  05705 			;				for(p=0;p<16;p++){
0015F0 6B6D       05706 	CLRF  p,1
0015F2 0E10       05707 m240	MOVLW 16
0015F4 0100       05708 	MOVLB 0
0015F6 616D       05709 	CPFSLT p,1
0015F8 D012       05710 	BRA   m241
                  05711 			;					ac=vac[p];
0015FA 6AEA       05712 	CLRF  FSR0+1,0
0015FC 0E70       05713 	MOVLW 112
0015FE 256D       05714 	ADDWF p,W,1
001600 6EE9       05715 	MOVWF FSR0,0
001602 CFEF F080  05716 	MOVFF INDF0,ac
                  05717 			;					uns16 d =(uns16)ac*ac;
001606 5180       05718 	MOVF  ac,W,1
001608 0380       05719 	MULWF ac,1
00160A CFF3 F0AC  05720 	MOVFF PRODL,d_6
00160E CFF4 F0AD  05721 	MOVFF PRODH,d_6+1
                  05722 			;					Mac0+=d;
001612 51AC       05723 	MOVF  d_6,W,1
001614 279B       05724 	ADDWF Mac0,1,1
001616 51AD       05725 	MOVF  d_6+1,W,1
001618 239C       05726 	ADDWFC Mac0+1,1,1
                  05727 			;				}
00161A 2B6D       05728 	INCF  p,1,1
00161C D7EA       05729 	BRA   m240
                  05730 			;				Mac1=Mac0;
00161E C09B F09D  05731 m241	MOVFF Mac0,Mac1
001622 C09C F09E  05732 	MOVFF Mac0+1,Mac1+1
                  05733 			;				Mac0/=p;
001626 C09B F0C4  05734 	MOVFF Mac0,arg1
00162A C09C F0C5  05735 	MOVFF Mac0+1,arg1+1
00162E 0100       05736 	MOVLB 0
001630 516D       05737 	MOVF  p,W,1
001632 EC52 F002  05738 	CALL  _divU16_8
001636 C0C4 F09B  05739 	MOVFF arg1,Mac0
00163A C0C5 F09C  05740 	MOVFF arg1+1,Mac0+1
                  05741 			;				raiz= sqrt (Mac0);
00163E C09B F0B0  05742 	MOVFF Mac0,arg1f24
001642 C09C F0B1  05743 	MOVFF Mac0+1,arg1f24+1
001646 0100       05744 	MOVLB 0
001648 6BB2       05745 	CLRF  arg1f24+2,1
00164A ECB8 F001  05746 	CALL  _int24ToFloat24
00164E ECB5 F002  05747 	CALL  sqrt
001652 C0B0 F095  05748 	MOVFF arg1f24,raiz
001656 C0B1 F096  05749 	MOVFF arg1f24+1,raiz+1
00165A C0B2 F097  05750 	MOVFF arg1f24+2,raiz+2
                  05751 			;				q = (uns16)raiz*10;
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 97

ADDR   CODE       LINE  SOURCE

00165E C095 F0B0  05752 	MOVFF raiz,arg1f24
001662 C096 F0B1  05753 	MOVFF raiz+1,arg1f24+1
001666 C097 F0B2  05754 	MOVFF raiz+2,arg1f24+2
00166A ECFD F001  05755 	CALL  _float24ToInt24
00166E 0E0A       05756 	MOVLW 10
001670 0100       05757 	MOVLB 0
001672 03B0       05758 	MULWF rval_3,1
001674 CFF3 F09F  05759 	MOVFF PRODL,q
001678 CFF4 F0A0  05760 	MOVFF PRODH,q+1
00167C 0E0A       05761 	MOVLW 10
00167E 03B1       05762 	MULWF rval_3+1,1
001680 50F3       05763 	MOVF  PRODL,W,0
001682 27A0       05764 	ADDWF q+1,1,1
                  05765 			;				float banda=51.6; //a 230 aqui tengo 53
001684 0E66       05766 	MOVLW 102
001686 6FA7       05767 	MOVWF banda,1
001688 0E4E       05768 	MOVLW 78
00168A 6FA8       05769 	MOVWF banda+1,1
00168C 0E84       05770 	MOVLW 132
00168E 6FA9       05771 	MOVWF banda+2,1
                  05772 			;				if(raiz<=REF_AC)raiz=REF_AC-raiz;
001690 BF96       05773 	BTFSC raiz+1,7,1
001692 D008       05774 	BRA   m242
001694 0E01       05775 	MOVLW 1
001696 5D95       05776 	SUBWF raiz,W,1
001698 0E14       05777 	MOVLW 20
00169A 5996       05778 	SUBWFB raiz+1,W,1
00169C 0E84       05779 	MOVLW 132
00169E 5997       05780 	SUBWFB raiz+2,W,1
0016A0 B0D8       05781 	BTFSC 0xFD8,Carry,0
0016A2 D015       05782 	BRA   m243
0016A4 0100       05783 m242	MOVLB 0
0016A6 6BB0       05784 	CLRF  arg1f24,1
0016A8 0E14       05785 	MOVLW 20
0016AA 6FB1       05786 	MOVWF arg1f24+1,1
0016AC 0E84       05787 	MOVLW 132
0016AE 6FB2       05788 	MOVWF arg1f24+2,1
0016B0 C095 F0B3  05789 	MOVFF raiz,arg2f24
0016B4 C096 F0B4  05790 	MOVFF raiz+1,arg2f24+1
0016B8 C097 F0B5  05791 	MOVFF raiz+2,arg2f24+2
0016BC ECB1 F001  05792 	CALL  _fsub24
0016C0 C0B0 F095  05793 	MOVFF arg1f24,raiz
0016C4 C0B1 F096  05794 	MOVFF arg1f24+1,raiz+1
0016C8 C0B2 F097  05795 	MOVFF arg1f24+2,raiz+2
                  05796 			;				else if(raiz>REF_AC)raiz=raiz-REF_AC;
0016CC D01E       05797 	BRA   m244
0016CE 0100       05798 m243	MOVLB 0
0016D0 BF96       05799 	BTFSC raiz+1,7,1
0016D2 D01B       05800 	BRA   m244
0016D4 0E01       05801 	MOVLW 1
0016D6 5D95       05802 	SUBWF raiz,W,1
0016D8 0E14       05803 	MOVLW 20
0016DA 5996       05804 	SUBWFB raiz+1,W,1
0016DC 0E84       05805 	MOVLW 132
0016DE 5997       05806 	SUBWFB raiz+2,W,1
0016E0 A0D8       05807 	BTFSS 0xFD8,Carry,0
0016E2 D013       05808 	BRA   m244
0016E4 C095 F0B0  05809 	MOVFF raiz,arg1f24
0016E8 C096 F0B1  05810 	MOVFF raiz+1,arg1f24+1
0016EC C097 F0B2  05811 	MOVFF raiz+2,arg1f24+2
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 98

ADDR   CODE       LINE  SOURCE

0016F0 6BB3       05812 	CLRF  arg2f24,1
0016F2 0E14       05813 	MOVLW 20
0016F4 6FB4       05814 	MOVWF arg2f24+1,1
0016F6 0E84       05815 	MOVLW 132
0016F8 6FB5       05816 	MOVWF arg2f24+2,1
0016FA ECB1 F001  05817 	CALL  _fsub24
0016FE C0B0 F095  05818 	MOVFF arg1f24,raiz
001702 C0B1 F096  05819 	MOVFF arg1f24+1,raiz+1
001706 C0B2 F097  05820 	MOVFF arg1f24+2,raiz+2
                  05821 			;
                  05822 			;				
                  05823 			;				a=(uns16)raiz; 		//la resta está mas o menos bien
00170A C095 F0B0  05824 m244	MOVFF raiz,arg1f24
00170E C096 F0B1  05825 	MOVFF raiz+1,arg1f24+1
001712 C097 F0B2  05826 	MOVFF raiz+2,arg1f24+2
001716 ECFD F001  05827 	CALL  _float24ToInt24
00171A C0B0 F0A1  05828 	MOVFF rval_3,a
00171E C0B1 F0A2  05829 	MOVFF rval_3+1,a+1
                  05830 			;				//if(raiz<=37.0){					
                  05831 			;					//ProbaVmax=(raiz/banda)*10.0;
                  05832 			;					ProbaVmax=raiz*0.3*100.0;
001722 C095 F0B0  05833 	MOVFF raiz,arg1f24
001726 C096 F0B1  05834 	MOVFF raiz+1,arg1f24+1
00172A C097 F0B2  05835 	MOVFF raiz+2,arg1f24+2
00172E 0E9A       05836 	MOVLW 154
001730 0100       05837 	MOVLB 0
001732 6FB3       05838 	MOVWF arg2f24,1
001734 0E19       05839 	MOVLW 25
001736 6FB4       05840 	MOVWF arg2f24+1,1
001738 0E7D       05841 	MOVLW 125
00173A 6FB5       05842 	MOVWF arg2f24+2,1
00173C ECA6 F000  05843 	CALL  _fmul24
001740 0100       05844 	MOVLB 0
001742 6BB3       05845 	CLRF  arg2f24,1
001744 0E48       05846 	MOVLW 72
001746 6FB4       05847 	MOVWF arg2f24+1,1
001748 0E85       05848 	MOVLW 133
00174A 6FB5       05849 	MOVWF arg2f24+2,1
00174C ECA6 F000  05850 	CALL  _fmul24
001750 C0B0 F0A3  05851 	MOVFF arg1f24,ProbaVmax
001754 C0B1 F0A4  05852 	MOVFF arg1f24+1,ProbaVmax+1
001758 C0B2 F0A5  05853 	MOVFF arg1f24+2,ProbaVmax+2
                  05854 			;					ProbaVmax*=0.6;
00175C C0A3 F0B0  05855 	MOVFF ProbaVmax,arg1f24
001760 C0A4 F0B1  05856 	MOVFF ProbaVmax+1,arg1f24+1
001764 C0A5 F0B2  05857 	MOVFF ProbaVmax+2,arg1f24+2
001768 0E9A       05858 	MOVLW 154
00176A 0100       05859 	MOVLB 0
00176C 6FB3       05860 	MOVWF arg2f24,1
00176E 0E19       05861 	MOVLW 25
001770 6FB4       05862 	MOVWF arg2f24+1,1
001772 0E7E       05863 	MOVLW 126
001774 6FB5       05864 	MOVWF arg2f24+2,1
001776 ECA6 F000  05865 	CALL  _fmul24
00177A C0B0 F0A3  05866 	MOVFF arg1f24,ProbaVmax
00177E C0B1 F0A4  05867 	MOVFF arg1f24+1,ProbaVmax+1
001782 C0B2 F0A5  05868 	MOVFF arg1f24+2,ProbaVmax+2
                  05869 			;
                  05870 			;					Vmax=ProbaVmax;
001786 C0A3 F0D0  05871 	MOVFF ProbaVmax,Vmax
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 99

ADDR   CODE       LINE  SOURCE

00178A C0A4 F0D1  05872 	MOVFF ProbaVmax+1,Vmax+1
00178E C0A5 F0D2  05873 	MOVFF ProbaVmax+2,Vmax+2
                  05874 			;				//}
                  05875 			;				
                  05876 			;				estado = ENVIO_LCD;// cambiar a CALCULOS_IAC para la version final!!!!
001792 0E04       05877 	MOVLW 4
001794 0100       05878 	MOVLB 0
001796 6FD7       05879 	MOVWF estado,1
                  05880 			;			
                  05881 			;				break;
001798 D623       05882 	BRA   m223
                  05883 			;
                  05884 			;			case CALCULOS_IAC:
                  05885 			;			
                  05886 			;				estado = LECTURAS_VARIAS;
00179A 0E03       05887 m245	MOVLW 3
00179C 0100       05888 	MOVLB 0
00179E 6FD7       05889 	MOVWF estado,1
                  05890 			;			break;
0017A0 D61F       05891 	BRA   m223
                  05892 			;																///11,5v-->700
                  05893 			;			case LECTURAS_VARIAS:								///11,8v-->728
                  05894 			;				uns16 bat = medir(LEO_BAT,10);				 	///12,0v-->730
0017A2 0E01       05895 m246	MOVLW 1
0017A4 0100       05896 	MOVLB 0
0017A6 6FAC       05897 	MOVWF canal,1
0017A8 0E0A       05898 	MOVLW 10
0017AA DD34       05899 	RCALL medir
0017AC C0AE F0AA  05900 	MOVFF resultado,bat
0017B0 C0AF F0AB  05901 	MOVFF resultado+1,bat+1
                  05902 			;				if (bat>785)				vbat=BATT_FULL;  	///12,3v-->763
0017B4 0E12       05903 	MOVLW 18
0017B6 0100       05904 	MOVLB 0
0017B8 5DAA       05905 	SUBWF bat,W,1
0017BA 0E03       05906 	MOVLW 3
0017BC 59AB       05907 	SUBWFB bat+1,W,1
0017BE A0D8       05908 	BTFSS 0xFD8,Carry,0
0017C0 D003       05909 	BRA   m247
0017C2 0E01       05910 	MOVLW 1
0017C4 6F92       05911 	MOVWF vbat,1
                  05912 			;				else if((bat>762&&bat<775))	vbat=BATT_75;		///12,5v-->774
0017C6 D058       05913 	BRA   m254
0017C8 0EFB       05914 m247	MOVLW 251
0017CA 0100       05915 	MOVLB 0
0017CC 5DAA       05916 	SUBWF bat,W,1
0017CE 0E02       05917 	MOVLW 2
0017D0 59AB       05918 	SUBWFB bat+1,W,1
0017D2 A0D8       05919 	BTFSS 0xFD8,Carry,0
0017D4 D009       05920 	BRA   m248
0017D6 0E07       05921 	MOVLW 7
0017D8 5DAA       05922 	SUBWF bat,W,1
0017DA 0E03       05923 	MOVLW 3
0017DC 59AB       05924 	SUBWFB bat+1,W,1
0017DE B0D8       05925 	BTFSC 0xFD8,Carry,0
0017E0 D003       05926 	BRA   m248
0017E2 0E02       05927 	MOVLW 2
0017E4 6F92       05928 	MOVWF vbat,1
                  05929 			;				else if((bat>742&&bat<760)) vbat=BATT_50;		///12,8v-->794
0017E6 D048       05930 	BRA   m254
0017E8 0EE7       05931 m248	MOVLW 231
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 100

ADDR   CODE       LINE  SOURCE

0017EA 0100       05932 	MOVLB 0
0017EC 5DAA       05933 	SUBWF bat,W,1
0017EE 0E02       05934 	MOVLW 2
0017F0 59AB       05935 	SUBWFB bat+1,W,1
0017F2 A0D8       05936 	BTFSS 0xFD8,Carry,0
0017F4 D009       05937 	BRA   m249
0017F6 0EF8       05938 	MOVLW 248
0017F8 5DAA       05939 	SUBWF bat,W,1
0017FA 0E02       05940 	MOVLW 2
0017FC 59AB       05941 	SUBWFB bat+1,W,1
0017FE B0D8       05942 	BTFSC 0xFD8,Carry,0
001800 D003       05943 	BRA   m249
001802 0E03       05944 	MOVLW 3
001804 6F92       05945 	MOVWF vbat,1
                  05946 			;				else if((bat>722&&bat<740)) vbat=BATT_25;		///13,0v-->804
001806 D038       05947 	BRA   m254
001808 0ED3       05948 m249	MOVLW 211
00180A 0100       05949 	MOVLB 0
00180C 5DAA       05950 	SUBWF bat,W,1
00180E 0E02       05951 	MOVLW 2
001810 59AB       05952 	SUBWFB bat+1,W,1
001812 A0D8       05953 	BTFSS 0xFD8,Carry,0
001814 D009       05954 	BRA   m250
001816 0EE4       05955 	MOVLW 228
001818 5DAA       05956 	SUBWF bat,W,1
00181A 0E02       05957 	MOVLW 2
00181C 59AB       05958 	SUBWFB bat+1,W,1
00181E B0D8       05959 	BTFSC 0xFD8,Carry,0
001820 D003       05960 	BRA   m250
001822 0E04       05961 	MOVLW 4
001824 6F92       05962 	MOVWF vbat,1
                  05963 			;				else if((bat>710&&bat<720)) vbat=BATT_10;		///13,5v-->837
001826 D028       05964 	BRA   m254
001828 0EC7       05965 m250	MOVLW 199
00182A 0100       05966 	MOVLB 0
00182C 5DAA       05967 	SUBWF bat,W,1
00182E 0E02       05968 	MOVLW 2
001830 59AB       05969 	SUBWFB bat+1,W,1
001832 A0D8       05970 	BTFSS 0xFD8,Carry,0
001834 D009       05971 	BRA   m251
001836 0ED0       05972 	MOVLW 208
001838 5DAA       05973 	SUBWF bat,W,1
00183A 0E02       05974 	MOVLW 2
00183C 59AB       05975 	SUBWFB bat+1,W,1
00183E B0D8       05976 	BTFSC 0xFD8,Carry,0
001840 D003       05977 	BRA   m251
001842 0E05       05978 	MOVLW 5
001844 6F92       05979 	MOVWF vbat,1
                  05980 			;				else if(bat<=708){								///14,0v-->872
001846 D018       05981 	BRA   m254
001848 0EC5       05982 m251	MOVLW 197
00184A 0100       05983 	MOVLB 0
00184C 5DAA       05984 	SUBWF bat,W,1
00184E 0E02       05985 	MOVLW 2
001850 59AB       05986 	SUBWFB bat+1,W,1
001852 B0D8       05987 	BTFSC 0xFD8,Carry,0
001854 D011       05988 	BRA   m254
                  05989 			;					o++;										///14,5v-->895
001856 2B93       05990 	INCF  o,1,1
                  05991 			;					if(o<=5)vbat=BATT_LW;						///15,0v-->946
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 101

ADDR   CODE       LINE  SOURCE

001858 0E06       05992 	MOVLW 6
00185A 6193       05993 	CPFSLT o,1
00185C D002       05994 	BRA   m252
00185E 0E06       05995 	MOVLW 6
001860 6F92       05996 	MOVWF vbat,1
                  05997 			;					if(o>6)vbat=BATT_CLEAR;
001862 0E06       05998 m252	MOVLW 6
001864 0100       05999 	MOVLB 0
001866 6593       06000 	CPFSGT o,1
001868 D002       06001 	BRA   m253
00186A 0E07       06002 	MOVLW 7
00186C 6F92       06003 	MOVWF vbat,1
                  06004 			;					if(o==10)o=0;
00186E 0E0A       06005 m253	MOVLW 10
001870 0100       06006 	MOVLB 0
001872 6393       06007 	CPFSEQ o,1
001874 D001       06008 	BRA   m254
001876 6B93       06009 	CLRF  o,1
                  06010 			;				} 			
                  06011 			;				estado= ENVIO_LCD;
001878 0E04       06012 m254	MOVLW 4
00187A 0100       06013 	MOVLB 0
00187C 6FD7       06014 	MOVWF estado,1
                  06015 			;			break;
00187E D5B0       06016 	BRA   m223
                  06017 			;
                  06018 			;			case ENVIO_LCD:
                  06019 			;				//puesto así para tener más velocidad en el bucle principal!!
                  06020 			;				switch (vuelta){
001880 0100       06021 m255	MOVLB 0
001882 5194       06022 	MOVF  vuelta,W,1
001884 B4D8       06023 	BTFSC 0xFD8,Zero_,0
001886 D034       06024 	BRA   m256
001888 0A01       06025 	XORLW 1
00188A B4D8       06026 	BTFSC 0xFD8,Zero_,0
00188C D049       06027 	BRA   m257
00188E 0A03       06028 	XORLW 3
001890 B4D8       06029 	BTFSC 0xFD8,Zero_,0
001892 D0F5       06030 	BRA   m273
001894 0A01       06031 	XORLW 1
001896 B4D8       06032 	BTFSC 0xFD8,Zero_,0
001898 D04F       06033 	BRA   m258
00189A 0A07       06034 	XORLW 7
00189C B4D8       06035 	BTFSC 0xFD8,Zero_,0
00189E D055       06036 	BRA   m259
0018A0 0A01       06037 	XORLW 1
0018A2 B4D8       06038 	BTFSC 0xFD8,Zero_,0
0018A4 D05B       06039 	BRA   m260
0018A6 0A03       06040 	XORLW 3
0018A8 B4D8       06041 	BTFSC 0xFD8,Zero_,0
0018AA D061       06042 	BRA   m261
0018AC 0A01       06043 	XORLW 1
0018AE B4D8       06044 	BTFSC 0xFD8,Zero_,0
0018B0 D067       06045 	BRA   m262
0018B2 0A0F       06046 	XORLW 15
0018B4 B4D8       06047 	BTFSC 0xFD8,Zero_,0
0018B6 D06D       06048 	BRA   m263
0018B8 0A01       06049 	XORLW 1
0018BA B4D8       06050 	BTFSC 0xFD8,Zero_,0
0018BC D073       06051 	BRA   m264
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 102

ADDR   CODE       LINE  SOURCE

0018BE 0A03       06052 	XORLW 3
0018C0 B4D8       06053 	BTFSC 0xFD8,Zero_,0
0018C2 D079       06054 	BRA   m265
0018C4 0A01       06055 	XORLW 1
0018C6 B4D8       06056 	BTFSC 0xFD8,Zero_,0
0018C8 D07F       06057 	BRA   m266
0018CA 0A07       06058 	XORLW 7
0018CC B4D8       06059 	BTFSC 0xFD8,Zero_,0
0018CE D085       06060 	BRA   m267
0018D0 0A01       06061 	XORLW 1
0018D2 B4D8       06062 	BTFSC 0xFD8,Zero_,0
0018D4 D08B       06063 	BRA   m268
0018D6 0A03       06064 	XORLW 3
0018D8 B4D8       06065 	BTFSC 0xFD8,Zero_,0
0018DA D091       06066 	BRA   m269
0018DC 0A01       06067 	XORLW 1
0018DE B4D8       06068 	BTFSC 0xFD8,Zero_,0
0018E0 D097       06069 	BRA   m270
0018E2 0A1F       06070 	XORLW 31
0018E4 B4D8       06071 	BTFSC 0xFD8,Zero_,0
0018E6 D0B4       06072 	BRA   m271
0018E8 0A01       06073 	XORLW 1
0018EA B4D8       06074 	BTFSC 0xFD8,Zero_,0
0018EC D0BD       06075 	BRA   m272
0018EE D0C7       06076 	BRA   m273
                  06077 			;					case 0:
                  06078 			;						uns16 w =(uns16)banda;
0018F0 C0A7 F0B0  06079 m256	MOVFF banda,arg1f24
0018F4 C0A8 F0B1  06080 	MOVFF banda+1,arg1f24+1
0018F8 C0A9 F0B2  06081 	MOVFF banda+2,arg1f24+2
0018FC ECFD F001  06082 	CALL  _float24ToInt24
001900 C0B0 F0AC  06083 	MOVFF rval_3,w
001904 C0B1 F0AD  06084 	MOVFF rval_3+1,w+1
                  06085 			;						Enviar_uns16(2,1,w);
001908 0E02       06086 	MOVLW 2
00190A 0100       06087 	MOVLB 0
00190C 6FB0       06088 	MOVWF linea_4,1
00190E 0E01       06089 	MOVLW 1
001910 6FB1       06090 	MOVWF columna_3,1
001912 C0AC F0B2  06091 	MOVFF w,dato_4
001916 C0AD F0B3  06092 	MOVFF w+1,dato_4+1
00191A EC59 F006  06093 	CALL  Enviar_uns16
                  06094 			;					break;
00191E D0AF       06095 	BRA   m273
                  06096 			;					case 1:
                  06097 			;						Enviar_uns16(2,7,a);
001920 0E02       06098 m257	MOVLW 2
001922 0100       06099 	MOVLB 0
001924 6FB0       06100 	MOVWF linea_4,1
001926 0E07       06101 	MOVLW 7
001928 6FB1       06102 	MOVWF columna_3,1
00192A C0A1 F0B2  06103 	MOVFF a,dato_4
00192E C0A2 F0B3  06104 	MOVFF a+1,dato_4+1
001932 EC59 F006  06105 	CALL  Enviar_uns16
                  06106 			;					break;
001936 D0A3       06107 	BRA   m273
                  06108 			;					case 2:
                  06109 			;
                  06110 			;					break;
                  06111 			;					case 3:
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 103

ADDR   CODE       LINE  SOURCE

                  06112 			;						Enviar_char(2,13,vac[3]);
001938 0E02       06113 m258	MOVLW 2
00193A 0100       06114 	MOVLB 0
00193C 6FB0       06115 	MOVWF linea_5,1
00193E 0E0D       06116 	MOVLW 13
001940 6FB1       06117 	MOVWF columna_4,1
001942 5173       06118 	MOVF  vac+3,W,1
001944 EC99 F007  06119 	CALL  Enviar_char
                  06120 			;					break;
001948 D09A       06121 	BRA   m273
                  06122 			;					case 4:
                  06123 			;						Enviar_char(2,17,vac[4]);
00194A 0E02       06124 m259	MOVLW 2
00194C 0100       06125 	MOVLB 0
00194E 6FB0       06126 	MOVWF linea_5,1
001950 0E11       06127 	MOVLW 17
001952 6FB1       06128 	MOVWF columna_4,1
001954 5174       06129 	MOVF  vac+4,W,1
001956 EC99 F007  06130 	CALL  Enviar_char
                  06131 			;					break;
00195A D091       06132 	BRA   m273
                  06133 			;					case 5:
                  06134 			;						Enviar_char(3,1,vac[5]);
00195C 0E03       06135 m260	MOVLW 3
00195E 0100       06136 	MOVLB 0
001960 6FB0       06137 	MOVWF linea_5,1
001962 0E01       06138 	MOVLW 1
001964 6FB1       06139 	MOVWF columna_4,1
001966 5175       06140 	MOVF  vac+5,W,1
001968 EC99 F007  06141 	CALL  Enviar_char
                  06142 			;					break;
00196C D088       06143 	BRA   m273
                  06144 			;					case 6:
                  06145 			;						Enviar_char(3,5,vac[6]);
00196E 0E03       06146 m261	MOVLW 3
001970 0100       06147 	MOVLB 0
001972 6FB0       06148 	MOVWF linea_5,1
001974 0E05       06149 	MOVLW 5
001976 6FB1       06150 	MOVWF columna_4,1
001978 5176       06151 	MOVF  vac+6,W,1
00197A EC99 F007  06152 	CALL  Enviar_char
                  06153 			;					break;
00197E D07F       06154 	BRA   m273
                  06155 			;					case 7:
                  06156 			;						Enviar_char(3,9,vac[7]);
001980 0E03       06157 m262	MOVLW 3
001982 0100       06158 	MOVLB 0
001984 6FB0       06159 	MOVWF linea_5,1
001986 0E09       06160 	MOVLW 9
001988 6FB1       06161 	MOVWF columna_4,1
00198A 5177       06162 	MOVF  vac+7,W,1
00198C EC99 F007  06163 	CALL  Enviar_char
                  06164 			;					break;
001990 D076       06165 	BRA   m273
                  06166 			;					case 8:
                  06167 			;						Enviar_char(3,13,vac[8]);
001992 0E03       06168 m263	MOVLW 3
001994 0100       06169 	MOVLB 0
001996 6FB0       06170 	MOVWF linea_5,1
001998 0E0D       06171 	MOVLW 13
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 104

ADDR   CODE       LINE  SOURCE

00199A 6FB1       06172 	MOVWF columna_4,1
00199C 5178       06173 	MOVF  vac+8,W,1
00199E EC99 F007  06174 	CALL  Enviar_char
                  06175 			;					break;
0019A2 D06D       06176 	BRA   m273
                  06177 			;					case 9:
                  06178 			;						Enviar_char(3,17,vac[9]);
0019A4 0E03       06179 m264	MOVLW 3
0019A6 0100       06180 	MOVLB 0
0019A8 6FB0       06181 	MOVWF linea_5,1
0019AA 0E11       06182 	MOVLW 17
0019AC 6FB1       06183 	MOVWF columna_4,1
0019AE 5179       06184 	MOVF  vac+9,W,1
0019B0 EC99 F007  06185 	CALL  Enviar_char
                  06186 			;					break;
0019B4 D064       06187 	BRA   m273
                  06188 			;					case 10:
                  06189 			;						Enviar_char(4,1,vac[10]);
0019B6 0E04       06190 m265	MOVLW 4
0019B8 0100       06191 	MOVLB 0
0019BA 6FB0       06192 	MOVWF linea_5,1
0019BC 0E01       06193 	MOVLW 1
0019BE 6FB1       06194 	MOVWF columna_4,1
0019C0 517A       06195 	MOVF  vac+10,W,1
0019C2 EC99 F007  06196 	CALL  Enviar_char
                  06197 			;					break;
0019C6 D05B       06198 	BRA   m273
                  06199 			;					case 11:
                  06200 			;						Enviar_char(4,5,vac[11]);
0019C8 0E04       06201 m266	MOVLW 4
0019CA 0100       06202 	MOVLB 0
0019CC 6FB0       06203 	MOVWF linea_5,1
0019CE 0E05       06204 	MOVLW 5
0019D0 6FB1       06205 	MOVWF columna_4,1
0019D2 517B       06206 	MOVF  vac+11,W,1
0019D4 EC99 F007  06207 	CALL  Enviar_char
                  06208 			;					break;
0019D8 D052       06209 	BRA   m273
                  06210 			;					case 12:
                  06211 			;						Enviar_char(4,9,vac[12]);
0019DA 0E04       06212 m267	MOVLW 4
0019DC 0100       06213 	MOVLB 0
0019DE 6FB0       06214 	MOVWF linea_5,1
0019E0 0E09       06215 	MOVLW 9
0019E2 6FB1       06216 	MOVWF columna_4,1
0019E4 517C       06217 	MOVF  vac+12,W,1
0019E6 EC99 F007  06218 	CALL  Enviar_char
                  06219 			;					break;
0019EA D049       06220 	BRA   m273
                  06221 			;					case 13:
                  06222 			;						Enviar_char(4,13,vac[13]);
0019EC 0E04       06223 m268	MOVLW 4
0019EE 0100       06224 	MOVLB 0
0019F0 6FB0       06225 	MOVWF linea_5,1
0019F2 0E0D       06226 	MOVLW 13
0019F4 6FB1       06227 	MOVWF columna_4,1
0019F6 517D       06228 	MOVF  vac+13,W,1
0019F8 EC99 F007  06229 	CALL  Enviar_char
                  06230 			;					break;
0019FC D040       06231 	BRA   m273
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 105

ADDR   CODE       LINE  SOURCE

                  06232 			;					case 14:
                  06233 			;						Enviar_char(4,17,vac[14]);
0019FE 0E04       06234 m269	MOVLW 4
001A00 0100       06235 	MOVLB 0
001A02 6FB0       06236 	MOVWF linea_5,1
001A04 0E11       06237 	MOVLW 17
001A06 6FB1       06238 	MOVWF columna_4,1
001A08 517E       06239 	MOVF  vac+14,W,1
001A0A EC99 F007  06240 	CALL  Enviar_char
                  06241 			;					break;
001A0E D037       06242 	BRA   m273
                  06243 			;					case 15:
                  06244 			;						uns16  v= (uns16)ProbaVmax;
001A10 C0A3 F0B0  06245 m270	MOVFF ProbaVmax,arg1f24
001A14 C0A4 F0B1  06246 	MOVFF ProbaVmax+1,arg1f24+1
001A18 C0A5 F0B2  06247 	MOVFF ProbaVmax+2,arg1f24+2
001A1C ECFD F001  06248 	CALL  _float24ToInt24
001A20 C0B0 F0AE  06249 	MOVFF rval_3,v
001A24 C0B1 F0AF  06250 	MOVFF rval_3+1,v+1
                  06251 			;						Enviar_uns16(1,1,v);
001A28 0E01       06252 	MOVLW 1
001A2A 0100       06253 	MOVLB 0
001A2C 6FB0       06254 	MOVWF linea_4,1
001A2E 0E01       06255 	MOVLW 1
001A30 6FB1       06256 	MOVWF columna_3,1
001A32 C0AE F0B2  06257 	MOVFF v,dato_4
001A36 C0AF F0B3  06258 	MOVFF v+1,dato_4+1
001A3A EC59 F006  06259 	CALL  Enviar_uns16
                  06260 			;						Enviar_char(1,12,r);
001A3E 0E01       06261 	MOVLW 1
001A40 0100       06262 	MOVLB 0
001A42 6FB0       06263 	MOVWF linea_5,1
001A44 0E0C       06264 	MOVLW 12
001A46 6FB1       06265 	MOVWF columna_4,1
001A48 51CE       06266 	MOVF  r,W,1
001A4A EC99 F007  06267 	CALL  Enviar_char
                  06268 			;					break;
001A4E D017       06269 	BRA   m273
                  06270 			;					case 16:
                  06271 			;						 
                  06272 			;						Enviar_uns16(1,16, q);
001A50 0E01       06273 m271	MOVLW 1
001A52 0100       06274 	MOVLB 0
001A54 6FB0       06275 	MOVWF linea_4,1
001A56 0E10       06276 	MOVLW 16
001A58 6FB1       06277 	MOVWF columna_3,1
001A5A C09F F0B2  06278 	MOVFF q,dato_4
001A5E C0A0 F0B3  06279 	MOVFF q+1,dato_4+1
001A62 EC59 F006  06280 	CALL  Enviar_uns16
                  06281 			;					break;
001A66 D00B       06282 	BRA   m273
                  06283 			;					case 17:
                  06284 			;						Enviar_uns16(1,7,Mac1);
001A68 0E01       06285 m272	MOVLW 1
001A6A 0100       06286 	MOVLB 0
001A6C 6FB0       06287 	MOVWF linea_4,1
001A6E 0E07       06288 	MOVLW 7
001A70 6FB1       06289 	MOVWF columna_3,1
001A72 C09D F0B2  06290 	MOVFF Mac1,dato_4
001A76 C09E F0B3  06291 	MOVFF Mac1+1,dato_4+1
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 106

ADDR   CODE       LINE  SOURCE

001A7A EC59 F006  06292 	CALL  Enviar_uns16
                  06293 			;					break;
                  06294 			;				}
                  06295 			;				vuelta++;
001A7E 0100       06296 m273	MOVLB 0
001A80 2B94       06297 	INCF  vuelta,1,1
                  06298 			;				if(vuelta==18)vuelta=0;
001A82 0E12       06299 	MOVLW 18
001A84 6394       06300 	CPFSEQ vuelta,1
001A86 D001       06301 	BRA   m274
001A88 6B94       06302 	CLRF  vuelta,1
                  06303 			;				estado = LECTURA_VAC;
001A8A 0100       06304 m274	MOVLB 0
001A8C 6BD7       06305 	CLRF  estado,1
                  06306 			;			break;
001A8E D4A8       06307 	BRA   m223
                  06308 			;
                  06309 			;		}
                  06310 			;	}	
                  06311 			;}
                  06312 			;
                  06313 			;
                  06314 			; //**************************************************************************************//
                  06315 			; //************************ F U N C I O N E S    V A R I A S ****************************//
                  06316 			; //**************************************************************************************//
                  06317 			;			
                  06318 			;void configuraPic (void)					
                  06319 			;{
                  06320 configuraPic
                  06321 			;	GIE = 0;						// Desactivamos inicialmente todas las interrupciones.
001A90 9EF2       06322 	BCF   0xFF2,GIE,0
                  06323 			;
                  06324 			;	OSCTUNE=0b.01.000000; //PLL enable 
001A92 0E40       06325 	MOVLW 64
001A94 6E9B       06326 	MOVWF OSCTUNE,0
                  06327 			;	
                  06328 			;	RCON = 0b.01111111; //C18 pag 80 i 167  Causes del RESET i IPEN (priority Enabled o no)
001A96 0E7F       06329 	MOVLW 127
001A98 6ED0       06330 	MOVWF RCON,0
                  06331 			;	OSCCON    = 0b.0.111.0.0.00;//C18 pag 53  //=============== ULL b3 abans 0 
001A9A 0E70       06332 	MOVLW 112
001A9C 6ED3       06333 	MOVWF OSCCON,0
                  06334 			;	
                  06335 			;	ANSEL  = 0b.0000.0111;					// Solo el canal AN0 será entrada analógica, el resto serán entradas/salidas digitales.(PIC 8
                           16F87)
001A9E 0E07       06336 	MOVLW 7
001AA0 6E7E       06337 	MOVWF ANSEL,0
                  06338 			;	//ANSELH = 0b.0000.0000;				// Solo el canal AN0 será entrada analógica, el resto serán entradas/salidas digitales.(PIC 8
                           16F87)
                  06339 			;	
                  06340 			;	TRISA  = 0b.0000.1111;					// PORTA.0 es entrada, el resto son salidas.
001AA2 0E0F       06341 	MOVLW 15
001AA4 6E92       06342 	MOVWF TRISA,0
                  06343 			;	TRISB  = 0b.0000.0000;					// PORTB todo salidas.
001AA6 6A93       06344 	CLRF  TRISB,0
                  06345 			;	TRISC  = 0b.0000.0000;					// PORTC todo salidas además de la salida del PWM.
001AA8 6A94       06346 	CLRF  TRISC,0
                  06347 			;	TRISD  = 0b.0000.0000;					// PORTD todo salidas.				
001AAA 6A95       06348 	CLRF  TRISD,0
                  06349 			;	LATB  = 0x00;							// Inicializa las salidas de PORTB a 0.
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 107

ADDR   CODE       LINE  SOURCE

001AAC 6A8A       06350 	CLRF  LATB,0
                  06351 			;	PORTC  = 0x00;							// Inicializa las salidas de PORTC a 0.
001AAE 6A82       06352 	CLRF  PORTC,0
                  06353 			;	PORTD  = 0x00;							// Inicializa las salidas de PORTD a 0.
001AB0 6A83       06354 	CLRF  PORTD,0
                  06355 			;
                  06356 			;	//configuro ccp y pwm
                  06357 			;
                  06358 			;
                  06359 			;	T2CON   = 0b.0.0001.0.01;				// Prescaler P1 = 4, TMR2ON = 1 cuenta;	
001AB2 0E09       06360 	MOVLW 9
001AB4 6ECA       06361 	MOVWF T2CON,0
                  06362 			;	PR2     = 199;
001AB6 0EC7       06363 	MOVLW 199
001AB8 6ECB       06364 	MOVWF PR2,0
                  06365 			;	CCP1CON = 0b.1000.1100;					// CCP1: modo PWM half bridge con bits de CCPR1L a 00 inicialmente.
001ABA 0E8C       06366 	MOVLW 140
001ABC 6EBD       06367 	MOVWF CCP1CON,0
                  06368 			;
                  06369 			;	PWM1CON =0b.0000.0100; //tiempo muerto entre P1A y P1B
001ABE 0E04       06370 	MOVLW 4
001AC0 6EB7       06371 	MOVWF PWM1CON,0
001AC2 0012       06372 	RETURN
                  06373 _const1
001AC4 0100       06374 	MOVLB 0
001AC6 6F69       06375 	MOVWF ci,1
001AC8 5169       06376 	MOVF  ci,W,1
001ACA 0FDC       06377 	ADDLW 220
001ACC 6EF6       06378 	MOVWF TBLPTR,0
001ACE 0E1A       06379 	MOVLW 26
001AD0 6AF7       06380 	CLRF  TBLPTR+1,0
001AD2 22F7       06381 	ADDWFC TBLPTR+1,1,0
001AD4 6AF8       06382 	CLRF  TBLPTR+2,0
001AD6 0008       06383 	TBLRD *
001AD8 50F5       06384 	MOVF  TABLAT,W,0
001ADA 0012       06385 	RETURN
001ADC 0800       06386 	DW    0x800
001ADE 1710       06387 	DW    0x1710
001AE0 271F       06388 	DW    0x271F
001AE2 362F       06389 	DW    0x362F
001AE4 443D       06390 	DW    0x443D
001AE6 514B       06391 	DW    0x514B
001AE8 5D57       06392 	DW    0x5D57
001AEA 6762       06393 	DW    0x6762
001AEC 706C       06394 	DW    0x706C
001AEE 7773       06395 	DW    0x7773
001AF0 7B79       06396 	DW    0x7B79
001AF2 7E7D       06397 	DW    0x7E7D
001AF4 807F       06398 	DW    0x807F
001AF6 100C       06399 	DW    0x100C
001AF8 0408       06400 	DW    0x408
001AFA 041B       06401 	DW    0x41B
001AFC 0304       06402 	DW    0x304
001AFE FFEE       06403 	DW    0xFFEE
001B00 FFFF       06404 	DW    0xFFFF
001B02 FFFF       06405 	DW    0xFFFF
001B04 FFFF       06406 	DW    0xFFFF
001B06 FFEE       06407 	DW    0xFFEE
001B08 FFF1       06408 	DW    0xFFF1
001B0A FFFF       06409 	DW    0xFFFF
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 108

ADDR   CODE       LINE  SOURCE

001B0C FFFF       06410 	DW    0xFFFF
001B0E FFEE       06411 	DW    0xFFEE
001B10 F1F1       06412 	DW    0xF1F1
001B12 FFFF       06413 	DW    0xFFFF
001B14 FFFF       06414 	DW    0xFFFF
001B16 FFEE       06415 	DW    0xFFEE
001B18 F1F1       06416 	DW    0xF1F1
001B1A FFF1       06417 	DW    0xFFF1
001B1C FFFF       06418 	DW    0xFFFF
001B1E FFEE       06419 	DW    0xFFEE
001B20 F1F1       06420 	DW    0xF1F1
001B22 F1F1       06421 	DW    0xF1F1
001B24 FFFF       06422 	DW    0xFFFF
001B26 FFEE       06423 	DW    0xFFEE
001B28 F1F1       06424 	DW    0xF1F1
001B2A F1F1       06425 	DW    0xF1F1
001B2C FFF1       06426 	DW    0xFFF1
001B2E 0000       06427 	DW    0x0
001B30 0000       06428 	DW    0x0
001B32 0000       06429 	DW    0x0
001B34 0000       06430 	DW    0x0
                  06431 
                  06432 	END
                  06433 
                  06434 
                  06435 ; *** KEY INFO ***
                  06436 
                  06437 ; 0x000008  162 word(s)  1 % : highPriorityTimer_0
                  06438 ; 0x001AC4   57 word(s)  0 % : _const1
                  06439 ; 0x00014C  100 word(s)  1 % : _fmul24
                  06440 ; 0x000214  167 word(s)  2 % : _fadd24
                  06441 ; 0x000362    7 word(s)  0 % : _fsub24
                  06442 ; 0x000370   69 word(s)  0 % : _int24ToFloat24
                  06443 ; 0x0003FA   85 word(s)  1 % : _float24ToInt24
                  06444 ; 0x0004A4   24 word(s)  0 % : _divU16_8
                  06445 ; 0x0004D4   27 word(s)  0 % : _divU16_16
                  06446 ; 0x00050A   23 word(s)  0 % : _remU16_8
                  06447 ; 0x000538   25 word(s)  0 % : _remU16_16
                  06448 ; 0x00056A  169 word(s)  2 % : sqrt
                  06449 ; 0x0006BC   10 word(s)  0 % : retardo_20u
                  06450 ; 0x0006D0   19 word(s)  0 % : retardo_1m
                  06451 ; 0x0006F6   20 word(s)  0 % : retardo_50m
                  06452 ; 0x00071E   18 word(s)  0 % : retardo_100m
                  06453 ; 0x000742   20 word(s)  0 % : retardo_500m
                  06454 ; 0x00076A   28 word(s)  0 % : envia_codigo_inicial
                  06455 ; 0x0007A2   59 word(s)  0 % : enviar_comando
                  06456 ; 0x000818   79 word(s)  0 % : enviar_literal
                  06457 ; 0x0008B6   72 word(s)  0 % : enviar_cifra
                  06458 ; 0x000946   59 word(s)  0 % : inicializar_lcd
                  06459 ; 0x0009BC   39 word(s)  0 % : escribir_posicion
                  06460 ; 0x000A0A   37 word(s)  0 % : borrar_linea
                  06461 ; 0x000A54    2 word(s)  0 % : borrar_lcd
                  06462 ; 0x000A58  301 word(s)  3 % : Enviar_lcd
                  06463 ; 0x000CB2  320 word(s)  3 % : Enviar_uns16
                  06464 ; 0x000F32  209 word(s)  2 % : Enviar_char
                  06465 ; 0x0010D4  160 word(s)  1 % : RAM_LCD
                  06466 ; 0x001214  113 word(s)  1 % : medir
                  06467 ; 0x001A90   26 word(s)  0 % : configuraPic
                  06468 ; 0x0012F6  973 word(s) 11 % : main
                  06469 
CC8E Version 1.4,   File: ondulador_float.c   21. May 2015  17:38   Page 109

ADDR   CODE       LINE  SOURCE

                  06470 ; RAM usage: 121 bytes (107 local), 647 bytes free
                  06471 ; Maximum call level: 3 (+2 for interrupt)
                  06472 ; Total of 3481 code words (42 %)
