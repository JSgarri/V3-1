CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 1

ADDR   CODE       LINE  SOURCE

                  00001 
                  00002 ; CC8E Version 1.4, Copyright (c) B Knudsen Data
                  00003 ; C compiler for the PIC18 microcontrollers
                  00004 ; ************  21. Apr 2015  15:08  *************
                  00005 
                  00006 	processor  PIC18F44K20
                  00007 	radix  DEC
                  00008 
300000 08FF       00009 	__config 0x300001, 0x8
                  00010 	__config 0x300002, 0x1
300002 1601       00011 	__config 0x300003, 0x16
300004 88FF       00012 	__config 0x300005, 0x88
300006 FF85       00013 	__config 0x300006, 0x85
                  00014 
       0FF6       00015 TBLPTR      EQU   0xFF6
       0FF5       00016 TABLAT      EQU   0xFF5
       0FF4       00017 PRODH       EQU   0xFF4
       0FF3       00018 PRODL       EQU   0xFF3
       0FF2       00019 INTCON      EQU   0xFF2
       0FF1       00020 INTCON2     EQU   0xFF1
       0FE0       00021 BSR         EQU   0xFE0
       0FD8       00022 STATUS      EQU   0xFD8
       0000       00023 Carry       EQU   0
       0002       00024 Zero_       EQU   2
       0FD5       00025 T0CON       EQU   0xFD5
       0FD3       00026 OSCCON      EQU   0xFD3
       0FD0       00027 RCON        EQU   0xFD0
       0FCB       00028 PR2         EQU   0xFCB
       0FCA       00029 T2CON       EQU   0xFCA
       0FC4       00030 ADRESH      EQU   0xFC4
       0FC2       00031 ADCON0      EQU   0xFC2
       0FC1       00032 ADCON1      EQU   0xFC1
       0FBE       00033 CCPR1L      EQU   0xFBE
       0FBD       00034 CCP1CON     EQU   0xFBD
       0FB7       00035 PWM1CON     EQU   0xFB7
       0F9B       00036 OSCTUNE     EQU   0xF9B
       0F95       00037 TRISD       EQU   0xF95
       0F94       00038 TRISC       EQU   0xF94
       0F93       00039 TRISB       EQU   0xF93
       0F92       00040 TRISA       EQU   0xF92
       0F8C       00041 LATD        EQU   0xF8C
       0F8B       00042 LATC        EQU   0xF8B
       0F83       00043 PORTD       EQU   0xF83
       0F82       00044 PORTC       EQU   0xF82
       0F81       00045 PORTB       EQU   0xF81
       0002       00046 TMR0IF      EQU   2
       0007       00047 GIE         EQU   7
       0002       00048 TMR2ON      EQU   2
       0001       00049 GO          EQU   1
       0001       00050 TMR2IF      EQU   1
       0001       00051 TMR2IE      EQU   1
       0000       00052 bUdw        EQU   0
       0072       00053 ancho_pwm   EQU   0x72
       0074       00054 Vmax        EQU   0x74
       0076       00055 SENO        EQU   0x76
       0077       00056 T           EQU   0x77
       0078       00057 i           EQU   0x78
       0060       00058 svrSTATUS   EQU   0x60
       0061       00059 svrBSR      EQU   0x61
       0062       00060 svrWREG     EQU   0x62
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 2

ADDR   CODE       LINE  SOURCE

       0063       00061 sv_PRODL    EQU   0x63
       0064       00062 sv_PRODH    EQU   0x64
       0065       00063 sv_TBLPTR   EQU   0x65
       0068       00064 sv_TABLAT   EQU   0x68
       0F7F       00065 PDel0       EQU   0xF7F
       006F       00066 PDel0_2     EQU   0x6F
       006F       00067 PDel0_3     EQU   0x6F
       0070       00068 PDel1       EQU   0x70
       0F7F       00069 PDel0_4     EQU   0xF7F
       0F7F       00070 PDel1_2     EQU   0xF7F
       0F7F       00071 PDel0_5     EQU   0xF7F
       0F7F       00072 PDel1_3     EQU   0xF7F
       0F7F       00073 PDel2       EQU   0xF7F
       006E       00074 codigo      EQU   0x6E
       006E       00075 comando     EQU   0x6E
       0F7F       00076 dato        EQU   0xF7F
       0F7F       00077 i_3         EQU   0xF7F
       0F7F       00078 dato_2      EQU   0xF7F
       0F7F       00079 i_4         EQU   0xF7F
       006D       00080 i_5         EQU   0x6D
       0F7F       00081 linea       EQU   0xF7F
       0F7F       00082 columna     EQU   0xF7F
       0F7F       00083 linea_2     EQU   0xF7F
       0F7F       00084 i_6         EQU   0xF7F
       0F7F       00085 linea_3     EQU   0xF7F
       0F7F       00086 columna_2   EQU   0xF7F
       0F7F       00087 dato_3      EQU   0xF7F
       0000       00088 bd          EQU   0
       0000       00089 dp          EQU   0
       0000       00090 xi          EQU   0
       0000       00091 ndp         EQU   0
       0F7F       00092 num         EQU   0xF7F
       0F7F       00093 u_milers    EQU   0xF7F
       0F7F       00094 cent        EQU   0xF7F
       0F7F       00095 dec         EQU   0xF7F
       0F7F       00096 unid        EQU   0xF7F
       0F7F       00097 resto1      EQU   0xF7F
       0F7F       00098 i_7         EQU   0xF7F
       0F7F       00099 xx          EQU   0xF7F
       0F7F       00100 dat         EQU   0xF7F
       0F7F       00101 xy          EQU   0xF7F
       0F7F       00102 C3cnt       EQU   0xF7F
       0F7F       00103 C4tmp       EQU   0xF7F
       0F7F       00104 C5rem       EQU   0xF7F
       0F7F       00105 C6cnt       EQU   0xF7F
       0F7F       00106 C7tmp       EQU   0xF7F
       0F7F       00107 C8cnt       EQU   0xF7F
       0F7F       00108 C9tmp       EQU   0xF7F
       0F7F       00109 C10rem      EQU   0xF7F
       0F7F       00110 C11cnt      EQU   0xF7F
       0F7F       00111 C12tmp      EQU   0xF7F
       0F7F       00112 C13cnt      EQU   0xF7F
       0F7F       00113 C14tmp      EQU   0xF7F
       0F7F       00114 C15rem      EQU   0xF7F
       0F7F       00115 C16cnt      EQU   0xF7F
       0F7F       00116 C17tmp      EQU   0xF7F
       0F7F       00117 linea_4     EQU   0xF7F
       0F7F       00118 columna_3   EQU   0xF7F
       0F7F       00119 dato_4      EQU   0xF7F
       0F7F       00120 num_2       EQU   0xF7F
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 3

ADDR   CODE       LINE  SOURCE

       0F7F       00121 u_milers_2  EQU   0xF7F
       0F7F       00122 cent_2      EQU   0xF7F
       0F7F       00123 d_milers    EQU   0xF7F
       0F7F       00124 dec_2       EQU   0xF7F
       0F7F       00125 unid_2      EQU   0xF7F
       0F7F       00126 resto1_2    EQU   0xF7F
       0F7F       00127 i_8         EQU   0xF7F
       0F7F       00128 xx_2        EQU   0xF7F
       0F7F       00129 dat_2       EQU   0xF7F
       0F7F       00130 C18cnt      EQU   0xF7F
       0F7F       00131 C19tmp      EQU   0xF7F
       0F7F       00132 C20rem      EQU   0xF7F
       0F7F       00133 C21cnt      EQU   0xF7F
       0F7F       00134 C22tmp      EQU   0xF7F
       0F7F       00135 C23cnt      EQU   0xF7F
       0F7F       00136 C24tmp      EQU   0xF7F
       0F7F       00137 C25rem      EQU   0xF7F
       0F7F       00138 C26cnt      EQU   0xF7F
       0F7F       00139 C27tmp      EQU   0xF7F
       0F7F       00140 C28cnt      EQU   0xF7F
       0F7F       00141 C29tmp      EQU   0xF7F
       0F7F       00142 C30rem      EQU   0xF7F
       0F7F       00143 C31cnt      EQU   0xF7F
       0F7F       00144 C32tmp      EQU   0xF7F
       0F7F       00145 C33cnt      EQU   0xF7F
       0F7F       00146 C34tmp      EQU   0xF7F
       0F7F       00147 C35rem      EQU   0xF7F
       0F7F       00148 C36cnt      EQU   0xF7F
       0F7F       00149 C37tmp      EQU   0xF7F
       0F7F       00150 valor_AD    EQU   0xF7F
       0069       00151 ci          EQU   0x69
                  00152 
000000 EF20 F005  00153 	GOTO main
                  00154 
                  00155   ; FILE ondulador_migrado.c
                  00156 			;/*
                  00157 			; * Autor: J_Sanchez
                  00158 			; * 
                  00159 			; * Fecha: 31-03-2015
                  00160 			; * Descripcion:Primera prueba con el 18F44K20 para el proyecto del ondulador v2.0
                  00161 			; *  Configuracion: 
                  00162 			; *		Modelo: 18F44K20
                  00163 			; *		Oscilador: Crystal 64Mhz
                  00164 			; *		Puente en H con PWM mejorado
                  00165 			; */
                  00166 			;
                  00167 			; //**************************************************************************************//
                  00168 			; //******************* C O N F I G  U R A C I O N    I N I C I A L  *********************//
                  00169 			; //**************************************************************************************//
                  00170 			; 
                  00171 			; #pragma chip PIC18F44K20
                  00172 			; #pragma config[1] = 0b.0000.1000//pagina 301 datasheet
                  00173 			; #pragma config[2] = 0b.0000.0001
                  00174 			; #pragma config[3] = 0b.0001.0110
                  00175 			; #pragma config[5] = 0b.1000.1000//Mirar CCP2 MUX bit 0 -->1 = CCP2 input/output is multiplexed with RC1
                  00176 			;													//   -->0 = CCP2 input/output is multiplexed with RB3 
                  00177 			; #pragma config[6] = 0b.1000.0101
                  00178 			; // resto configs son para la proteccion del programa 
                  00179 			;
                  00180 			; #pragma sharedAllocation//evita error en las interrupciones
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 4

ADDR   CODE       LINE  SOURCE

                  00181 			;
                  00182 			; //**************************************************************************************//
                  00183 			; //********************************  V A R I A B L E S  *********************************//
                  00184 			; //**************************************************************************************//
                  00185 			;
                  00186 			;#define LECTURA_VAC  0
                  00187 			;#define CALCULOS_VAC 1
                  00188 			;#define LECTURA_IAC  2
                  00189 			;#define CALCULOS_IAC 3
                  00190 			;#define ENVIO_LCD    4
                  00191 			;
                  00192 			;
                  00193 			;#pragma rambank 0
                  00194 			;bit bUdw; // a 1 puja en la taula (incrementa) , a 0 decrementa
                  00195 			;uns16 ancho_pwm;
                  00196 			;uns16 Vmax;
                  00197 			;uns8 SENO;
                  00198 			;
                  00199 			;
                  00200 			;char T,i; // Index de la taula
                  00201 			;
                  00202 			;
                  00203 			;static const char sen [26] = 			
                  00204 			;{0,8,16,23,31,39,47,54,61,68,75,81,87,93,98,103,108,112,115,119,121,123,125,126,127,128};
                  00205 			;
                  00206 			;
                  00207 			;//=======================================================================
                  00208 			;#include "int18XXX.h"	 // Capçalera de interrupcions.
                  00209 			;
                  00210 			;#pragma origin 0x08	//#pragma origin 0x18	(PIC 16F88x)// Indica el origen del vector de interrupciones.
       0000       00211 	ORG 0x0008
                  00212 			;
                  00213 			;interrupt highPriorityTimer_0 (void)		// Interrupción por desbordamiento de Timer 0.			
                  00214 			;{
                  00215 highPriorityTimer_0
                  00216 			;	int_save_registers 
000008 CFD8 F060  00217 	MOVFF STATUS,svrSTATUS
00000C CFE0 F061  00218 	MOVFF BSR,svrBSR
000010 0100       00219 	MOVLB 0
000012 6F62       00220 	MOVWF svrWREG,1
                  00221 			;
                  00222 			;	// save remaining registers on demand (error/warning)
                  00223 			;	//uns16 sv_FSR0 = FSR0;
                  00224 			;	//uns16 sv_FSR1 = FSR1;
                  00225 			;	//uns16 sv_FSR2 = FSR2;
                  00226 			;	//uns8 sv_PCLATH = PCLATH;
                  00227 			;	//uns8 sv_PCLATU = PCLATU;
                  00228 			;	uns8 sv_PRODL = PRODL;
000014 CFF3 F063  00229 	MOVFF PRODL,sv_PRODL
                  00230 			;	uns8 sv_PRODH = PRODH;
000018 CFF4 F064  00231 	MOVFF PRODH,sv_PRODH
                  00232 			;	uns24 sv_TBLPTR = TBLPTR;
00001C CFF6 F065  00233 	MOVFF TBLPTR,sv_TBLPTR
000020 CFF7 F066  00234 	MOVFF TBLPTR+1,sv_TBLPTR+1
000024 CFF8 F067  00235 	MOVFF TBLPTR+2,sv_TBLPTR+2
                  00236 			;	uns8 sv_TABLAT = TABLAT;
000028 CFF5 F068  00237 	MOVFF TABLAT,sv_TABLAT
                  00238 			;
                  00239 			;
                  00240 			;	     				// Guarda W, STATUS y PCLATH.
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 5

ADDR   CODE       LINE  SOURCE

                  00241 			;	LATC.0=!LATC.0;
00002C 708B       00242 	BTG   LATC,0,0
                  00243 			;	if(TMR2IF) 	//{ LATD.0= !LATD.0; TMR2IF=0; }
00002E A29E       00244 	BTFSS 0xF9E,TMR2IF,0
000030 D04D       00245 	BRA   m008
                  00246 			;	{ 
                  00247 			;		T2CON = 0b.0.0011.1.01; TMR2IF =0; //TMR2ON =1; // PostScaler per 4
000032 0E1D       00248 	MOVLW 29
000034 6ECA       00249 	MOVWF T2CON,0
000036 929E       00250 	BCF   0xF9E,TMR2IF,0
                  00251 			;		for (i = 1; i <= 6; i ++)  ancho_pwm = rl (ancho_pwm);
000038 0E01       00252 	MOVLW 1
00003A 6F78       00253 	MOVWF i,1
00003C 0E07       00254 m001	MOVLW 7
00003E 0100       00255 	MOVLB 0
000040 6178       00256 	CPFSLT i,1
000042 D004       00257 	BRA   m002
000044 3772       00258 	RLCF  ancho_pwm,1,1
000046 3773       00259 	RLCF  ancho_pwm+1,1,1
000048 2B78       00260 	INCF  i,1,1
00004A D7F8       00261 	BRA   m001
                  00262 			;		CCPR1L    = ancho_pwm.high8;	CCP1CON.5 = ancho_pwm.7;	CCP1CON.4 = ancho_pwm.6;
00004C C073 FFBE  00263 m002	MOVFF ancho_pwm+1,CCPR1L
000050 0100       00264 	MOVLB 0
000052 AF72       00265 	BTFSS ancho_pwm,7,1
000054 9ABD       00266 	BCF   CCP1CON,5,0
000056 BF72       00267 	BTFSC ancho_pwm,7,1
000058 8ABD       00268 	BSF   CCP1CON,5,0
00005A AD72       00269 	BTFSS ancho_pwm,6,1
00005C 98BD       00270 	BCF   CCP1CON,4,0
00005E BD72       00271 	BTFSC ancho_pwm,6,1
000060 88BD       00272 	BSF   CCP1CON,4,0
                  00273 			;				  
                  00274 			;		if(bUdw) 	{ if(T>=25)  bUdw=0;      
000062 A171       00275 	BTFSS 0x71,bUdw,1
000064 D007       00276 	BRA   m004
000066 0E18       00277 	MOVLW 24
000068 6577       00278 	CPFSGT T,1
00006A D002       00279 	BRA   m003
00006C 9171       00280 	BCF   0x71,bUdw,1
                  00281 			;				      else        T++;
00006E D002       00282 	BRA   m004
000070 0100       00283 m003	MOVLB 0
000072 2B77       00284 	INCF  T,1,1
                  00285 			;					} 
                  00286 			;		if(!bUdw)   T--;                       
000074 0100       00287 m004	MOVLB 0
000076 A171       00288 	BTFSS 0x71,bUdw,1
000078 0777       00289 	DECF  T,1,1
                  00290 			;		if(T==0) 
00007A 0100       00291 	MOVLB 0
00007C 5377       00292 	MOVF  T,1,1
00007E A4D8       00293 	BTFSS 0xFD8,Zero_,0
000080 D015       00294 	BRA   m007
                  00295 			;		{  	while(!TMR2IF); TMR2IF =0; // ESPERO QUE ACABI  T=1
000082 A29E       00296 m005	BTFSS 0xF9E,TMR2IF,0
000084 D7FE       00297 	BRA   m005
000086 929E       00298 	BCF   0xF9E,TMR2IF,0
                  00299 			;			T2CON = 0b.0.0001.1.01;  	CCPR1L = 0;		CCP1CON.5 = 0;	CCP1CON.4 = 0;	 // Posrescaler a 2
000088 0E0D       00300 	MOVLW 13
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 6

ADDR   CODE       LINE  SOURCE

00008A 6ECA       00301 	MOVWF T2CON,0
00008C 6ABE       00302 	CLRF  CCPR1L,0
00008E 9ABD       00303 	BCF   CCP1CON,5,0
000090 98BD       00304 	BCF   CCP1CON,4,0
                  00305 			;			//while(!TMR2IF); // espero que acabi el T=0
                  00306 			;			//	TMR2IF =0; // Postscaler a 2
                  00307 			;			while(!TMR2IF); // espeor que acabi la 1era meitat del T=0, postsclaer =2
000092 A29E       00308 m006	BTFSS 0xF9E,TMR2IF,0
000094 D7FE       00309 	BRA   m006
                  00310 			;			TMR2IF =0; 	T2CON = 0b.0.0000.1.01;  	CCPR1L = 0;		CCP1CON.5 = 0;	CCP1CON.4 = 0;
000096 929E       00311 	BCF   0xF9E,TMR2IF,0
000098 0E05       00312 	MOVLW 5
00009A 6ECA       00313 	MOVWF T2CON,0
00009C 6ABE       00314 	CLRF  CCPR1L,0
00009E 9ABD       00315 	BCF   CCP1CON,5,0
0000A0 98BD       00316 	BCF   CCP1CON,4,0
                  00317 			;			LATD.0= !LATD.0;	bUdw=1;  T=1; // el deixo sortir
0000A2 708C       00318 	BTG   LATD,0,0
0000A4 0100       00319 	MOVLB 0
0000A6 8171       00320 	BSF   0x71,bUdw,1
0000A8 0E01       00321 	MOVLW 1
0000AA 6F77       00322 	MOVWF T,1
                  00323 			;		}			  
                  00324 			;							
                  00325 			;		SENO = sen[T];			
0000AC 0100       00326 m007	MOVLB 0
0000AE 5177       00327 	MOVF  T,W,1
0000B0 EC9E F005  00328 	CALL  _const1
0000B4 0100       00329 	MOVLB 0
0000B6 6F76       00330 	MOVWF SENO,1
                  00331 			;		ancho_pwm = (uns16)SENO*Vmax;
0000B8 5176       00332 	MOVF  SENO,W,1
0000BA 0374       00333 	MULWF Vmax,1
0000BC CFF3 F072  00334 	MOVFF PRODL,ancho_pwm
0000C0 CFF4 F073  00335 	MOVFF PRODH,ancho_pwm+1
0000C4 5176       00336 	MOVF  SENO,W,1
0000C6 0375       00337 	MULWF Vmax+1,1
0000C8 50F3       00338 	MOVF  PRODL,W,0
0000CA 2773       00339 	ADDWF ancho_pwm+1,1,1
                  00340 			;				  			  
                  00341 			;	} 
                  00342 			;			
                  00343 			;	// restore registers that are saved
                  00344 			;	//FSR0 = sv_FSR0;
                  00345 			;	//FSR1 = sv_FSR1;
                  00346 			;	//FSR2 = sv_FSR2;
                  00347 			;	//PCLATH = sv_PCLATH;
                  00348 			;	//PCLATU = sv_PCLATU;
                  00349 			;	PRODL = sv_PRODL;
0000CC C063 FFF3  00350 m008	MOVFF sv_PRODL,PRODL
                  00351 			;	PRODH = sv_PRODH;
0000D0 C064 FFF4  00352 	MOVFF sv_PRODH,PRODH
                  00353 			;	TBLPTR = sv_TBLPTR;
0000D4 C065 FFF6  00354 	MOVFF sv_TBLPTR,TBLPTR
0000D8 C066 FFF7  00355 	MOVFF sv_TBLPTR+1,TBLPTR+1
0000DC C067 FFF8  00356 	MOVFF sv_TBLPTR+2,TBLPTR+2
                  00357 			;	TABLAT = sv_TABLAT;
0000E0 C068 FFF5  00358 	MOVFF sv_TABLAT,TABLAT
                  00359 			;
                  00360 			;    int_restore_registers 					// Devuelve W, STATUS y PCLATH.
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 7

ADDR   CODE       LINE  SOURCE

0000E4 0100       00361 	MOVLB 0
0000E6 5162       00362 	MOVF  svrWREG,W,1
0000E8 C061 FFE0  00363 	MOVFF svrBSR,BSR
0000EC C060 FFD8  00364 	MOVFF svrSTATUS,STATUS
                  00365 			;}
0000F0 0010       00366 	RETFIE
                  00367 
                  00368   ; FILE Temporiz_20Mhz.h
                  00369 			;void retardo_10u(void){
                  00370 retardo_10u
                  00371 			;	char PDel0;
                  00372 			;	#asm
                  00373 			;	;-------------------------------------------------------------
                  00374 			;	DEMORA  movlw     .11       ; 1 set numero de repeticion 
0000F2 0E0B       00375 	MOVLW 11
                  00376 			;	        movwf     PDel0     ; 1 |
0000F4 6E7F       00377 	MOVWF PDel0,0
                  00378 			;	PLoop0  clrwdt              ; 1 clear watchdog
0000F6 0004       00379 m009	CLRWDT
                  00380 			;	        decfsz    PDel0, 1  ; 1 + (1) es el tiempo 0  ?
0000F8 2E7F       00381 	DECFSZ PDel0,1,0
                  00382 			;	        goto      PLoop0    ; 2 no, loop
0000FA EF7B F000  00383 	GOTO  m009
                  00384 			;	        clrwdt              ; 1 ciclo delay
0000FE 0004       00385 	CLRWDT
                  00386 			;	        return              ; 2+2 Fin.
000100 0012       00387 	RETURN
                  00388 			;	;-------------------------------------------------------------
                  00389 			;	#endasm
                  00390 			;}
                  00391 			;
                  00392 			;void retardo_20u(void){
                  00393 retardo_20u
                  00394 			;	char PDel0;
                  00395 			;	#asm
                  00396 			;	;------------------------------------------------------------
                  00397 			;	DEMORA  movlw     .23       ; 1 set numero de repeticion 
000102 0E17       00398 	MOVLW 23
                  00399 			;	        movwf     PDel0     ; 1 |
000104 6F6F       00400 	MOVWF PDel0_2,1
                  00401 			;	PLoop0  clrwdt              ; 1 clear watchdog
000106 0004       00402 m010	CLRWDT
                  00403 			;	        decfsz    PDel0, 1  ; 1 + (1) es el tiempo 0  ?
000108 2F6F       00404 	DECFSZ PDel0_2,1,1
                  00405 			;	        goto      PLoop0    ; 2 no, loop
00010A EF83 F000  00406 	GOTO  m010
                  00407 			;	PDelL1  goto PDelL2         ; 2 ciclos delay
00010E EF89 F000  00408 	GOTO  m011
                  00409 			;	PDelL2  clrwdt              ; 1 ciclo delay
000112 0004       00410 m011	CLRWDT
                  00411 			;	        return              ; 2+2 Fin.
000114 0012       00412 	RETURN
                  00413 			;	;-------------------------------------------------------------
                  00414 			;	#endasm
                  00415 			;}
                  00416 			;
                  00417 			;void retardo_1m(void){
                  00418 retardo_1m
                  00419 			;	char PDel0,PDel1;
                  00420 			;	#asm
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 8

ADDR   CODE       LINE  SOURCE

                  00421 			;	;-------------------------------------------------------------
                  00422 			;	DEMORA  movlw     .6        ; 1 set numero de repeticion  (B)
000116 0E06       00423 	MOVLW 6
                  00424 			;	        movwf     PDel0     ; 1 |
000118 6F6F       00425 	MOVWF PDel0_3,1
                  00426 			;	PLoop1  movlw     .207      ; 1 set numero de repeticion  (A)
00011A 0ECF       00427 m012	MOVLW 207
                  00428 			;	        movwf     PDel1     ; 1 |
00011C 6F70       00429 	MOVWF PDel1,1
                  00430 			;	PLoop2  clrwdt              ; 1 clear watchdog
00011E 0004       00431 m013	CLRWDT
                  00432 			;	        decfsz    PDel1, 1  ; 1 + (1) es el tiempo 0  ? (A)
000120 2F70       00433 	DECFSZ PDel1,1,1
                  00434 			;	        goto      PLoop2    ; 2 no, loop
000122 EF8F F000  00435 	GOTO  m013
                  00436 			;	        decfsz    PDel0,  1 ; 1 + (1) es el tiempo 0  ? (B)
000126 2F6F       00437 	DECFSZ PDel0_3,1,1
                  00438 			;	        goto      PLoop1    ; 2 no, loop
000128 EF8D F000  00439 	GOTO  m012
                  00440 			;	PDelL1  goto PDelL2         ; 2 ciclos delay
00012C EF98 F000  00441 	GOTO  m014
                  00442 			;	PDelL2  clrwdt              ; 1 ciclo delay
000130 0004       00443 m014	CLRWDT
                  00444 			;	        return              ; 2+2 Fin.
000132 0012       00445 	RETURN
                  00446 			;	;-------------------------------------------------------------
                  00447 			;	#endasm
                  00448 			;}
                  00449 			;
                  00450 			;void retardo_100m(void){
                  00451 retardo_100m
                  00452 			;	char PDel0,PDel1;
                  00453 			;	#asm
                  00454 			;	;-------------------------------------------------------------
                  00455 			;	DEMORA  movlw     .239      ; 1 set numero de repeticion  (B)
000134 0EEF       00456 	MOVLW 239
                  00457 			;	        movwf     PDel0     ; 1 |
000136 6E7F       00458 	MOVWF PDel0_4,0
                  00459 			;	PLoop1  movlw     .232      ; 1 set numero de repeticion  (A)
000138 0EE8       00460 m015	MOVLW 232
                  00461 			;	        movwf     PDel1     ; 1 |
00013A 6E7F       00462 	MOVWF PDel1_2,0
                  00463 			;	PLoop2  clrwdt              ; 1 clear watchdog
00013C 0004       00464 m016	CLRWDT
                  00465 			;	PDelL1  goto PDelL2         ; 2 ciclos delay
00013E EFA1 F000  00466 	GOTO  m017
                  00467 			;	PDelL2  goto PDelL3         ; 2 ciclos delay
000142 EFA3 F000  00468 m017	GOTO  m018
                  00469 			;	PDelL3  clrwdt              ; 1 ciclo delay
000146 0004       00470 m018	CLRWDT
                  00471 			;	        decfsz    PDel1, 1  ; 1 + (1) es el tiempo 0  ? (A)
000148 2E7F       00472 	DECFSZ PDel1_2,1,0
                  00473 			;	        goto      PLoop2    ; 2 no, loop
00014A EF9E F000  00474 	GOTO  m016
                  00475 			;	        decfsz    PDel0,  1 ; 1 + (1) es el tiempo 0  ? (B)
00014E 2E7F       00476 	DECFSZ PDel0_4,1,0
                  00477 			;	        goto      PLoop1    ; 2 no, loop
000150 EF9C F000  00478 	GOTO  m015
                  00479 			;	PDelL4  goto PDelL5         ; 2 ciclos delay
000154 EFAC F000  00480 	GOTO  m019
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 9

ADDR   CODE       LINE  SOURCE

                  00481 			;	PDelL5  goto PDelL6         ; 2 ciclos delay
000158 EFAE F000  00482 m019	GOTO  m020
                  00483 			;	PDelL6  goto PDelL7         ; 2 ciclos delay
00015C EFB0 F000  00484 m020	GOTO  m021
                  00485 			;	PDelL7  clrwdt              ; 1 ciclo delay
000160 0004       00486 m021	CLRWDT
                  00487 			;	        return              ; 2+2 Fin.
000162 0012       00488 	RETURN
                  00489 			;	;-------------------------------------------------------------
                  00490 			;	#endasm
                  00491 			;}
                  00492 			;void retardo_500m(void){
                  00493 retardo_500m
                  00494 			;	char PDel0,PDel1,PDel2;
                  00495 			;	#asm
                  00496 			;	;-------------------------------------------------------------
                  00497 			;	DEMORA  movlw     .22       ; 1 set numero de repeticion  (C)
000164 0E16       00498 	MOVLW 22
                  00499 			;	        movwf     PDel0     ; 1 |
000166 6E7F       00500 	MOVWF PDel0_5,0
                  00501 			;	PLoop0  movlw     .134      ; 1 set numero de repeticion  (B)
000168 0E86       00502 m022	MOVLW 134
                  00503 			;	        movwf     PDel1     ; 1 |
00016A 6E7F       00504 	MOVWF PDel1_3,0
                  00505 			;	PLoop1  movlw     .211      ; 1 set numero de repeticion  (A)
00016C 0ED3       00506 m023	MOVLW 211
                  00507 			;	        movwf     PDel2     ; 1 |
00016E 6E7F       00508 	MOVWF PDel2,0
                  00509 			;	PLoop2  clrwdt              ; 1 clear watchdog
000170 0004       00510 m024	CLRWDT
                  00511 			;	        decfsz    PDel2, 1  ; 1 + (1) es el tiempo 0  ? (A)
000172 2E7F       00512 	DECFSZ PDel2,1,0
                  00513 			;	        goto      PLoop2    ; 2 no, loop
000174 EFB8 F000  00514 	GOTO  m024
                  00515 			;	        decfsz    PDel1,  1 ; 1 + (1) es el tiempo 0  ? (B)
000178 2E7F       00516 	DECFSZ PDel1_3,1,0
                  00517 			;	        goto      PLoop1    ; 2 no, loop
00017A EFB6 F000  00518 	GOTO  m023
                  00519 			;	        decfsz    PDel0,  1 ; 1 + (1) es el tiempo 0  ? (C)
00017E 2E7F       00520 	DECFSZ PDel0_5,1,0
                  00521 			;	        goto      PLoop0    ; 2 no, loop
000180 EFB4 F000  00522 	GOTO  m022
                  00523 			;	PDelL1  goto PDelL2         ; 2 ciclos delay
000184 EFC4 F000  00524 	GOTO  m025
                  00525 			;	PDelL2  clrwdt              ; 1 ciclo delay
000188 0004       00526 m025	CLRWDT
                  00527 			;	        return              ; 2+2 Fin.
00018A 0012       00528 	RETURN
                  00529 			;	;-------------------------------------------------------------
                  00530 			;	#endasm
                  00531 
                  00532   ; FILE C:\PIC\CC8E\math24F.h
                  00533 			;// *************************************************
                  00534 			;// 24 bit basic floating point math operations
                  00535 			;// Copyright (c) B Knudsen Data, Norway, 2000 - 2005
                  00536 			;// *************************************************
                  00537 			;
                  00538 			;#pragma library 1
                  00539 			;/* PROTOTYPES for page definition in application header file:
                  00540 			;float24 operator* _fmul24( float24 arg1f24, float24 arg2f24);
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 10

ADDR   CODE       LINE  SOURCE

                  00541 			;float24 operator/ _fdiv24( float24 arg1f24, float24 arg2f24);
                  00542 			;float24 operator+ _fadd24( float24 arg1f24, float24 arg2f24);
                  00543 			;float24 operator- _fsub24( float24 arg1f24, float24 arg2f24);
                  00544 			;float24 operator= _int24ToFloat24( int24 arg1f24);
                  00545 			;float24 operator= _int32ToFloat24( int32 arg32);
                  00546 			;int24 operator= _float24ToInt24( float24 arg1f24);
                  00547 			;bit operator< _f24_LT_f24( float24 arg1f24, float24 arg2f24);
                  00548 			;bit operator>= _f24_GE_f24( float24 arg1f24, float24 arg2f24);
                  00549 			;bit operator> _f24_GT_f24( float24 arg1f24, float24 arg2f24);
                  00550 			;bit operator<= _f24_LE_f24( float24 arg1f24, float24 arg2f24);
                  00551 			;*/
                  00552 			;
                  00553 			;// DEFINABLE SYMBOLS (in the application code):
                  00554 			;//#define FP_OPTIM_SPEED  // optimize for SPEED: default
                  00555 			;//#define FP_OPTIM_SIZE   // optimize for SIZE
                  00556 			;//#define DISABLE_ROUNDING   // disable rounding and save code space
                  00557 			;
                  00558 			;#define float24ToIEEE754(a) { a.mid8=rl(a.mid8); a.high8=rr(a.high8);\
                  00559 			;                              a.mid8=rr(a.mid8); }
                  00560 			;#define IEEE754ToFloat24(a) { a.mid8=rl(a.mid8); a.high8=rl(a.high8);\
                  00561 			;                              a.mid8=rr(a.mid8); }
                  00562 			;
                  00563 			;
                  00564 			;/*  24 bit floating point format:
                  00565 			;
                  00566 			;  address  ID
                  00567 			;    X      a.low8  : LSB, bit 0-7 of mantissa
                  00568 			;    X+1    a.mid8  : bit 8-14 of mantissa, bit 15 is the sign bit
                  00569 			;    X+2    a.high8 : MSB, bit 0-7 of exponent, with bias 0x7F
                  00570 			;
                  00571 			;    bit 15 of mantissa is a hidden bit, always equal to 1
                  00572 			;    zero (0.0) :  a.high8 = 0 (mantissa & sign ignored)
                  00573 			;
                  00574 			;   MSB    LSB
                  00575 			;    7F 00 00  : 1.0   =  1.0  * 2**(0x7F-0x7F) = 1.0 * 1
                  00576 			;    7F 80 00  : -1.0  = -1.0  * 2**(0x7F-0x7F) = -1.0 * 1
                  00577 			;    80 00 00  : 2.0   =  1.0  * 2**(0x80-0x7F) = 1.0 * 2
                  00578 			;    80 40 00  : 3.0   =  1.5  * 2**(0x80-0x7F) = 1.5 * 2
                  00579 			;    7E 60 00  : 0.875 =  1.75 * 2**(0x7E-0x7F) = 1.75 * 0.5
                  00580 			;    7F 60 00  : 1.75  =  1.75 * 2**(0x7E-0x7F) = 1.75 * 1
                  00581 			;    7F 7F FF  : 1.999969482
                  00582 			;    00 7C 5A  : 0.0 (mantissa & sign ignored)
                  00583 			;    01 00 00  : 1.17549435e-38 =  1.0 * 2**(0x01-0x7F)
                  00584 			;    FE 7F FF  : 3.40277175e+38 =  1.999969482 * 2**(0xFE-0x7F)
                  00585 			;    FF 00 00  : +INF : positive infinity
                  00586 			;    FF 80 00  : -INF : negative infinity
                  00587 			;*/                 
                  00588 			;
                  00589 			;#define  FpBIAS  0x7F
                  00590 			;
                  00591 			;#ifndef FpFlags_defined
                  00592 			; #define FpFlags_defined
                  00593 			;
                  00594 			; char FpFlags;
                  00595 			; //bit IOV         @ FpFlags.0; // integer overflow flag: NOT USED
                  00596 			; bit FpOverflow    @ FpFlags.1; // floating point overflow flag
                  00597 			; bit FpUnderFlow   @ FpFlags.2; // floating point underflow flag
                  00598 			; bit FpDiv0        @ FpFlags.3; // floating point divide by zero flag
                  00599 			; //bit FpNAN       @ FpFlags.4; // not-a-number exception flag: NOT USED
                  00600 			; bit FpDomainError @ FpFlags.5; // domain error exception flag
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 11

ADDR   CODE       LINE  SOURCE

                  00601 			; bit FpRounding    @ FpFlags.6; // floating point rounding flag, 0=truncation
                  00602 			;                                // 1 = unbiased rounding to nearest LSB
                  00603 			; //bit FpSaturate  @ FpFlags.7; // floating point saturate flag: NOT USED
                  00604 			;
                  00605 			; #pragma floatOverflow FpOverflow
                  00606 			; #pragma floatUnderflow FpUnderFlow
                  00607 			;
                  00608 			; #define InitFpFlags()  FpFlags = 0x40 /* enable rounding as default */
                  00609 			;#endif
                  00610 			;
                  00611 			;#ifdef DISABLE_ROUNDING
                  00612 			; #pragma floatRounding 0
                  00613 			;#endif
                  00614 			;
                  00615 			;
                  00616 			;#if __CoreSet__ < 1600
                  00617 			; #define genAdd(r,a) W=a; btsc(Carry); W=incsz(a); r+=W
                  00618 			; #define genSub(r,a) W=a; btss(Carry); W=incsz(a); r-=W
                  00619 			; #define genAddW(r,a) W=a; btsc(Carry); W=incsz(a); W=r+W
                  00620 			; #define genSubW(r,a) W=a; btss(Carry); W=incsz(a); W=r-W
                  00621 			;#else
                  00622 			; #define genAdd(r,a) W=a; r=addWFC(r)
                  00623 			; #define genSub(r,a) W=a; r=subWFB(r)
                  00624 			; #define genAddW(r,a) W=a; W=addWFC(r)
                  00625 			; #define genSubW(r,a) W=a; W=subWFB(r)
                  00626 			;#endif
                  00627 			;
                  00628 			;#if __CoreSet__ == 1700 || __CoreSet__ == 1800
                  00629 			; #define hw_mult8x8(a,b)  W = a; multiply(b)
                  00630 			; #define loRES PRODL
                  00631 			; #define hiRES PRODH
                  00632 			;#endif
                  00633 			;
                  00634 			;#if __CoreSet__ == 2000
                  00635 			; #define hw_mult8x8(a,b)  W = a; multiply(b)
                  00636 			; #define loRES W
                  00637 			; #define hiRES MULH
                  00638 			;#endif
                  00639 			;
                  00640 			;
                  00641 			;float24 operator* _fmul24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  00642 			;{
                  00643 _fmul24
                  00644 			;    uns16 aarg;
                  00645 			;    W = arg1f24.mid8;
                  00646 			;    aarg.high8 = W;
                  00647 			;
                  00648 			;    // save sign
                  00649 			;    char sign = arg2f24.mid8 ^ W;  // before first overflow test
                  00650 			;
                  00651 			;    W = arg1f24.high8;
                  00652 			;   #if __CoreSet__ / 100 == 17
                  00653 			;    if (W != 0)
                  00654 			;        W = arg2f24.high8;
                  00655 			;    if (W == 0)
                  00656 			;        goto RES0;
                  00657 			;   #else
                  00658 			;    if (!Zero_)
                  00659 			;        W = arg2f24.high8;
                  00660 			;    if (Zero_)
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 12

ADDR   CODE       LINE  SOURCE

                  00661 			;        goto RES0;
                  00662 			;   #endif
                  00663 			;
                  00664 			;    arg1f24.high8 += W /* arg2f24.high8 */;
                  00665 			;    W = FpBIAS-1;
                  00666 			;    if (Carry)  {
                  00667 			;        arg1f24.high8 -= W;
                  00668 			;        if (Carry)
                  00669 			;            goto OVERFLOW;
                  00670 			;    }
                  00671 			;    else  {
                  00672 			;        arg1f24.high8 -= W;
                  00673 			;        if (!Carry)
                  00674 			;            goto UNDERFLOW;
                  00675 			;    }
                  00676 			;    aarg.low8 = arg1f24.low8;
                  00677 			;
                  00678 			;    aarg.15 = 1;
                  00679 			;    arg2f24.15 = 1;
                  00680 			;
                  00681 			;   #if defined hw_mult8x8  &&  !defined FP_OPTIM_SIZE
                  00682 			;
                  00683 			;    char tmpL;
                  00684 			;    arg1f24.low16 = 0;
                  00685 			;
                  00686 			;    hw_mult8x8( arg2f24.low8, aarg.low8);   // p1
                  00687 			;    tmpL = hiRES;
                  00688 			;
                  00689 			;    hw_mult8x8( arg2f24.mid8, aarg.low8);  // p2
                  00690 			;    tmpL += loRES;
                  00691 			;    genAdd( arg1f24.low8, hiRES);
                  00692 			;    genAdd( arg1f24.mid8, 0);
                  00693 			;
                  00694 			;    hw_mult8x8( arg2f24.low8, aarg.mid8);  // p2
                  00695 			;    tmpL += loRES;
                  00696 			;    genAdd( arg1f24.low8, hiRES);
                  00697 			;    genAdd( arg1f24.mid8, 0);
                  00698 			;
                  00699 			;    hw_mult8x8( arg2f24.mid8, aarg.mid8);  // p3
                  00700 			;    arg1f24.low8 += loRES;
                  00701 			;    genAdd( arg1f24.mid8, hiRES);
                  00702 			;
                  00703 			;   #undef hw_mult8x8
                  00704 			;   #undef loRES
                  00705 			;   #undef hiRES
                  00706 			;
                  00707 			;    if (!arg1f24.15)  {
                  00708 			;        tmpL = rl( tmpL);
                  00709 			;        arg1f24.low16 = rl( arg1f24.low16);
                  00710 			;        if (arg1f24.high8 == 0)
                  00711 			;            goto UNDERFLOW;
                  00712 			;        arg1f24.high8 -= 1;
                  00713 			;        W = rl( tmpL);  // restore bit behind LSB in Carry
                  00714 			;    }
                  00715 			;
                  00716 			;   #else
                  00717 			;
                  00718 			;    arg1f24.low16 = 0;
                  00719 			;
                  00720 			;    char counter = sizeof(aarg)*8;
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 13

ADDR   CODE       LINE  SOURCE

                  00721 			;
                  00722 			;    do  {
                  00723 			;        aarg = rr( aarg);
                  00724 			;        if (Carry)  {
                  00725 			;            arg1f24.low8 += arg2f24.low8;
                  00726 			;            genAdd( arg1f24.mid8, arg2f24.mid8);
                  00727 			;        }
                  00728 			;        arg1f24.low16 = rr( arg1f24.low16);
                  00729 			;        counter = decsz(counter);
                  00730 			;    } while (1);
                  00731 			;
                  00732 			;    if (!arg1f24.15)  {
                  00733 			;        // catch Carry bit that was shifted out previously
                  00734 			;        arg1f24.low16 = rl( arg1f24.low16);
                  00735 			;        if (arg1f24.high8 == 0)
                  00736 			;            goto UNDERFLOW;
                  00737 			;        arg1f24.high8 -= 1;
                  00738 			;        W = rl( aarg.high8);
                  00739 			;        // restore bit behind LSB in Carry
                  00740 			;    }
                  00741 			;
                  00742 			;   #endif
                  00743 			;
                  00744 			;   #ifndef DISABLE_ROUNDING
                  00745 			;    if (FpRounding  &&  Carry)  {
                  00746 			;        arg1f24.low8 += 1;
                  00747 			;        if (!arg1f24.low8)  {
                  00748 			;            arg1f24.mid8 += 1;
                  00749 			;            if (!arg1f24.mid8)  {
                  00750 			;               #if __CoreSet__ >= 1700 && __CoreSet__ <= 1800
                  00751 			;                Carry = 1; // previous INCF changes Carry
                  00752 			;               #else
                  00753 			;                // Carry = 1; //OK
                  00754 			;               #endif
                  00755 			;                arg1f24.low16 = rr( arg1f24.low16);
                  00756 			;                arg1f24.high8 += 1;
                  00757 			;                if (Zero_)
                  00758 			;                    goto OVERFLOW;
                  00759 			;            }
                  00760 			;        }
                  00761 			;    }
                  00762 			;   #endif
                  00763 			;    goto SET_SIGN;
                  00764 			;
                  00765 			;  UNDERFLOW:
                  00766 			;    FpUnderFlow = 1;
                  00767 			;  RES0:
                  00768 			;    arg1f24.high8 = 0;
                  00769 			;    goto MANTISSA;
                  00770 			;
                  00771 			;  OVERFLOW:
                  00772 			;    FpOverflow = 1;
                  00773 			;    arg1f24.high8 = 0xFF;
                  00774 			;  MANTISSA:
                  00775 			;    arg1f24.low16 = 0x8000;
                  00776 			;
                  00777 			;  SET_SIGN:
                  00778 			;    if (!(sign & 0x80))
                  00779 			;        arg1f24.15 = 0;
                  00780 			;    return arg1f24;
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 14

ADDR   CODE       LINE  SOURCE

                  00781 			;}
                  00782 			;
                  00783 			;
                  00784 			;
                  00785 			;float24 operator/ _fdiv24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  00786 			;{
                  00787 _fdiv24
                  00788 			;    uns16 aarg;
                  00789 			;    W = arg1f24.mid8;
                  00790 			;    aarg.high8 = W;
                  00791 			;
                  00792 			;    // save sign
                  00793 			;    char sign = arg2f24.mid8 ^ W;  // before first overflow test
                  00794 			;
                  00795 			;   #if __CoreSet__ / 100 == 17
                  00796 			;    if (!arg2f24.high8)
                  00797 			;        goto Div0;
                  00798 			;   #else
                  00799 			;    W = arg2f24.high8;
                  00800 			;    if (Zero_)
                  00801 			;        goto Div0;
                  00802 			;   #endif
                  00803 			;    if (!arg1f24.high8)
                  00804 			;        goto RES0;
                  00805 			;
                  00806 			;    arg1f24.high8 -= arg2f24.high8;
                  00807 			;    W = FpBIAS;
                  00808 			;    if (!Carry)  {
                  00809 			;        arg1f24.high8 += W;
                  00810 			;        if (!Carry)
                  00811 			;            goto UNDERFLOW;
                  00812 			;    }
                  00813 			;    else  {
                  00814 			;        arg1f24.high8 += W;
                  00815 			;        if (Carry)
                  00816 			;            goto OVERFLOW;
                  00817 			;    }
                  00818 			;
                  00819 			;    aarg.low8 = arg1f24.low8;
                  00820 			;    aarg.15 = 1;
                  00821 			;    arg2f24.15 = 1;
                  00822 			;
                  00823 			;    // division: shift & add
                  00824 			;    char counter = 16;
                  00825 			;    arg1f24.low16 = 0;  // speedup
                  00826 			;
                  00827 			;#if defined FP_OPTIM_SPEED || !defined FP_OPTIM_SIZE  // SPEED
                  00828 			;
                  00829 			;    goto START_ML;
                  00830 			;
                  00831 			;  TEST_ZERO_L:
                  00832 			;    W = aarg.low8 - arg2f24.low8;
                  00833 			;    if (!Carry)
                  00834 			;        goto SHIFT_IN_CARRY;
                  00835 			;    aarg.low8 = W;
                  00836 			;    aarg.high8 = 0;
                  00837 			;    goto SET_AND_SHIFT_IN_CARRY;
                  00838 			;
                  00839 			;// MAIN LOOP
                  00840 			;    do  {
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 15

ADDR   CODE       LINE  SOURCE

                  00841 			;      LOOP_ML:
                  00842 			;        if (!Carry)  {
                  00843 			;           START_ML:
                  00844 			;            W = aarg.high8 - arg2f24.mid8;
                  00845 			;            if (Zero_)
                  00846 			;                goto TEST_ZERO_L;
                  00847 			;            if (!Carry)
                  00848 			;                goto SHIFT_IN_CARRY;
                  00849 			;        }
                  00850 			;        aarg.low8 -= arg2f24.low8;
                  00851 			;        genSub( aarg.high8, arg2f24.mid8);
                  00852 			;      SET_AND_SHIFT_IN_CARRY:
                  00853 			;        Carry = 1;
                  00854 			;      SHIFT_IN_CARRY:
                  00855 			;        arg1f24.low16 = rl( arg1f24.low16);
                  00856 			;        // Carry = 0;  // ok, speedup
                  00857 			;        aarg = rl( aarg);
                  00858 			;        counter = decsz(counter);
                  00859 			;    } while (1);
                  00860 			;
                  00861 			;
                  00862 			;
                  00863 			;#else  // SIZE
                  00864 			;
                  00865 			;    goto START_ML;
                  00866 			;
                  00867 			;// MAIN LOOP
                  00868 			;    do  {
                  00869 			;      LOOP_ML:
                  00870 			;        if (Carry)
                  00871 			;            goto SUBTRACT;
                  00872 			;      START_ML:
                  00873 			;        W = aarg.low8 - arg2f24.low8;
                  00874 			;        genSubW( aarg.high8, arg2f24.mid8);
                  00875 			;        if (!Carry)
                  00876 			;            goto SKIP_SUB;
                  00877 			;       SUBTRACT:
                  00878 			;        aarg.low8 -= arg2f24.low8;
                  00879 			;        genSub( aarg.high8, arg2f24.mid8);
                  00880 			;        Carry = 1;
                  00881 			;       SKIP_SUB:
                  00882 			;        arg1f24.low16 = rl( arg1f24.low16);
                  00883 			;        // Carry = 0;  // ok
                  00884 			;        aarg = rl( aarg);
                  00885 			;        counter = decsz(counter);
                  00886 			;    } while (1);
                  00887 			;
                  00888 			;#endif
                  00889 			;
                  00890 			;    if (!arg1f24.15)  {
                  00891 			;        if (!arg1f24.high8)
                  00892 			;            goto UNDERFLOW;
                  00893 			;       #if __CoreSet__ >= 1700 && __CoreSet__ <= 1800
                  00894 			;        sign = rr( sign);   // Save Carry
                  00895 			;       #endif
                  00896 			;        arg1f24.high8 --;
                  00897 			;        counter ++;
                  00898 			;       #if __CoreSet__ >= 1700 && __CoreSet__ <= 1800
                  00899 			;        sign = rl( sign);   // Restore Carry, changed by INCF/DECF
                  00900 			;       #endif
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 16

ADDR   CODE       LINE  SOURCE

                  00901 			;        goto LOOP_ML;
                  00902 			;    }
                  00903 			;
                  00904 			;   #ifndef DISABLE_ROUNDING
                  00905 			;    if (FpRounding)  {
                  00906 			;        if (Carry)
                  00907 			;            goto ADD_1;
                  00908 			;        aarg.low8 -= arg2f24.low8;
                  00909 			;        genSub( aarg.high8, arg2f24.mid8);
                  00910 			;        if (Carry)  {
                  00911 			;          ADD_1:
                  00912 			;            arg1f24.low8 += 1;
                  00913 			;            if (!arg1f24.low8)  {
                  00914 			;                arg1f24.mid8 ++;
                  00915 			;                if (!arg1f24.mid8)  {
                  00916 			;                    arg1f24.low16 = rr( arg1f24.low16);
                  00917 			;                    arg1f24.high8 ++;
                  00918 			;                    if (!arg1f24.high8)
                  00919 			;                        goto OVERFLOW;
                  00920 			;                }
                  00921 			;            }
                  00922 			;        }
                  00923 			;    }
                  00924 			;   #endif
                  00925 			;    goto SET_SIGN;
                  00926 			;
                  00927 			;  Div0:
                  00928 			;    FpDiv0 = 1;
                  00929 			;    goto SATURATE;
                  00930 			;
                  00931 			;  UNDERFLOW:
                  00932 			;    FpUnderFlow = 1;
                  00933 			;  RES0:
                  00934 			;    arg1f24.high8 = 0;
                  00935 			;    goto MANTISSA;
                  00936 			;
                  00937 			;  OVERFLOW:
                  00938 			;    FpOverflow = 1;
                  00939 			;  SATURATE:
                  00940 			;    arg1f24.high8 = 0xFF;
                  00941 			;  MANTISSA:
                  00942 			;    arg1f24.low16 = 0x8000;
                  00943 			;
                  00944 			;  SET_SIGN:
                  00945 			;    if (!(sign & 0x80))
                  00946 			;        arg1f24.15 = 0;
                  00947 			;    return arg1f24;
                  00948 			;}
                  00949 			;
                  00950 			;
                  00951 			;float24 operator+ _fadd24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  00952 			;{
                  00953 _fadd24
                  00954 			;    char xtra, temp;
                  00955 			;    char expo = arg1f24.high8 - arg2f24.high8;
                  00956 			;    if (!Carry)  {
                  00957 			;        expo = -expo;
                  00958 			;        temp = arg1f24.high8;
                  00959 			;        arg1f24.high8 = arg2f24.high8;
                  00960 			;        arg2f24.high8 = temp;
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 17

ADDR   CODE       LINE  SOURCE

                  00961 			;        temp = arg1f24.mid8;
                  00962 			;        arg1f24.mid8 = arg2f24.mid8;
                  00963 			;        arg2f24.mid8 = temp;
                  00964 			;        temp = arg1f24.low8;
                  00965 			;        arg1f24.low8 = arg2f24.low8;
                  00966 			;        arg2f24.low8 = temp;
                  00967 			;    }
                  00968 			;    if (expo > sizeof(arg1f24)*8-7)
                  00969 			;        goto _RETURN_MF;
                  00970 			;    if (!arg2f24.high8)
                  00971 			;        goto _RETURN_MF;   // result is arg1f24
                  00972 			;
                  00973 			;    xtra = 0;
                  00974 			;
                  00975 			;    W = arg1f24.mid8;
                  00976 			;    temp = W;
                  00977 			;    char sign = arg2f24.mid8 ^ W;
                  00978 			;    arg1f24.15 = 1;
                  00979 			;    arg2f24.15 = 1;
                  00980 			;
                  00981 			;    while (1)  {
                  00982 			;        W = 8;
                  00983 			;        expo -= W;
                  00984 			;        if (!Carry)
                  00985 			;            break;
                  00986 			;        xtra = arg2f24.low8;
                  00987 			;        arg2f24.low8 = arg2f24.mid8;
                  00988 			;        arg2f24.mid8 = 0;
                  00989 			;    }
                  00990 			;    expo += W;
                  00991 			;    if (expo)  {
                  00992 			;        do  {
                  00993 			;            Carry = 0;
                  00994 			;            arg2f24.low16 = rr( arg2f24.low16);
                  00995 			;            xtra = rr( xtra);
                  00996 			;        } while (--expo > 0);
                  00997 			;    }
                  00998 			;
                  00999 			;
                  01000 			;    if (sign & 0x80)  {
                  01001 			;        // SUBTRACT
                  01002 			;        arg1f24.low8 -= arg2f24.low8;
                  01003 			;        genSub( arg1f24.mid8, arg2f24.mid8);
                  01004 			;        if (!Carry)  {  // arg2f24 > arg1f24
                  01005 			;            arg1f24.low16 = -arg1f24.low16;
                  01006 			;            // xtra == 0 because arg1f24.exp == arg2f24.exp
                  01007 			;            temp ^= 0x80;  // invert sign
                  01008 			;        }
                  01009 			;        xtra = -xtra;
                  01010 			;        if (xtra)
                  01011 			;            arg1f24.low16 --;
                  01012 			;        // adjust result left
                  01013 			;       #define counter expo
                  01014 			;        counter = 3;
                  01015 			;        while (!arg1f24.mid8)  {
                  01016 			;            arg1f24.mid8 = arg1f24.low8;
                  01017 			;            arg1f24.low8 = xtra;
                  01018 			;            xtra = 0;
                  01019 			;            arg1f24.high8 -= 8;
                  01020 			;            if (!Carry)
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 18

ADDR   CODE       LINE  SOURCE

                  01021 			;                goto RES0;
                  01022 			;            if (--counter == 0)  // max 2 iterations
                  01023 			;                goto RES0;
                  01024 			;        }
                  01025 			;       #undef counter
                  01026 			;        while (!arg1f24.15)  {
                  01027 			;            Carry = 0;
                  01028 			;            xtra = rl( xtra);
                  01029 			;            arg1f24.low16 = rl( arg1f24.low16);
                  01030 			;            arg1f24.high8 --;
                  01031 			;            if (!arg1f24.high8)
                  01032 			;                goto RES0;   // UNDERFLOW?
                  01033 			;        }
                  01034 			;       #ifndef DISABLE_ROUNDING
                  01035 			;        if (FpRounding  &&  (xtra & 0x80))  {
                  01036 			;            xtra = 0; // disable recursion
                  01037 			;            goto INCREMENT;
                  01038 			;        }
                  01039 			;       #endif
                  01040 			;    }
                  01041 			;    else  {
                  01042 			;        // ADD arg1f24 and arg2f24
                  01043 			;        arg1f24.low8 += arg2f24.low8;
                  01044 			;        genAdd( arg1f24.mid8, arg2f24.mid8);
                  01045 			;        if (Carry)  {
                  01046 			;          ADJUST_RIGHT:
                  01047 			;            arg1f24.low16 = rr( arg1f24.low16);
                  01048 			;            xtra = rr( xtra);
                  01049 			;            arg1f24.high8 += 1;  // exp
                  01050 			;            if (!arg1f24.high8)
                  01051 			;                goto OVERFLOW;
                  01052 			;        }
                  01053 			;       #ifndef DISABLE_ROUNDING
                  01054 			;        if (FpRounding  &&  (xtra & 0x80))  {
                  01055 			;          INCREMENT:
                  01056 			;            arg1f24.low8 += 1;
                  01057 			;            if (!arg1f24.low8)  {
                  01058 			;                arg1f24.mid8 += 1;
                  01059 			;                if (!arg1f24.mid8)  {
                  01060 			;                    Carry = 1; // prepare for shift
                  01061 			;                    arg1f24.0 = 0;  // disable recursion
                  01062 			;                    goto ADJUST_RIGHT;
                  01063 			;                }
                  01064 			;            }
                  01065 			;        }
                  01066 			;       #endif
                  01067 			;    }
                  01068 			;    goto SET_SIGN;
                  01069 			;
                  01070 			;//  UNDERFLOW:
                  01071 			;//    FpUnderFlow = 1;
                  01072 			;  RES0:
                  01073 			;    arg1f24.high8 = 0;
                  01074 			;    goto MANTISSA;
                  01075 			;
                  01076 			;  OVERFLOW:
                  01077 			;    FpOverflow = 1;
                  01078 			;    arg1f24.high8 = 0xFF;
                  01079 			;  MANTISSA:
                  01080 			;    arg1f24.low16 = 0x8000;
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 19

ADDR   CODE       LINE  SOURCE

                  01081 			;
                  01082 			;  SET_SIGN:
                  01083 			;    if (!(temp & 0x80))
                  01084 			;        arg1f24.15 = 0;
                  01085 			;
                  01086 			;  _RETURN_MF:
                  01087 			;    return arg1f24;
                  01088 			;}
                  01089 			;
                  01090 			;
                  01091 			;// SUBTRACTION
                  01092 			;
                  01093 			;float24 operator- _fsub24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  01094 			;{
                  01095 _fsub24
                  01096 			;    arg2f24.mid8 ^= 0x80;
                  01097 			;    arg1f24 += arg2f24;
                  01098 			;    return arg1f24;
                  01099 			;}
                  01100 			;
                  01101 			;
                  01102 			;float24 operator=( int8 arg) @
                  01103 			;float24 operator=( uns8 arg) @
                  01104 			;float24 operator=( int16 arg) @
                  01105 			;float24 operator=( uns16 arg) @
                  01106 			;float24 operator= _int24ToFloat24( sharedM int24 arg1f24)
                  01107 			;{
                  01108 _int24ToFloat24
                  01109 			;    sharedM float24 arg2f24;   // unused, but required
                  01110 			;    char expo = FpBIAS + 16 - 1;
                  01111 			;    char xtra = 0;
                  01112 			;    char sign = 0;
                  01113 			;    if (arg1f24 < 0)  {
                  01114 			;        arg1f24 = -arg1f24;
                  01115 			;        sign |= 0x80;
                  01116 			;    }
                  01117 			;    if (arg1f24.high8)  {
                  01118 			;        expo += 8;
                  01119 			;        xtra = arg1f24.low8;
                  01120 			;        arg1f24.low8 = arg1f24.mid8;
                  01121 			;        arg1f24.mid8 = arg1f24.high8;
                  01122 			;    }
                  01123 			;    else if (!arg1f24.mid8)  {
                  01124 			;        expo -= 8;
                  01125 			;        W = arg1f24.low8;
                  01126 			;        if (!W)
                  01127 			;            goto _RETURN_MF;
                  01128 			;        arg1f24.mid8 = W;
                  01129 			;        arg1f24.low8 = 0;
                  01130 			;    }
                  01131 			;
                  01132 			;    // arg1f24.mid8 != 0
                  01133 			;    goto TEST_ARG1_B15;
                  01134 			;    do  {
                  01135 			;        xtra = rl( xtra);
                  01136 			;        arg1f24.low16 = rl( arg1f24.low16);
                  01137 			;        expo --;
                  01138 			;      TEST_ARG1_B15:
                  01139 			;    } while (!arg1f24.15);
                  01140 			;
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 20

ADDR   CODE       LINE  SOURCE

                  01141 			;   #ifndef DISABLE_ROUNDING
                  01142 			;    if (FpRounding && (xtra & 0x80))  {
                  01143 			;        arg1f24.low8 += 1;
                  01144 			;        if (!arg1f24.low8)  {
                  01145 			;            arg1f24.mid8 += 1;
                  01146 			;            if (!arg1f24.mid8)  {
                  01147 			;                Carry = 1;
                  01148 			;                arg1f24.low16 = rr( arg1f24.low16);
                  01149 			;                expo ++;
                  01150 			;            }
                  01151 			;        }
                  01152 			;    }
                  01153 			;   #endif
                  01154 			;
                  01155 			;    arg1f24.high8 = expo;
                  01156 			;    if (!(sign & 0x80))
                  01157 			;        arg1f24.15 = 0;
                  01158 			;
                  01159 			;  _RETURN_MF:
                  01160 			;    float24 rval @ arg1f24;
                  01161 			;    rval.low24 = arg1f24.low24;
                  01162 			;    return rval;
                  01163 			;}
                  01164 			;
                  01165 			;
                  01166 			;float24 operator=( uns24 arg) @
                  01167 			;float24 operator= _int32ToFloat24( int32 arg32)
                  01168 			;{
                  01169 _int32ToFloat24
                  01170 			;    char expo = FpBIAS + 16 - 1;
                  01171 			;    char xtra @ arg32.high8;
                  01172 			;    char sign = 0;
                  01173 			;    if (arg32 < 0)  {
                  01174 			;        arg32 = -arg32;
                  01175 			;        sign |= 0x80;
                  01176 			;    }
                  01177 			;    if (arg32.high8)  {
                  01178 			;        expo += 8;
                  01179 			;        arg32.low8 = arg32.midL8;
                  01180 			;        arg32.midL8 = arg32.midH8;
                  01181 			;        arg32.midH8 = arg32.high8;
                  01182 			;        arg32.high8 = 0;
                  01183 			;    }
                  01184 			;    if (arg32.midH8)  {
                  01185 			;        expo += 8;
                  01186 			;        xtra = arg32.low8;
                  01187 			;        arg32.low8 = arg32.midL8;
                  01188 			;        arg32.midL8 = arg32.midH8;
                  01189 			;    }
                  01190 			;    else if (!arg32.midL8)  {
                  01191 			;        expo -= 8;
                  01192 			;        W = arg32.low8;
                  01193 			;        if (!W)
                  01194 			;            goto _RETURN_MF;
                  01195 			;        arg32.midL8 = W;
                  01196 			;        arg32.low8 = 0;
                  01197 			;    }
                  01198 			;
                  01199 			;    // arg32.midL8 != 0
                  01200 			;    goto TEST_ARG_B15;
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 21

ADDR   CODE       LINE  SOURCE

                  01201 			;    do  {
                  01202 			;        xtra = rl( xtra);
                  01203 			;        arg32.low16 = rl( arg32.low16);
                  01204 			;        expo --;
                  01205 			;      TEST_ARG_B15:
                  01206 			;    } while (!arg32.15);
                  01207 			;
                  01208 			;   #ifndef DISABLE_ROUNDING
                  01209 			;    if (FpRounding && (xtra & 0x80))  {
                  01210 			;        arg32.low8 += 1;
                  01211 			;        if (!arg32.low8)  {
                  01212 			;            arg32.midL8 += 1;
                  01213 			;            if (!arg32.midL8)  {
                  01214 			;                Carry = 1;
                  01215 			;                arg32.low16 = rr( arg32.low16);
                  01216 			;                expo ++;
                  01217 			;            }
                  01218 			;        }
                  01219 			;    }
                  01220 			;   #endif
                  01221 			;
                  01222 			;    arg32.midH8 = expo;
                  01223 			;    if (!(sign & 0x80))
                  01224 			;        arg32.15 = 0;
                  01225 			;
                  01226 			;  _RETURN_MF:
                  01227 			;    float24 rval @ arg32;
                  01228 			;    rval.low24 = arg32.low24;
                  01229 			;    return rval;
                  01230 			;}
                  01231 			;
                  01232 			;
                  01233 			;uns8 operator=( sharedM float24 arg1f24) @
                  01234 			;int8 operator=( sharedM float24 arg1f24) @
                  01235 			;uns16 operator=( sharedM float24 arg1f24) @
                  01236 			;int16 operator=( sharedM float24 arg1f24) @
                  01237 			;int24 operator= _float24ToInt24( sharedM float24 arg1f24)
                  01238 			;{
                  01239 _float24ToInt24
                  01240 			;    sharedM float24 arg2f24;   // unused, but required
                  01241 			;    char sign = arg1f24.mid8;
                  01242 			;    char expo = arg1f24.high8 - (FpBIAS-1);
                  01243 			;    if (!Carry)
                  01244 			;        goto RES0;
                  01245 			;    arg1f24.15 = 1;
                  01246 			;
                  01247 			;    arg1f24.high8 = 0;
                  01248 			;   #ifndef DISABLE_ROUNDING
                  01249 			;    char xtra = 0;
                  01250 			;   #endif
                  01251 			;
                  01252 			;    // (a): expo = 0..8 : shift 1 byte to the right
                  01253 			;    // (b): expo = 9..16: shift 0 byte
                  01254 			;    // (c): expo = 17..24: shift 1 byte to the left
                  01255 			;   #if __CoreSet__ / 100 == 12
                  01256 			;    expo -= 17;
                  01257 			;    expo = 0xFF - expo;  // COMF (Carry unchanged)
                  01258 			;    if (Carry)  {  // (c)
                  01259 			;   #else
                  01260 			;    expo = 16 - expo;
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 22

ADDR   CODE       LINE  SOURCE

                  01261 			;    if (!Carry)  {  // (c)
                  01262 			;   #endif
                  01263 			;        expo += 8;
                  01264 			;        if (!Carry)
                  01265 			;            goto OVERFLOW;
                  01266 			;        arg1f24.high8 = arg1f24.mid8;
                  01267 			;        arg1f24.mid8 = arg1f24.low8;
                  01268 			;        arg1f24.low8 = 0;
                  01269 			;    }
                  01270 			;    else  {  // (a) (b)
                  01271 			;        // expo = 0 .. 16
                  01272 			;        W = expo - 8;
                  01273 			;        if (Carry)  {  // (a)
                  01274 			;            expo = W;
                  01275 			;           #ifndef DISABLE_ROUNDING
                  01276 			;            xtra = arg1f24.low8;
                  01277 			;           #endif
                  01278 			;            arg1f24.low8 = arg1f24.mid8;
                  01279 			;            arg1f24.mid8 = 0;
                  01280 			;        }
                  01281 			;    }
                  01282 			;    if (expo)  {
                  01283 			;        do  {
                  01284 			;            Carry = 0;
                  01285 			;            arg1f24.high8 = rr( arg1f24.high8);
                  01286 			;            arg1f24.low16 = rr( arg1f24.low16);
                  01287 			;           #ifndef DISABLE_ROUNDING
                  01288 			;            xtra = rr( xtra);
                  01289 			;           #endif
                  01290 			;        } while (--expo);
                  01291 			;    }
                  01292 			;    if (arg1f24.23)  {
                  01293 			;       OVERFLOW:
                  01294 			;        FpOverflow = 1;
                  01295 			;        W = 0xFF;
                  01296 			;        goto ASSIGNW;
                  01297 			;       RES0:
                  01298 			;        W = 0;
                  01299 			;       ASSIGNW:
                  01300 			;        arg1f24.low8 = W;
                  01301 			;        arg1f24.mid8 = W;
                  01302 			;        arg1f24.high8 = W;
                  01303 			;        arg1f24.23 = 0;
                  01304 			;    }
                  01305 			;    else  {
                  01306 			;       #ifndef DISABLE_ROUNDING
                  01307 			;        if (FpRounding && (xtra & 0x80))  {
                  01308 			;            arg1f24.low8 += 1;
                  01309 			;            if (!arg1f24.low8)
                  01310 			;                arg1f24.mid8 += 1;
                  01311 			;        }
                  01312 			;       #endif
                  01313 			;        if (sign & 0x80)
                  01314 			;            arg1f24.low24 = -arg1f24.low24;
                  01315 			;    }
                  01316 			;    int24 rval @ arg1f24;
                  01317 			;    rval = arg1f24.low24;
                  01318 			;    return rval;
                  01319 			;}
                  01320 			;
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 23

ADDR   CODE       LINE  SOURCE

                  01321 			;
                  01322 			;bit operator< _f24_LT_f24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  01323 			;{
                  01324 _f24_LT_f24
                  01325 			;    Carry = 0;
                  01326 			;    if (!(arg1f24.high8 | arg2f24.high8))
                  01327 			;        return Carry;
                  01328 			;    if (!arg1f24.15)  {
                  01329 			;        if (arg2f24.15)
                  01330 			;            return Carry;
                  01331 			;        W = arg1f24.low8 - arg2f24.low8;
                  01332 			;        genSubW( arg1f24.mid8, arg2f24.mid8);
                  01333 			;        genSubW( arg1f24.high8, arg2f24.high8);
                  01334 			;        goto _RETURN_MF;
                  01335 			;    }
                  01336 			;    if (!arg2f24.15)
                  01337 			;        goto _RETURN_MF;
                  01338 			;    W = arg2f24.low8 - arg1f24.low8;
                  01339 			;    genSubW( arg2f24.mid8, arg1f24.mid8);
                  01340 			;    genSubW( arg2f24.high8, arg1f24.high8);
                  01341 			;  _RETURN_MF:
                  01342 			;    if (Carry)
                  01343 			;        return 0;
                  01344 			;    return 1;
                  01345 			;}
                  01346 			;
                  01347 			;
                  01348 			;bit operator>= _f24_GE_f24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  01349 			;{
                  01350 _f24_GE_f24
                  01351 			;    Carry = 1;
                  01352 			;    if (!(arg1f24.high8 | arg2f24.high8))
                  01353 			;        return Carry;
                  01354 			;    if (!arg1f24.15)  {
                  01355 			;        if (arg2f24.15)
                  01356 			;            return Carry;
                  01357 			;        W = arg1f24.low8 - arg2f24.low8;
                  01358 			;        genSubW( arg1f24.mid8, arg2f24.mid8);
                  01359 			;        genSubW( arg1f24.high8, arg2f24.high8);
                  01360 			;        return Carry;
                  01361 			;    }
                  01362 			;    Carry = 0;
                  01363 			;    if (!arg2f24.15)
                  01364 			;        return Carry;
                  01365 			;    W = arg2f24.low8 - arg1f24.low8;
                  01366 			;    genSubW( arg2f24.mid8, arg1f24.mid8);
                  01367 			;    genSubW( arg2f24.high8, arg1f24.high8);
                  01368 			;    return Carry;
                  01369 			;}
                  01370 			;
                  01371 			;
                  01372 			;
                  01373 			;bit operator> _f24_GT_f24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  01374 			;{
                  01375 _f24_GT_f24
                  01376 			;    Carry = 0;
                  01377 			;    if (!(arg1f24.high8 | arg2f24.high8))
                  01378 			;        return Carry;
                  01379 			;    if (!arg1f24.15)  {
                  01380 			;        if (arg2f24.15)
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 24

ADDR   CODE       LINE  SOURCE

                  01381 			;            goto _RETURN_MF;
                  01382 			;        W = arg2f24.low8 - arg1f24.low8;
                  01383 			;        genSubW( arg2f24.mid8, arg1f24.mid8);
                  01384 			;        genSubW( arg2f24.high8, arg1f24.high8);
                  01385 			;        goto _RETURN_MF;
                  01386 			;    }
                  01387 			;    if (!arg2f24.15)
                  01388 			;        return Carry;
                  01389 			;    W = arg1f24.low8 - arg2f24.low8;
                  01390 			;    genSubW( arg1f24.mid8, arg2f24.mid8);
                  01391 			;    genSubW( arg1f24.high8, arg2f24.high8);
                  01392 			;  _RETURN_MF:
                  01393 			;    if (Carry)
                  01394 			;        return 0;
                  01395 			;    return 1;
                  01396 			;}
                  01397 			;
                  01398 			;
                  01399 			;
                  01400 			;bit operator<= _f24_LE_f24( sharedM float24 arg1f24, sharedM float24 arg2f24)
                  01401 			;{
                  01402 _f24_LE_f24
                  01403 			;    Carry = 1;
                  01404 			;    if (!(arg1f24.high8 | arg2f24.high8))
                  01405 			;        return Carry;
                  01406 			;    if (!arg1f24.15)  {
                  01407 			;        Carry = 0;
                  01408 			;        if (arg2f24.15)
                  01409 			;            return Carry;
                  01410 			;        W = arg2f24.low8 - arg1f24.low8;
                  01411 			;        genSubW( arg2f24.mid8, arg1f24.mid8);
                  01412 			;        genSubW( arg2f24.high8, arg1f24.high8);
                  01413 			;        return Carry;
                  01414 			;    }
                  01415 			;    if (!arg2f24.15)
                  01416 			;        return Carry;
                  01417 			;    W = arg1f24.low8 - arg2f24.low8;
                  01418 			;    genSubW( arg1f24.mid8, arg2f24.mid8);
                  01419 			;    genSubW( arg1f24.high8, arg2f24.high8);
                  01420 			;    return Carry;
                  01421 
                  01422   ; FILE C:\PIC\CC8E\math24LB.h
                  01423 			;// *************************************************
                  01424 			;// 24 bit floating point math functions
                  01425 			;// Copyright (c) B Knudsen Data, Norway, 2000 - 2006
                  01426 			;// *************************************************
                  01427 			;
                  01428 			;#pragma library 1
                  01429 			;/* PROTOTYPES for page definition in application header file:
                  01430 			;float24 log( float24 arg1f24);
                  01431 			;float24 log10( float24 arg1f24);
                  01432 			;float24 exp10( float24 arg1f24);
                  01433 			;float24 exp( float24 arg1f24);
                  01434 			;float24 cos( float24 arg1f24);
                  01435 			;float24 sin( float24 arg1f24);
                  01436 			;float24 sqrt( float24 arg1f24);
                  01437 			;*/
                  01438 			;
                  01439 			;#ifndef FpFlags_defined
                  01440 			; #error The basic 24 bit floating point math library must be included first
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 25

ADDR   CODE       LINE  SOURCE

                  01441 			;#endif
                  01442 			;
                  01443 			;#if __CoreSet__ / 100 == 12
                  01444 			; #error Math functions (exp,log,..) are not adapted to 12 bit core devices
                  01445 			;#endif
                  01446 			;
                  01447 			;#if __CoreSet__ < 1600
                  01448 			; #define genAdd(r,a) W=a; btsc(Carry); W=incsz(a); r+=W
                  01449 			; #define genSub(r,a) W=a; btss(Carry); W=incsz(a); r-=W
                  01450 			; #define genAddW(r,a) W=a; btsc(Carry); W=incsz(a); W=r+W
                  01451 			; #define genSubW(r,a) W=a; btss(Carry); W=incsz(a); W=r-W
                  01452 			;#else
                  01453 			; #define genAdd(r,a) W=a; r=addWFC(r)
                  01454 			; #define genSub(r,a) W=a; r=subWFB(r)
                  01455 			; #define genAddW(r,a) W=a; W=addWFC(r)
                  01456 			; #define genSubW(r,a) W=a; W=subWFB(r)
                  01457 			;#endif
                  01458 			;
                  01459 			;
                  01460 			;float24 log( sharedM float24 arg1f24)
                  01461 			;{
                  01462 log
                  01463 			;    sharedM float24 arg2f24;
                  01464 			;
                  01465 			;    if (arg1f24.mid8 & 0x80)  //  test for negative argument
                  01466 			;        goto _DOMERR32;
                  01467 			;    if (!arg1f24.high8)   //  test for zero argument
                  01468 			;        goto _DOMERR32;
                  01469 			;
                  01470 			;    char savedFlags = FpFlags;   //  save rounding flag
                  01471 			;    FpFlags |= 0x40;  //  enable rounding
                  01472 			;
                  01473 			;    char xexp = arg1f24.high8 - (FpBIAS-1);
                  01474 			;    arg1f24.high8 = FpBIAS-1;
                  01475 			;
                  01476 			;    arg2f24 = 1.0;
                  01477 			;
                  01478 			;    //  .70710678118655 = 7E3504F3
                  01479 			;    W = arg1f24.low8 - 0x05;
                  01480 			;    W = 0x35;
                  01481 			;    if (!Carry)
                  01482 			;        W = 0x35+1;
                  01483 			;    W = arg1f24.mid8 - W;
                  01484 			;
                  01485 			;    if (Carry)
                  01486 			;        arg1f24 -= arg2f24;
                  01487 			;    else  {
                  01488 			;        arg1f24.high8 += 1;  /* arg1f24 *= 2; */
                  01489 			;        arg1f24 -= arg2f24;
                  01490 			;        xexp -= 1;
                  01491 			;    }
                  01492 			;
                  01493 			;    float24 d = arg1f24;  //  save z
                  01494 			;
                  01495 			;    // POLL132  LOG32Q,2,0  ; Q(z)
                  01496 			;    arg1f24 += 0.33339502905E+1; /* LOG32Q1 */
                  01497 			;    arg1f24 *= d;
                  01498 			;    arg1f24 += 0.24993759223E1;  /* LOG32Q0 */
                  01499 			;    float24 c = arg1f24;
                  01500 			;
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 26

ADDR   CODE       LINE  SOURCE

                  01501 			;     //   minimax rational approximation  z-.5*z*z+z*(z*z*P(z)/Q(z))
                  01502 			;    // POL32  LOG32P,1,0  ; P(z)
                  01503 			;    arg1f24 = d;
                  01504 			;    arg1f24 *= 0.48646956294; /* LOG32P1 */
                  01505 			;    arg1f24 += 0.83311400452; /* LOG32P0 */
                  01506 			;
                  01507 			;    c = arg1f24 / c;   //  P(z)/Q(z)
                  01508 			;
                  01509 			;    W = d.high8;  arg1f24.high8 = W;  arg2f24.high8 = W;
                  01510 			;    W = d.mid8;   arg1f24.mid8 = W;   arg2f24.mid8 = W;
                  01511 			;    W = d.low8;   arg1f24.low8 = W;   arg2f24.low8 = W;
                  01512 			;
                  01513 			;    arg1f24 *= arg2f24;       // z * z;
                  01514 			;
                  01515 			;    float24 e = arg1f24;
                  01516 			;    arg1f24 *= c;          //  z*z*P(z)/Q(z)
                  01517 			;    arg1f24 *= d;          //  z*(z*z*P(z)/Q(z))
                  01518 			;
                  01519 			;    arg2f24 = e;
                  01520 			;    if (arg2f24.high8)
                  01521 			;        arg2f24.high8 --;  // arg2f24 *= 0.5;
                  01522 			;    arg1f24 -= arg2f24;       //  -.5*z*z + z*(z*z*P(z)/Q(z))
                  01523 			;    arg1f24 += d;          //  z -.5*z*z + z*(z*z*P(z)/Q(z))
                  01524 			;
                  01525 			;    if (!xexp)
                  01526 			;        goto _RETURN_MF;
                  01527 			;
                  01528 			;    e = arg1f24;  //  save
                  01529 			;
                  01530 			;    // integer to floating point conversion
                  01531 			;    arg1f24 = (int8) xexp;
                  01532 			;
                  01533 			;    d = arg1f24;  //  save k
                  01534 			;
                  01535 			;    arg1f24 *= -0.000212194440055;
                  01536 			;
                  01537 			;    arg1f24 += e;   //  log(1+z) + k*log(2)
                  01538 			;
                  01539 			;    e = arg1f24;  //  save
                  01540 			;
                  01541 			;    arg1f24 = d * 0.693359375;
                  01542 			;
                  01543 			;    arg1f24 += e;      //  log(1+z) + k*log(2)
                  01544 			;
                  01545 			;    if (!(savedFlags & 0x40))
                  01546 			;        FpFlags &= ~0x40;   //  restore rounding flag
                  01547 			;    goto _RETURN_MF;
                  01548 			;
                  01549 			;  _DOMERR32:
                  01550 			;    FpDomainError = 1;   //  domain error
                  01551 			;
                  01552 			;  _RETURN_MF:
                  01553 			;    return arg1f24;
                  01554 			;}
                  01555 			;
                  01556 			;
                  01557 			;
                  01558 			;float24 log10( sharedM float24 arg1f24)
                  01559 			;{
                  01560 log10
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 27

ADDR   CODE       LINE  SOURCE

                  01561 			;    sharedM float24 arg2f24;      // allocation 'trick'
                  01562 			;
                  01563 			;    char flags = FpFlags;
                  01564 			;    FpFlags |= 0x40;
                  01565 			;
                  01566 			;    arg1f24 = log( arg1f24);
                  01567 			;
                  01568 			;    arg1f24 *= 0.43429448190325;  //  log10(e);
                  01569 			;
                  01570 			;    if (!(flags & 0x40))
                  01571 			;        FpFlags &= ~0x40;
                  01572 			;
                  01573 			;    return arg1f24;
                  01574 			;}
                  01575 			;
                  01576 			;
                  01577 			;
                  01578 			;char floorMaskTable24( char i)
                  01579 			;{
                  01580 floorMaskTable24
                  01581 			;    if (i & 4)  {
                  01582 			;        if (i & 2)  {
                  01583 			;            if (i & 1)
                  01584 			;                return 128;
                  01585 			;            return 192;
                  01586 			;        }
                  01587 			;        if (i & 1)
                  01588 			;            return 224;
                  01589 			;        return 240;
                  01590 			;    }
                  01591 			;    if (i & 2)  {
                  01592 			;        if (i & 1)
                  01593 			;            return 248;
                  01594 			;        return 252;
                  01595 			;    }
                  01596 			;    if (i & 1)
                  01597 			;        return 254;
                  01598 			;    return 255;
                  01599 			;}
                  01600 			;
                  01601 			;float24 floor24( sharedM float24 arg1f24)
                  01602 			;{
                  01603 floor24
                  01604 			;    if (!arg1f24.high8)
                  01605 			;        goto _RETURN_MF;
                  01606 			;
                  01607 			;    uns16 ma = arg1f24.low16;  //  save mantissa
                  01608 			;
                  01609 			;    W = arg1f24.high8 - 127;
                  01610 			;    char tmp = W;      // OPM
                  01611 			;    if (tmp & 0x80)
                  01612 			;        goto FLOOR24ZERO;
                  01613 			;
                  01614 			;    //  save number of zero bits
                  01615 			;    W = 15 - W;
                  01616 			;
                  01617 			;    char tmpa = W;
                  01618 			;    tmp = W;
                  01619 			;
                  01620 			;    if (tmp & 0x8)  // LSB+3		; divide by eight
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 28

ADDR   CODE       LINE  SOURCE

                  01621 			;        goto FLOOR24MASKH;
                  01622 			;
                  01623 			;
                  01624 			;    W = floorMaskTable24( tmpa);    //  get mask
                  01625 			;    arg1f24.low8 &= W;
                  01626 			;    if (!(arg1f24.mid8 & 0x80))  //  if negative, round down
                  01627 			;        goto _RETURN_MF;
                  01628 			;
                  01629 			;    char arg1B7 = W;
                  01630 			;    if (!(arg1f24.low8 - ma.low8))
                  01631 			;        goto _RETURN_MF;
                  01632 			;
                  01633 			;    tmp = ~arg1B7;
                  01634 			;    arg1f24.low8 += tmp + 1;
                  01635 			;    if (Zero_)
                  01636 			;        arg1f24.mid8 += 1;
                  01637 			;
                  01638 			;    //  has rounding caused carryout?
                  01639 			;    if (!Zero_)
                  01640 			;        goto _RETURN_MF;
                  01641 			;    arg1f24.mid8 = rr( arg1f24.mid8);
                  01642 			;    arg1f24.low8 = rr( arg1f24.low8);
                  01643 			;
                  01644 			;    //  check for overflow
                  01645 			;    arg1f24.high8 = incsz( arg1f24.high8);
                  01646 			;    goto _RETURN_MF;
                  01647 			;    goto OVERFLOW;
                  01648 			;
                  01649 			;
                  01650 			;  FLOOR24MASKH:
                  01651 			;    W = floorMaskTable24( tmpa);  //  get mask
                  01652 			;    arg1f24.mid8 &= W;
                  01653 			;    arg1f24.low8 = 0;
                  01654 			;
                  01655 			;    //  if negative, round down
                  01656 			;    if (!(arg1f24.mid8 & 0x80))
                  01657 			;        goto _RETURN_MF;
                  01658 			;
                  01659 			;    arg1B7 = W;
                  01660 			;    if (( arg1f24.low8 - ma.low8) != 0)
                  01661 			;        goto FLOOR24RNDH;
                  01662 			;    if (!(arg1f24.mid8 - ma.mid8))
                  01663 			;        goto _RETURN_MF;
                  01664 			;
                  01665 			;  FLOOR24RNDH:
                  01666 			;    tmp = ~arg1B7;
                  01667 			;    arg1f24.mid8 += tmp + 1;
                  01668 			;
                  01669 			;    //  has rounding caused carryout?
                  01670 			;    if (!Carry)
                  01671 			;        goto _RETURN_MF;
                  01672 			;    arg1f24.mid8 = rr( arg1f24.mid8);
                  01673 			;    arg1f24.low8 = rr( arg1f24.low8);
                  01674 			;
                  01675 			;    //  check for overflow
                  01676 			;    arg1f24.high8 = incsz( arg1f24.high8);
                  01677 			;    goto _RETURN_MF;
                  01678 			;    goto OVERFLOW;
                  01679 			;
                  01680 			;
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 29

ADDR   CODE       LINE  SOURCE

                  01681 			;  FLOOR24ZERO:
                  01682 			;    if (!(arg1f24.mid8 & 0x80))
                  01683 			;        goto RES0;
                  01684 			;    return -1.0;
                  01685 			;
                  01686 			;  RES0:
                  01687 			;    W = 0;
                  01688 			;    goto ASSIGNW;
                  01689 			;
                  01690 			;  OVERFLOW:
                  01691 			;    FpOverflow = 1;
                  01692 			;    W = 0xFF;
                  01693 			;  ASSIGNW:
                  01694 			;    arg1f24.low8 = W;
                  01695 			;    arg1f24.mid8 = W;
                  01696 			;    arg1f24.high8 = W;
                  01697 			;
                  01698 			;  _RETURN_MF:
                  01699 			;    return arg1f24;
                  01700 			;}
                  01701 			;
                  01702 			;
                  01703 			;
                  01704 			;float24 exp10( sharedM float24 arg1f24)
                  01705 			;{
                  01706 exp10
                  01707 			;    sharedM float24 arg2f24;      // allocation 'trick'
                  01708 			;    float24 c, d;
                  01709 			;    char xexp;
                  01710 			;
                  01711 			;    if (( arg1f24.high8 - 100) & 0x80)
                  01712 			;        goto EXP1;   //  return e**x = 1
                  01713 			;
                  01714 			;    W = 132 - arg1f24.high8;
                  01715 			;    if (!Carry)
                  01716 			;        goto _DOMERR;
                  01717 			;    if (!Zero_)
                  01718 			;        goto ARGOK;
                  01719 			;
                  01720 			;    if (!(arg1f24.mid8 & 0x80))  {
                  01721 			;        //  positive domain check
                  01722 			;        W = 26 - arg1f24.mid8;
                  01723 			;        if (!Carry)
                  01724 			;            goto _DOMERR;
                  01725 			;        if (!Zero_)
                  01726 			;            goto ARGOK;
                  01727 			;
                  01728 			;        W = 33 - arg1f24.low8;
                  01729 			;        if (!Carry)
                  01730 			;            goto _DOMERR;
                  01731 			;    }
                  01732 			;    else  {
                  01733 			;
                  01734 			;        W = 151 - arg1f24.mid8;
                  01735 			;        if (!Carry)
                  01736 			;            goto _DOMERR;
                  01737 			;        if (!Zero_)
                  01738 			;            goto ARGOK;
                  01739 			;
                  01740 			;        W = 184 - arg1f24.low8;
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 30

ADDR   CODE       LINE  SOURCE

                  01741 			;        if (!Carry)
                  01742 			;            goto _DOMERR;
                  01743 			;    }
                  01744 			;
                  01745 			;  ARGOK:
                  01746 			;
                  01747 			;    char savedFlags = FpFlags;
                  01748 			;    FpFlags |= 0x40;  //  enable rounding
                  01749 			;
                  01750 			;    c = arg1f24;  //  save x
                  01751 			;    arg1f24 *= 3.32192809489;  //  1/log10(2) = 3.32192809489
                  01752 			;    arg1f24 += 0.5;  //  k = [ x / log10(2) + .5 ]
                  01753 			;    arg1f24 = floor24( arg1f24);
                  01754 			;
                  01755 			;    float24 e = arg1f24; //  save float k
                  01756 			;    FpFlags &= ~0x40;
                  01757 			;    //floating point to integer conversion
                  01758 			;    xexp = arg1f24; //  k = [ x / ln(2) + .5 ]
                  01759 			;    FpFlags |= 0x40;
                  01760 			;    arg1f24 = e * -0.30078125; //  c1
                  01761 			;    d = arg1f24 + c;
                  01762 			;    arg1f24 = e * -2.487456637421670e-04;  // c2
                  01763 			;    arg1f24 += d;
                  01764 			;    d = arg1f24;  //  save f
                  01765 			;
                  01766 			;    if (!(d.mid8 & 0x80))  {
                  01767 			;        // POL32  EXP1032H,5,4   ; minimax approximation on [0,log10(2)/2]
                  01768 			;        arg1f24 *= 6.388992868121E-1;/* EXP1032H5 */
                  01769 			;        arg1f24 += 1.154596329197E0; /* EXP1032H4 */
                  01770 			;        arg1f24 *= d;
                  01771 			;        arg1f24 += 2.035920309947E0; /* EXP1032H3 */
                  01772 			;        arg1f24 *= d;
                  01773 			;        arg1f24 += 2.650909138708E0; /* EXP1032H2 */
                  01774 			;        arg1f24 *= d;
                  01775 			;        arg1f24 += 2.302585504840E0; /* EXP1032H1 */
                  01776 			;    }
                  01777 			;    else  {
                  01778 			;        // POL32 EXP1032L,5,4  ; minimax approximation on [-log10(2)/2,0]
                  01779 			;        arg1f24 *= 4.544952589676E-1;/* EXP1032L5 */
                  01780 			;        arg1f24 += 1.157459289066E0; /* EXP1032L4 */
                  01781 			;        arg1f24 *= d;
                  01782 			;        arg1f24 += 2.033640565225E0; /* EXP1032L3 */
                  01783 			;        arg1f24 *= d;
                  01784 			;        arg1f24 += 2.650914554552E0; /* EXP1032L2 */
                  01785 			;        arg1f24 *= d;
                  01786 			;        arg1f24 += 2.302584716116E0; /* EXP1032L1 */
                  01787 			;    }
                  01788 			;    arg1f24 *= d;
                  01789 			;    if (!(savedFlags & 0x40))
                  01790 			;        FpFlags &= ~0x40;
                  01791 			;    arg1f24 += 1.0; /* EXP1032H0/EXP1032L0 */
                  01792 			;
                  01793 			;    arg1f24.high8 += xexp;
                  01794 			;    goto _RETURN_MF;
                  01795 			;
                  01796 			;  EXP1:
                  01797 			;    arg1f24 = 1.0;   //  return 10**x = 1.0
                  01798 			;    goto _RETURN_MF;
                  01799 			;
                  01800 			;  _DOMERR:
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 31

ADDR   CODE       LINE  SOURCE

                  01801 			;    FpDomainError = 1;   //  domain error
                  01802 			;
                  01803 			;  _RETURN_MF:
                  01804 			;    return arg1f24;
                  01805 			;}
                  01806 			;
                  01807 			;
                  01808 			;
                  01809 			;float24 exp( sharedM float24 arg1f24)
                  01810 			;//     Maximum argument : 88.7228391117 = log(2**128)
                  01811 			;//     Minimum argument : -87.3365447506 = log(2**-126)
                  01812 			;{
                  01813 exp
                  01814 			;    sharedM float24 arg2f24;
                  01815 			;    float24 c, d;
                  01816 			;    char xexp;
                  01817 			;
                  01818 			;    if (( arg1f24.high8 - 94) & 0x80)
                  01819 			;        goto EXP1;   //  return e**x = 1
                  01820 			;
                  01821 			;    W = 133 - arg1f24.high8;
                  01822 			;    if (!Carry)
                  01823 			;        goto _DOMERR;
                  01824 			;    if (!Zero_)
                  01825 			;        goto ARGOK;
                  01826 			;
                  01827 			;    if (!(arg1f24.mid8 & 0x80))  {
                  01828 			;
                  01829 			;        W = 49 - arg1f24.mid8;
                  01830 			;        if (!Carry)
                  01831 			;            goto _DOMERR;
                  01832 			;        if (!Zero_)
                  01833 			;            goto ARGOK;
                  01834 			;
                  01835 			;        W = 114 - arg1f24.midL8;
                  01836 			;        if (!Carry)
                  01837 			;            goto _DOMERR;
                  01838 			;    }
                  01839 			;    else {
                  01840 			;
                  01841 			;        W = 174 - arg1f24.mid8;
                  01842 			;        if (!Carry)
                  01843 			;            goto _DOMERR;
                  01844 			;        if (!Zero_)
                  01845 			;            goto ARGOK;
                  01846 			;
                  01847 			;        W = 172 - arg1f24.midL8;
                  01848 			;        if (!Carry)
                  01849 			;            goto _DOMERR;
                  01850 			;    }
                  01851 			;
                  01852 			;  ARGOK:
                  01853 			;
                  01854 			;    char savedFlags = FpFlags;
                  01855 			;    FpFlags |= 0x40;  //  enable rounding
                  01856 			;
                  01857 			;    c = arg1f24;  //  save x
                  01858 			;    arg1f24 *= 1.44269504089;
                  01859 			;    arg1f24 += 0.5; //  k = [ x / ln(2) + .5 ]
                  01860 			;    arg1f24 = floor24( arg1f24);
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 32

ADDR   CODE       LINE  SOURCE

                  01861 			;
                  01862 			;    float24 e = arg1f24;
                  01863 			;    xexp = arg1f24;   //  k = [ x / ln(2) + .5 ]
                  01864 			;    arg1f24 = e * -0.69140625; // c1
                  01865 			;    d = arg1f24 + c;
                  01866 			;    arg1f24 = e * -1.740930559945286e-03;  // c2
                  01867 			;    arg1f24 += d;
                  01868 			;    d = arg1f24;  //  save f
                  01869 			;
                  01870 			;    if (!(d.mid8 & 0x80))  {
                  01871 			;        // POL32   EXP32H,5,0
                  01872 			;        arg1f24 *= 0.989943653774E-2; /* EXP32H5 */
                  01873 			;        arg1f24 += 0.410473706887E-1; /* EXP32H4 */
                  01874 			;        arg1f24 *= d;
                  01875 			;        arg1f24 += 0.166777360103;    /* EXP32H3 */
                  01876 			;        arg1f24 *= d;
                  01877 			;        arg1f24 += 0.499991163105;    /* EXP32H2 */
                  01878 			;        arg1f24 *= d;
                  01879 			;        arg1f24 += 1.00000025499;     /* EXP32H1 */
                  01880 			;    }
                  01881 			;    else  {
                  01882 			;        // POL32   EXP32L,5,0
                  01883 			;        arg1f24 *= 0.699995870637E-2; /* EXP32L5 */
                  01884 			;        arg1f24 += 0.411548782678E-1; /* EXP32L4 */
                  01885 			;        arg1f24 *= d;
                  01886 			;        arg1f24 += 0.166574299807;    /* EXP32L3 */
                  01887 			;        arg1f24 *= d;
                  01888 			;        arg1f24 += 0.499992371926;    /* EXP32L2 */
                  01889 			;        arg1f24 *= d;
                  01890 			;        arg1f24 += 0.999999766814;    /* EXP32L1 */
                  01891 			;    }
                  01892 			;    arg1f24 *= d;
                  01893 			;    arg1f24 += 1.0;   /* EXP32H0 or EXP32L0 */
                  01894 			;    arg1f24.high8 += xexp;
                  01895 			;
                  01896 			;    if (!(savedFlags & 0x40))
                  01897 			;        FpFlags &= ~0x40;   //  restore rounding flag
                  01898 			;    goto _RETURN_MF;
                  01899 			;
                  01900 			;  EXP1:
                  01901 			;    arg1f24 = 1.0;   //  return 10**x = 1.0
                  01902 			;    goto _RETURN_MF;
                  01903 			;
                  01904 			;  _DOMERR:
                  01905 			;    FpDomainError = 1;   //  domain error
                  01906 			;
                  01907 			;  _RETURN_MF:
                  01908 			;    return arg1f24;
                  01909 			;}
                  01910 			;
                  01911 			;
                  01912 			;
                  01913 			;
                  01914 			;
                  01915 			;
                  01916 			;float24 cosin24( sharedM float24 arg1f24, sharedM float24 arg2f24, char cosinus)
                  01917 			;{
                  01918 cosin24
                  01919 			;    float24 c, d;
                  01920 			;    char j;
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 33

ADDR   CODE       LINE  SOURCE

                  01921 			;
                  01922 			;    char savedFlags = FpFlags;  //  save rounding flag
                  01923 			;    FpFlags |= 0x40;  //  enable rounding
                  01924 			;
                  01925 			;    char csign = 0;    //  initialize sign
                  01926 			;
                  01927 			;    if (!cosinus  &&  (arg1f24.mid8 & 0x80))
                  01928 			;        csign |= 0x80;
                  01929 			;
                  01930 			;    arg1f24.mid8 &= ~0x80;  //  use |x|
                  01931 			;
                  01932 			;    //  loss threshold check
                  01933 			;    // arg1f24 <= +512.0
                  01934 			;    // arg1f24 >= -512.0
                  01935 			;    if (arg1f24.high8 >= 0x88)
                  01936 			;        FpDomainError = 1;   //  domain error
                  01937 			;
                  01938 			;    c = arg1f24;  //  save |x|
                  01939 			;
                  01940 			;    // fixed point multiplication by 4/pi
                  01941 			;    arg1f24 *= 1.27323954474;   // 4/pi
                  01942 			;
                  01943 			;    FpFlags &= ~0x40;
                  01944 			;
                  01945 			;    //  y = [ |x| * (4/pi) ]
                  01946 			;    arg1f24.low16 = arg1f24;  // floating point to integer conversion
                  01947 			;
                  01948 			;    FpFlags |= 0x40;
                  01949 			;
                  01950 			;    if (arg1f24.low8 & 0x1)
                  01951 			;        arg1f24.low16 += 1;  // make arg1f24 even
                  01952 			;
                  01953 			;    //  j = y mod 8
                  01954 			;    j = arg1f24.low8 & 7;  // 0,2,4,6
                  01955 			;    if (j >= 4)  {
                  01956 			;        csign ^= 128;
                  01957 			;        j -= 4;
                  01958 			;    }
                  01959 			;
                  01960 			;    arg1f24 = arg1f24.low16;  // integer to floating point conversion
                  01961 			;
                  01962 			;    //  save y in DARG
                  01963 			;    W = arg1f24.high8;
                  01964 			;    d.high8 = W;
                  01965 			;   #if __CoreSet__ / 100 == 17
                  01966 			;    if (W == 0)  // NB17
                  01967 			;        goto ZEQX;
                  01968 			;   #else
                  01969 			;    if (Zero_)
                  01970 			;        goto ZEQX;
                  01971 			;   #endif
                  01972 			;    d.low16 = arg1f24.low16;
                  01973 			;
                  01974 			;    arg1f24 *= -7.851562500000000e-01;
                  01975 			;    c = arg1f24 + c;    //  z1 = |x| - y * (p1)
                  01976 			;    arg1f24 = d * -2.419133974475018e-04;
                  01977 			;    arg1f24 += c;
                  01978 			;
                  01979 			;    //  save z in c
                  01980 			;    W = arg1f24.high8;  c.high8 = W;  arg2f24.high8 = W;
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 34

ADDR   CODE       LINE  SOURCE

                  01981 			;    W = arg1f24.mid8;   c.mid8 = W;   arg2f24.mid8 = W;
                  01982 			;    W = arg1f24.low8;   c.low8 = W;   arg2f24.low8 = W;
                  01983 			;
                  01984 			;    goto POLYNOM;
                  01985 			;
                  01986 			;   ZEQX:
                  01987 			;    W = c.high8;  arg1f24.high8 = W;  arg2f24.high8 = W;
                  01988 			;    W = c.mid8;   arg1f24.mid8 = W;   arg2f24.mid8 = W;
                  01989 			;    W = c.low8;   arg1f24.low8 = W;   arg2f24.low8 = W;
                  01990 			;
                  01991 			;   POLYNOM:
                  01992 			;
                  01993 			;    arg1f24 *= arg2f24;   // z * z
                  01994 			;    d = arg1f24;   //  save z * z
                  01995 			;
                  01996 			;    if ((( rr( j) ^ j) & 0x1) ^ cosinus)  {
                  01997 			;        // POL24  COS24,3,0
                  01998 			;
                  01999 			;        arg1f24 *= -1.35859090e-03;  // 117,178,18,191
                  02000 			;        arg1f24 += 4.16550264e-02;   // 122,42,158,118
                  02001 			;        arg1f24 *= d;
                  02002 			;        arg1f24 += -4.99998569e-01;  // 125,255,255,208
                  02003 			;        arg1f24 *= d;
                  02004 			;        arg1f24 += 1.0;
                  02005 			;    }
                  02006 			;    else  {
                  02007 			;        /// POL24  SIN24,2,0
                  02008 			;        arg1f24 *= 8.12155753e-03;   // 120,5,16,72
                  02009 			;        arg1f24 += -1.66601613e-01;  // 124,170,153,157
                  02010 			;        arg1f24 *= d;
                  02011 			;        arg1f24 += 9.99994993e-01;   // 126,127,255,172
                  02012 			;        arg1f24 *= c;
                  02013 			;    }
                  02014 			;
                  02015 			;    W = 128;  // LSB+1
                  02016 			;    if (cosinus  &&  (j & 0x2))   // NB17
                  02017 			;        csign ^= W;
                  02018 			;    if (csign & 0x80)
                  02019 			;        arg1f24.mid8 ^= W;
                  02020 			;
                  02021 			;    if (savedFlags & 0x40)
                  02022 			;        FpFlags |= 0x40;  //  restore rounding flag
                  02023 			;    return arg1f24;
                  02024 			;}
                  02025 			;
                  02026 			;
                  02027 			;float24 cos( sharedM float24 arg1f24)
                  02028 			;{
                  02029 cos
                  02030 			;    sharedM float24 arg2f24;      // allocation 'trick'
                  02031 			;    arg1f24 = cosin24( arg1f24, arg2f24, 1);
                  02032 			;    return arg1f24;
                  02033 			;}
                  02034 			;
                  02035 			;
                  02036 			;float24 sin( sharedM float24 arg1f24)
                  02037 			;{
                  02038 sin
                  02039 			;    sharedM float24 arg2f24;      // allocation 'trick'
                  02040 			;    arg1f24 = cosin24( arg1f24, arg2f24, 0);
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 35

ADDR   CODE       LINE  SOURCE

                  02041 			;    return arg1f24;
                  02042 			;}
                  02043 			;
                  02044 			;
                  02045 			;
                  02046 			;#if !defined __CC8EFREE__
                  02047 			;
                  02048 			;float24 sqrt( float24 arg)
                  02049 			;// Copyright (c) Jim van Zee, Seattle, WA., 2004
                  02050 			;{
                  02051 			;    uns8 arg_exp @ arg.high8;    // arg exponent (offset by FpBIAS)
                  02052 			;    uns24 root = 0;              // result (treated as an integer)
                  02053 			;    float24 sqrtf @ root;        // result (treated as a float)
                  02054 			;    uns24 remain;
                  02055 			;    uns8 nr_bits;
                  02056 			;
                  02057 			;    if (arg.mid8 & 0x80) {  // test for negative argument
                  02058 			;        FpDomainError=1;
                  02059 			;        goto END;           // negative #s return '0'
                  02060 			;    }
                  02061 			;    if (!arg_exp)
                  02062 			;        goto END;           // 0->0 (all bytes are 0)
                  02063 			;
                  02064 			;    arg.15 = 1;             // restore hidden bit
                  02065 			;    remain = 0;             // clear remainder
                  02066 			;    nr_bits = 16;           // initialize bit count
                  02067 			;
                  02068 			;    // Here's a 'tricky bit': 'even' exponents work out OK, but 'odd'
                  02069 			;    // exponents need one less shift initially in order to align the
                  02070 			;    // bits in a 'powers-of-four' pattern (two-bits-at-a-time).
                  02071 			;
                  02072 			;    btss(arg_exp.0);          // skip if exponent is odd
                  02073 			;    do {
                  02074 			;        remain.23=1;          // set 2x shift flag
                  02075 			;        root = rl(root);        // exponent= 'spill byte'
                  02076 			;        root.0=1;               // add '1' to form '2N+1'
                  02077 			;        root.1=0;               // clear next root bit
                  02078 			;        do {
                  02079 			;            arg.low16 = rl(arg.low16); // shift mantissa into 'remain'
                  02080 			;            remain = rl(remain);       // two-bits-at-a-time (add 0's)
                  02081 			;        } while(Carry);         // Carry=1 the first time
                  02082 			;        arg.0=0;                // clear the carry-in bit
                  02083 			;
                  02084 			;        // now compare root and remainder; if remain >= root, subtract
                  02085 			;        // to get the new remainder & set bit=1; otherwise leave bit=0.
                  02086 			;
                  02087 			;        //        if (remain >= root) // 3-byte compare
                  02088 			;        //        {   remain -= root; // update remainder
                  02089 			;        //            root.1 = 1;   } // set this bit = 1
                  02090 			;
                  02091 			;        W = remain.low8 - root.low8;  // compare remain w/root
                  02092 			;        genSubW( remain.mid8, root.mid8);
                  02093 			;        genSubW( remain.high8, root.high8);
                  02094 			;
                  02095 			;        // If remain >= root, the next bit is '1', otherwise '0'
                  02096 			;        if (Carry) {          // remain -= root;
                  02097 			;            remain.high8 = W;   // save 'spill byte'
                  02098 			;            remain.low8 -= root.low8;   // do subtraction
                  02099 			;            genSub( remain.mid8, root.mid8);
                  02100 			;            root.1 = 1; // note: lsb is bit1, not bit0!
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 36

ADDR   CODE       LINE  SOURCE

                  02101 			;        }
                  02102 			;
                  02103 			;    } while (--nr_bits); // 16 bit mantissa
                  02104 			;
                  02105 			;    // Finally unshift root (only need to do 16 bits, since msb->0!)
                  02106 			;    root.low16 = rr(root.low16);       // '2N+1' -> 'N'
                  02107 			;    root.15 = 0;            // clear hidden bit
                  02108 			;
                  02109 			;    // and set exponent = arg_exp/2 (we used this as the spill byte)
                  02110 			;    arg_exp += FpBIAS;      // double the bias
                  02111 			;    root.high8=rr(arg_exp); // root exp = arg_exp/2+FpBIAS
                  02112 			;  END:
                  02113 			;    return sqrtf;           // neg & zero args return 0
                  02114 			;}
                  02115 			;
                  02116 			;#else
                  02117 			;
                  02118 			;float24 sqrt( sharedM float24 arg1f24)
                  02119 			;{
                  02120 sqrt
                  02121 			;    sharedM float24 arg2f24;      // allocation 'trick'
                  02122 			;
                  02123 			;    if (arg1f24.mid8 & 0x80)     // test for negative argument
                  02124 			;        goto _DOMERR;
                  02125 			;    if (!arg1f24.high8)          // return if argument zero
                  02126 			;        goto _RETURN_MF;
                  02127 			;
                  02128 			;    char cexp = arg1f24.high8;    // save exponent
                  02129 			;    char savedFLAGS = FpFlags;
                  02130 			;    FpFlags |= 0x40;           // enable rounding
                  02131 			;
                  02132 			;    arg1f24.high8 = FpBIAS;   // compute z
                  02133 			;    float24 d = arg1f24;
                  02134 			;
                  02135 			;    if (arg1f24.mid8 & 0x40)  {
                  02136 			;        // POL24  SQRT24H,4,0
                  02137 			;        arg1f24 *= -5.6351436252E-3;  // SQRT24H4
                  02138 			;        arg1f24 += 5.5047377031E-2; // SQRT24H3
                  02139 			;        arg1f24 *= d;
                  02140 			;        arg1f24 += -2.3944355047E-1;  // SQRT24H2
                  02141 			;        arg1f24 *= d;
                  02142 			;        arg1f24 += 8.3106978456E-1; // SQRT24H1
                  02143 			;        arg1f24 *= d;
                  02144 			;        arg1f24 += 3.5963132863E-1;  // SQRT24H0
                  02145 			;    }
                  02146 			;    else  {
                  02147 			;        // POL24  SQRT24L,4,0
                  02148 			;        arg1f24 *= -1.8702682470E-2;  // SQRT24L4
                  02149 			;        arg1f24 += 1.3009144111E-1; // SQRT24L3
                  02150 			;        arg1f24 *= d;
                  02151 			;        arg1f24 += -4.0192034196E-1;  // SQRT24L2
                  02152 			;        arg1f24 *= d;
                  02153 			;        arg1f24 += 9.8831235597E-1;  // SQRT24L1
                  02154 			;        arg1f24 *= d;
                  02155 			;        arg1f24 += 3.0221977303E-1;  // SQRT24L0
                  02156 			;    }
                  02157 			;
                  02158 			;    if (!(cexp & 0x1))      // is cexp even or odd?
                  02159 			;        arg1f24 *= 1.41421356237;  // sqrt(2)
                  02160 			;
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 37

ADDR   CODE       LINE  SOURCE

                  02161 			;    // divide exponent by two
                  02162 			;    cexp += 127;
                  02163 			;    arg1f24.high8 = rr( cexp);
                  02164 			;
                  02165 			;    if (!(savedFLAGS & 0x40))
                  02166 			;        FpFlags &= ~0x40;
                  02167 			;
                  02168 			;    goto _RETURN_MF;
                  02169 			;
                  02170 			;  _DOMERR:
                  02171 			;    FpDomainError = 1;   //  domain error
                  02172 			;
                  02173 			;  _RETURN_MF:
                  02174 			;    return arg1f24;
                  02175 
                  02176   ; FILE LCD_4bit.h
                  02177 			;
                  02178 			;bit ENGlobal,RSGlobal,data0Global,data1Global,data2Global,data3Global;
                  02179 			;
                  02180 			;void lcdBegin(bit EN,bit RS,bit data0,bit data1,bit data2,bit data3){
                  02181 lcdBegin
                  02182 			;
                  02183 			;
                  02184 			;}
00018C 0012       02185 	RETURN
                  02186 			;
                  02187 			;
                  02188 			;void envia_codigo_inicial (char codigo)
                  02189 			;{
                  02190 envia_codigo_inicial
00018E 0100       02191 	MOVLB 0
000190 6F6E       02192 	MOVWF codigo,1
                  02193 			;	PORTB.4=0;nop();
000192 9881       02194 	BCF   PORTB,4,0
000194 0000       02195 	NOP  
                  02196 			;	PORTB.0 = codigo.4;
000196 A96E       02197 	BTFSS codigo,4,1
000198 9081       02198 	BCF   PORTB,0,0
00019A B96E       02199 	BTFSC codigo,4,1
00019C 8081       02200 	BSF   PORTB,0,0
                  02201 			;	nop();
00019E 0000       02202 	NOP  
                  02203 			;	PORTB.1 = codigo.5;
0001A0 AB6E       02204 	BTFSS codigo,5,1
0001A2 9281       02205 	BCF   PORTB,1,0
0001A4 BB6E       02206 	BTFSC codigo,5,1
0001A6 8281       02207 	BSF   PORTB,1,0
                  02208 			;	nop();
0001A8 0000       02209 	NOP  
                  02210 			;	PORTB.2 = codigo.6;
0001AA AD6E       02211 	BTFSS codigo,6,1
0001AC 9481       02212 	BCF   PORTB,2,0
0001AE BD6E       02213 	BTFSC codigo,6,1
0001B0 8481       02214 	BSF   PORTB,2,0
                  02215 			;	nop();
0001B2 0000       02216 	NOP  
                  02217 			;	PORTB.3 = codigo.7;
0001B4 AF6E       02218 	BTFSS codigo,7,1
0001B6 9681       02219 	BCF   PORTB,3,0
0001B8 BF6E       02220 	BTFSC codigo,7,1
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 38

ADDR   CODE       LINE  SOURCE

0001BA 8681       02221 	BSF   PORTB,3,0
                  02222 			;	nop();
0001BC 0000       02223 	NOP  
                  02224 			;	PORTB.5 = 1; 
0001BE 8A81       02225 	BSF   PORTB,5,0
                  02226 			;	retardo_20u();
0001C0 DFA0       02227 	RCALL retardo_20u
                  02228 			;	PORTB.5 = 0; 
0001C2 9A81       02229 	BCF   PORTB,5,0
                  02230 			;	
                  02231 			;	
                  02232 			;	
                  02233 			;	return;
0001C4 0012       02234 	RETURN
                  02235 			;}
                  02236 			; 
                  02237 			;void enviar_comando (char comando) 
                  02238 			;{
                  02239 enviar_comando
0001C6 0100       02240 	MOVLB 0
0001C8 6F6E       02241 	MOVWF comando,1
                  02242 			;	
                  02243 			;	PORTB.0 =  comando.4;nop();
0001CA A96E       02244 	BTFSS comando,4,1
0001CC 9081       02245 	BCF   PORTB,0,0
0001CE B96E       02246 	BTFSC comando,4,1
0001D0 8081       02247 	BSF   PORTB,0,0
0001D2 0000       02248 	NOP  
                  02249 			;	PORTB.1 =  comando.5;nop();
0001D4 AB6E       02250 	BTFSS comando,5,1
0001D6 9281       02251 	BCF   PORTB,1,0
0001D8 BB6E       02252 	BTFSC comando,5,1
0001DA 8281       02253 	BSF   PORTB,1,0
0001DC 0000       02254 	NOP  
                  02255 			;	PORTB.2 =  comando.6;nop();
0001DE AD6E       02256 	BTFSS comando,6,1
0001E0 9481       02257 	BCF   PORTB,2,0
0001E2 BD6E       02258 	BTFSC comando,6,1
0001E4 8481       02259 	BSF   PORTB,2,0
0001E6 0000       02260 	NOP  
                  02261 			;	PORTB.3 =  comando.7;
0001E8 AF6E       02262 	BTFSS comando,7,1
0001EA 9681       02263 	BCF   PORTB,3,0
0001EC BF6E       02264 	BTFSC comando,7,1
0001EE 8681       02265 	BSF   PORTB,3,0
                  02266 			;	retardo_1m ();
0001F0 DF92       02267 	RCALL retardo_1m
                  02268 			;	PORTB.4 = 0;  									// Modo comando.
0001F2 9881       02269 	BCF   PORTB,4,0
                  02270 			;	retardo_20u (); //
0001F4 DF86       02271 	RCALL retardo_20u
                  02272 			;	PORTB.5 = 1;  									// Breve pulso.
0001F6 8A81       02273 	BSF   PORTB,5,0
                  02274 			;	retardo_20u ();
0001F8 DF84       02275 	RCALL retardo_20u
                  02276 			;	PORTB.5 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
0001FA 9A81       02277 	BCF   PORTB,5,0
                  02278 			;	retardo_1m ();
0001FC DF8C       02279 	RCALL retardo_1m
                  02280 			;	retardo_1m ();
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 39

ADDR   CODE       LINE  SOURCE

0001FE DF8B       02281 	RCALL retardo_1m
                  02282 			;	comando = swap (comando);
000200 0100       02283 	MOVLB 0
000202 3B6E       02284 	SWAPF comando,1,1
                  02285 			;	PORTB.0 =  comando.4;nop();
000204 A96E       02286 	BTFSS comando,4,1
000206 9081       02287 	BCF   PORTB,0,0
000208 B96E       02288 	BTFSC comando,4,1
00020A 8081       02289 	BSF   PORTB,0,0
00020C 0000       02290 	NOP  
                  02291 			;	PORTB.1 =  comando.5;nop();
00020E AB6E       02292 	BTFSS comando,5,1
000210 9281       02293 	BCF   PORTB,1,0
000212 BB6E       02294 	BTFSC comando,5,1
000214 8281       02295 	BSF   PORTB,1,0
000216 0000       02296 	NOP  
                  02297 			;	PORTB.2 =  comando.6;nop();
000218 AD6E       02298 	BTFSS comando,6,1
00021A 9481       02299 	BCF   PORTB,2,0
00021C BD6E       02300 	BTFSC comando,6,1
00021E 8481       02301 	BSF   PORTB,2,0
000220 0000       02302 	NOP  
                  02303 			;	PORTB.3 =  comando.7;nop();
000222 AF6E       02304 	BTFSS comando,7,1
000224 9681       02305 	BCF   PORTB,3,0
000226 BF6E       02306 	BTFSC comando,7,1
000228 8681       02307 	BSF   PORTB,3,0
00022A 0000       02308 	NOP  
                  02309 			;	retardo_1m ();
00022C DF74       02310 	RCALL retardo_1m
                  02311 			;	PORTB.4 = 0;  									// Modo comando.
00022E 9881       02312 	BCF   PORTB,4,0
                  02313 			;	retardo_20u ();
000230 DF68       02314 	RCALL retardo_20u
                  02315 			;	PORTB.5 = 1;  									// Breve pulso.
000232 8A81       02316 	BSF   PORTB,5,0
                  02317 			;	retardo_20u ();
000234 DF66       02318 	RCALL retardo_20u
                  02319 			;	PORTB.5 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
000236 9A81       02320 	BCF   PORTB,5,0
                  02321 			;	retardo_1m ();
000238 DF6E       02322 	RCALL retardo_1m
                  02323 			;	retardo_1m ();
00023A D76D       02324 	BRA   retardo_1m
                  02325 			;	//leds_OFF (10);
                  02326 			;	
                  02327 			;	
                  02328 			;	return;
                  02329 			;}    
                  02330 			;
                  02331 			;void enviar_literal (char dato) 
                  02332 			;{
                  02333 enviar_literal
00023C 6E7F       02334 	MOVWF dato,0
                  02335 			;    char i;
                  02336 			;
                  02337 			;	
                  02338 			;	PORTB.0 = dato.4;
00023E A87F       02339 	BTFSS dato,4,0
000240 9081       02340 	BCF   PORTB,0,0
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 40

ADDR   CODE       LINE  SOURCE

000242 B87F       02341 	BTFSC dato,4,0
000244 8081       02342 	BSF   PORTB,0,0
                  02343 			;	nop();
000246 0000       02344 	NOP  
                  02345 			;	PORTB.1 = dato.5;
000248 AA7F       02346 	BTFSS dato,5,0
00024A 9281       02347 	BCF   PORTB,1,0
00024C BA7F       02348 	BTFSC dato,5,0
00024E 8281       02349 	BSF   PORTB,1,0
                  02350 			;	nop();
000250 0000       02351 	NOP  
                  02352 			;	PORTB.2 = dato.6;
000252 AC7F       02353 	BTFSS dato,6,0
000254 9481       02354 	BCF   PORTB,2,0
000256 BC7F       02355 	BTFSC dato,6,0
000258 8481       02356 	BSF   PORTB,2,0
                  02357 			;	nop();
00025A 0000       02358 	NOP  
                  02359 			;	PORTB.3 = dato.7;
00025C AE7F       02360 	BTFSS dato,7,0
00025E 9681       02361 	BCF   PORTB,3,0
000260 BE7F       02362 	BTFSC dato,7,0
000262 8681       02363 	BSF   PORTB,3,0
                  02364 			;	nop();
000264 0000       02365 	NOP  
                  02366 			;	PORTB.4 = 1;  									// Modo dato.
000266 8881       02367 	BSF   PORTB,4,0
                  02368 			;	retardo_20u ();
000268 DF4C       02369 	RCALL retardo_20u
                  02370 			;	PORTB.5 = 1;  									// Breve pulso.
00026A 8A81       02371 	BSF   PORTB,5,0
                  02372 			;	retardo_20u ();
00026C DF4A       02373 	RCALL retardo_20u
                  02374 			;	PORTB.5 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
00026E 9A81       02375 	BCF   PORTB,5,0
                  02376 			;	for (i = 1; i <= 6; i++) retardo_20u ();
000270 0E01       02377 	MOVLW 1
000272 6E7F       02378 	MOVWF i_3,0
000274 0E07       02379 m026	MOVLW 7
000276 607F       02380 	CPFSLT i_3,0
000278 D003       02381 	BRA   m027
00027A DF43       02382 	RCALL retardo_20u
00027C 2A7F       02383 	INCF  i_3,1,0
00027E D7FA       02384 	BRA   m026
                  02385 			;	dato = swap (dato);
000280 3A7F       02386 m027	SWAPF dato,1,0
                  02387 			;	PORTB.0 = dato.4;nop();
000282 A87F       02388 	BTFSS dato,4,0
000284 9081       02389 	BCF   PORTB,0,0
000286 B87F       02390 	BTFSC dato,4,0
000288 8081       02391 	BSF   PORTB,0,0
00028A 0000       02392 	NOP  
                  02393 			;	PORTB.1 = dato.5;nop();
00028C AA7F       02394 	BTFSS dato,5,0
00028E 9281       02395 	BCF   PORTB,1,0
000290 BA7F       02396 	BTFSC dato,5,0
000292 8281       02397 	BSF   PORTB,1,0
000294 0000       02398 	NOP  
                  02399 			;	PORTB.2 = dato.6;nop();
000296 AC7F       02400 	BTFSS dato,6,0
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 41

ADDR   CODE       LINE  SOURCE

000298 9481       02401 	BCF   PORTB,2,0
00029A BC7F       02402 	BTFSC dato,6,0
00029C 8481       02403 	BSF   PORTB,2,0
00029E 0000       02404 	NOP  
                  02405 			;	PORTB.3 = dato.7;nop();
0002A0 AE7F       02406 	BTFSS dato,7,0
0002A2 9681       02407 	BCF   PORTB,3,0
0002A4 BE7F       02408 	BTFSC dato,7,0
0002A6 8681       02409 	BSF   PORTB,3,0
0002A8 0000       02410 	NOP  
                  02411 			;	retardo_1m ();
0002AA DF35       02412 	RCALL retardo_1m
                  02413 			;	PORTB.4 = 1;  									// Modo dato.
0002AC 8881       02414 	BSF   PORTB,4,0
                  02415 			;	retardo_1m ();
0002AE DF33       02416 	RCALL retardo_1m
                  02417 			;	PORTB.5 = 1;  									// Breve pulso.
0002B0 8A81       02418 	BSF   PORTB,5,0
                  02419 			;	retardo_20u ();
0002B2 DF27       02420 	RCALL retardo_20u
                  02421 			;	PORTB.5 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
0002B4 9A81       02422 	BCF   PORTB,5,0
                  02423 			;	for (i = 1; i<= 6; i++) retardo_20u ();
0002B6 0E01       02424 	MOVLW 1
0002B8 6E7F       02425 	MOVWF i_3,0
0002BA 0E07       02426 m028	MOVLW 7
0002BC 607F       02427 	CPFSLT i_3,0
0002BE D003       02428 	BRA   m029
0002C0 DF20       02429 	RCALL retardo_20u
0002C2 2A7F       02430 	INCF  i_3,1,0
0002C4 D7FA       02431 	BRA   m028
                  02432 			;	enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.	
0002C6 0E0C       02433 m029	MOVLW 12
0002C8 D77E       02434 	BRA   enviar_comando
                  02435 			;	return;
                  02436 			;}   
                  02437 			;
                  02438 			;void enviar_cifra (char dato) 
                  02439 			;{
                  02440 enviar_cifra
0002CA 6E7F       02441 	MOVWF dato_2,0
                  02442 			;    char i;
                  02443 			;	dato = dato + 0x30; 							// Convierto el nmero en su equivalente ASCII literal. 
0002CC 0E30       02444 	MOVLW 48
0002CE 267F       02445 	ADDWF dato_2,1,0
                  02446 			;	PORTB.0 = dato.4;
0002D0 A87F       02447 	BTFSS dato_2,4,0
0002D2 9081       02448 	BCF   PORTB,0,0
0002D4 B87F       02449 	BTFSC dato_2,4,0
0002D6 8081       02450 	BSF   PORTB,0,0
                  02451 			;	nop();
0002D8 0000       02452 	NOP  
                  02453 			;	PORTB.1 = dato.5;
0002DA AA7F       02454 	BTFSS dato_2,5,0
0002DC 9281       02455 	BCF   PORTB,1,0
0002DE BA7F       02456 	BTFSC dato_2,5,0
0002E0 8281       02457 	BSF   PORTB,1,0
                  02458 			;	nop();
0002E2 0000       02459 	NOP  
                  02460 			;	PORTB.2 = dato.6;
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 42

ADDR   CODE       LINE  SOURCE

0002E4 AC7F       02461 	BTFSS dato_2,6,0
0002E6 9481       02462 	BCF   PORTB,2,0
0002E8 BC7F       02463 	BTFSC dato_2,6,0
0002EA 8481       02464 	BSF   PORTB,2,0
                  02465 			;	nop();
0002EC 0000       02466 	NOP  
                  02467 			;	PORTB.3 = dato.7;
0002EE AE7F       02468 	BTFSS dato_2,7,0
0002F0 9681       02469 	BCF   PORTB,3,0
0002F2 BE7F       02470 	BTFSC dato_2,7,0
0002F4 8681       02471 	BSF   PORTB,3,0
                  02472 			;	nop();
0002F6 0000       02473 	NOP  
                  02474 			;	PORTB.4 = 1;  									// Modo dato.
0002F8 8881       02475 	BSF   PORTB,4,0
                  02476 			;	retardo_20u ();
0002FA DF03       02477 	RCALL retardo_20u
                  02478 			;	PORTB.5 = 1;  									// Breve pulso.
0002FC 8A81       02479 	BSF   PORTB,5,0
                  02480 			;	retardo_20u ();
0002FE DF01       02481 	RCALL retardo_20u
                  02482 			;	PORTB.5 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
000300 9A81       02483 	BCF   PORTB,5,0
                  02484 			;	for (i = 1; i <= 6; i++) retardo_20u ();
000302 0E01       02485 	MOVLW 1
000304 6E7F       02486 	MOVWF i_4,0
000306 0E07       02487 m030	MOVLW 7
000308 607F       02488 	CPFSLT i_4,0
00030A D003       02489 	BRA   m031
00030C DEFA       02490 	RCALL retardo_20u
00030E 2A7F       02491 	INCF  i_4,1,0
000310 D7FA       02492 	BRA   m030
                  02493 			;	dato = swap (dato);
000312 3A7F       02494 m031	SWAPF dato_2,1,0
                  02495 			;	PORTB.0 = dato.4;
000314 A87F       02496 	BTFSS dato_2,4,0
000316 9081       02497 	BCF   PORTB,0,0
000318 B87F       02498 	BTFSC dato_2,4,0
00031A 8081       02499 	BSF   PORTB,0,0
                  02500 			;	nop();
00031C 0000       02501 	NOP  
                  02502 			;	PORTB.1 = dato.5;
00031E AA7F       02503 	BTFSS dato_2,5,0
000320 9281       02504 	BCF   PORTB,1,0
000322 BA7F       02505 	BTFSC dato_2,5,0
000324 8281       02506 	BSF   PORTB,1,0
                  02507 			;	nop();
000326 0000       02508 	NOP  
                  02509 			;	PORTB.2 = dato.6;
000328 AC7F       02510 	BTFSS dato_2,6,0
00032A 9481       02511 	BCF   PORTB,2,0
00032C BC7F       02512 	BTFSC dato_2,6,0
00032E 8481       02513 	BSF   PORTB,2,0
                  02514 			;	nop();
000330 0000       02515 	NOP  
                  02516 			;	PORTB.3 = dato.7;
000332 AE7F       02517 	BTFSS dato_2,7,0
000334 9681       02518 	BCF   PORTB,3,0
000336 BE7F       02519 	BTFSC dato_2,7,0
000338 8681       02520 	BSF   PORTB,3,0
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 43

ADDR   CODE       LINE  SOURCE

                  02521 			;	retardo_1m ();
00033A DEED       02522 	RCALL retardo_1m
                  02523 			;	PORTB.4 = 1;  									// Modo dato.
00033C 8881       02524 	BSF   PORTB,4,0
                  02525 			;	retardo_1m ();
00033E DEEB       02526 	RCALL retardo_1m
                  02527 			;	PORTB.5 = 1;  									// Breve pulso.
000340 8A81       02528 	BSF   PORTB,5,0
                  02529 			;	retardo_20u ();
000342 DEDF       02530 	RCALL retardo_20u
                  02531 			;	PORTB.5 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
000344 9A81       02532 	BCF   PORTB,5,0
                  02533 			;	for (i = 1; i<= 6; i++) retardo_20u ();
000346 0E01       02534 	MOVLW 1
000348 6E7F       02535 	MOVWF i_4,0
00034A 0E07       02536 m032	MOVLW 7
00034C 607F       02537 	CPFSLT i_4,0
00034E D003       02538 	BRA   m033
000350 DED8       02539 	RCALL retardo_20u
000352 2A7F       02540 	INCF  i_4,1,0
000354 D7FA       02541 	BRA   m032
                  02542 			;	enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.
000356 0E0C       02543 m033	MOVLW 12
000358 D736       02544 	BRA   enviar_comando
                  02545 			;	return;
                  02546 			;} 
                  02547 			;
                  02548 			;void inicializar_lcd (void) 
                  02549 			;{
                  02550 inicializar_lcd
                  02551 			;	char i;
                  02552 			;	clrwdt () ;	
00035A 0004       02553 	CLRWDT
                  02554 			;	for (i = 1; i < 21; i++) retardo_1m ();    
00035C 0E01       02555 	MOVLW 1
00035E 0100       02556 	MOVLB 0
000360 6F6D       02557 	MOVWF i_5,1
000362 0E15       02558 m034	MOVLW 21
000364 0100       02559 	MOVLB 0
000366 616D       02560 	CPFSLT i_5,1
000368 D004       02561 	BRA   m035
00036A DED5       02562 	RCALL retardo_1m
00036C 0100       02563 	MOVLB 0
00036E 2B6D       02564 	INCF  i_5,1,1
000370 D7F8       02565 	BRA   m034
                  02566 			;	envia_codigo_inicial (0b.00.11.0000);
000372 0E30       02567 m035	MOVLW 48
000374 DF0C       02568 	RCALL envia_codigo_inicial
                  02569 			;	for (i = 1; i < 6; i++) retardo_1m ();
000376 0E01       02570 	MOVLW 1
000378 0100       02571 	MOVLB 0
00037A 6F6D       02572 	MOVWF i_5,1
00037C 0E06       02573 m036	MOVLW 6
00037E 0100       02574 	MOVLB 0
000380 616D       02575 	CPFSLT i_5,1
000382 D004       02576 	BRA   m037
000384 DEC8       02577 	RCALL retardo_1m
000386 0100       02578 	MOVLB 0
000388 2B6D       02579 	INCF  i_5,1,1
00038A D7F8       02580 	BRA   m036
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 44

ADDR   CODE       LINE  SOURCE

                  02581 			;    envia_codigo_inicial (0b.00.11.0000);	
00038C 0E30       02582 m037	MOVLW 48
00038E DEFF       02583 	RCALL envia_codigo_inicial
                  02584 			;	for (i = 1; i< 11; i++) retardo_20u ();
000390 0E01       02585 	MOVLW 1
000392 0100       02586 	MOVLB 0
000394 6F6D       02587 	MOVWF i_5,1
000396 0E0B       02588 m038	MOVLW 11
000398 0100       02589 	MOVLB 0
00039A 616D       02590 	CPFSLT i_5,1
00039C D004       02591 	BRA   m039
00039E DEB1       02592 	RCALL retardo_20u
0003A0 0100       02593 	MOVLB 0
0003A2 2B6D       02594 	INCF  i_5,1,1
0003A4 D7F8       02595 	BRA   m038
                  02596 			;    envia_codigo_inicial (0b.00.11.0000);
0003A6 0E30       02597 m039	MOVLW 48
0003A8 DEF2       02598 	RCALL envia_codigo_inicial
                  02599 			;	for (i = 1; i < 11; i++) retardo_20u ();
0003AA 0E01       02600 	MOVLW 1
0003AC 0100       02601 	MOVLB 0
0003AE 6F6D       02602 	MOVWF i_5,1
0003B0 0E0B       02603 m040	MOVLW 11
0003B2 0100       02604 	MOVLB 0
0003B4 616D       02605 	CPFSLT i_5,1
0003B6 D004       02606 	BRA   m041
0003B8 DEA4       02607 	RCALL retardo_20u
0003BA 0100       02608 	MOVLB 0
0003BC 2B6D       02609 	INCF  i_5,1,1
0003BE D7F8       02610 	BRA   m040
                  02611 			;	envia_codigo_inicial (0b.00.10.0000);			// A 4 bits.
0003C0 0E20       02612 m041	MOVLW 32
0003C2 DEE5       02613 	RCALL envia_codigo_inicial
                  02614 			;	enviar_comando (0b.0010.1000);					// A 4 bits, doble lnea, caracteres 5x7.
0003C4 0E28       02615 	MOVLW 40
0003C6 DEFF       02616 	RCALL enviar_comando
                  02617 			;	enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.
0003C8 0E0C       02618 	MOVLW 12
0003CA DEFD       02619 	RCALL enviar_comando
                  02620 			;	enviar_comando (0b.0000.0010);  				// Cursor en home, inicio de primera linea.
0003CC 0E02       02621 	MOVLW 2
0003CE D6FB       02622 	BRA   enviar_comando
                  02623 			;	return;
                  02624 			;}
                  02625 			;
                  02626 			;void escribir_posicion (char linea, char columna)
                  02627 			;{
                  02628 escribir_posicion
0003D0 6E7F       02629 	MOVWF columna,0
                  02630 			;	
                  02631 			;	switch (linea) 									// (se resta una unidad a la coordenada lnea para que la posicin colum
                           na inicial sea 1 y no 0).
0003D2 507F       02632 	MOVF  linea,W,0
0003D4 0A01       02633 	XORLW 1
0003D6 B4D8       02634 	BTFSC 0xFD8,Zero_,0
0003D8 D00A       02635 	BRA   m042
0003DA 0A03       02636 	XORLW 3
0003DC B4D8       02637 	BTFSC 0xFD8,Zero_,0
0003DE D00B       02638 	BRA   m043
0003E0 0A01       02639 	XORLW 1
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 45

ADDR   CODE       LINE  SOURCE

0003E2 B4D8       02640 	BTFSC 0xFD8,Zero_,0
0003E4 D00C       02641 	BRA   m044
0003E6 0A07       02642 	XORLW 7
0003E8 B4D8       02643 	BTFSC 0xFD8,Zero_,0
0003EA D00D       02644 	BRA   m045
0003EC D012       02645 	BRA   m046
                  02646 			;		{
                  02647 			;			case 1:
                  02648 			;				enviar_comando (127 + columna); 	// Inicio primera linea.
0003EE 0E7F       02649 m042	MOVLW 127
0003F0 247F       02650 	ADDWF columna,W,0
0003F2 DEE9       02651 	RCALL enviar_comando
                  02652 			;			break;
0003F4 D00E       02653 	BRA   m046
                  02654 			;						
                  02655 			;			case 2:
                  02656 			;				enviar_comando (191 + columna); 	// Inicio segunda lnea.
0003F6 0EBF       02657 m043	MOVLW 191
0003F8 247F       02658 	ADDWF columna,W,0
0003FA DEE5       02659 	RCALL enviar_comando
                  02660 			;			break;			
0003FC D00A       02661 	BRA   m046
                  02662 			;
                  02663 			;			case 3:
                  02664 			;				enviar_comando (147 + columna);		// Inicio tercera lnea (cursor en posicin 20 de la primera lnea).
0003FE 0E93       02665 m044	MOVLW 147
000400 247F       02666 	ADDWF columna,W,0
000402 DEE1       02667 	RCALL enviar_comando
                  02668 			;			break;				
000404 D006       02669 	BRA   m046
                  02670 			;			
                  02671 			;			case 4:
                  02672 			;				enviar_comando (211 + columna); 	// Inicio cuarta lnea (cursor en posicin 20 de la segunda lnea).
000406 0ED3       02673 m045	MOVLW 211
000408 247F       02674 	ADDWF columna,W,0
00040A DEDD       02675 	RCALL enviar_comando
                  02676 			;			break;
00040C D002       02677 	BRA   m046
                  02678 			;			enviar_comando (0b.0000.1100);			// Pantalla encendida, sin cursor.
00040E 0E0C       02679 	MOVLW 12
000410 D6DA       02680 	BRA   enviar_comando
                  02681 			;		}
                  02682 			;	
                  02683 			;	
                  02684 			;}
000412 0012       02685 m046	RETURN
                  02686 			;
                  02687 			;void borrar_linea (char linea)
                  02688 			;{
                  02689 borrar_linea
000414 6E7F       02690 	MOVWF linea_2,0
                  02691 			;	char i;
                  02692 			;		
                  02693 			;	switch (linea) 									// (se resta una unidad a la coordenada lnea para que la posicin colum
                           na inicial sea 1 y no 0).
000416 507F       02694 	MOVF  linea_2,W,0
000418 0A01       02695 	XORLW 1
00041A B4D8       02696 	BTFSC 0xFD8,Zero_,0
00041C D00A       02697 	BRA   m047
00041E 0A03       02698 	XORLW 3
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 46

ADDR   CODE       LINE  SOURCE

000420 B4D8       02699 	BTFSC 0xFD8,Zero_,0
000422 D00A       02700 	BRA   m048
000424 0A01       02701 	XORLW 1
000426 B4D8       02702 	BTFSC 0xFD8,Zero_,0
000428 D00A       02703 	BRA   m049
00042A 0A07       02704 	XORLW 7
00042C B4D8       02705 	BTFSC 0xFD8,Zero_,0
00042E D00A       02706 	BRA   m050
000430 D00B       02707 	BRA   m051
                  02708 			;		{
                  02709 			;			case 1:
                  02710 			;				enviar_comando (128); 				// Inicio primera linea.
000432 0E80       02711 m047	MOVLW 128
000434 DEC8       02712 	RCALL enviar_comando
                  02713 			;			break;
000436 D008       02714 	BRA   m051
                  02715 			;						
                  02716 			;			case 2:
                  02717 			;				enviar_comando (192); 				// Inicio segunda lnea.
000438 0EC0       02718 m048	MOVLW 192
00043A DEC5       02719 	RCALL enviar_comando
                  02720 			;			break;			
00043C D005       02721 	BRA   m051
                  02722 			;
                  02723 			;			case 3:
                  02724 			;				enviar_comando (148); 				// Inicio tercera lnea (cursor en posicin 20 de la primera lnea).
00043E 0E94       02725 m049	MOVLW 148
000440 DEC2       02726 	RCALL enviar_comando
                  02727 			;			break;				
000442 D002       02728 	BRA   m051
                  02729 			;			
                  02730 			;			case 4:
                  02731 			;				enviar_comando (212); 				// Inicio cuarta lnea (cursor en posicin 20 de la segunda lnea).
000444 0ED4       02732 m050	MOVLW 212
000446 DEBF       02733 	RCALL enviar_comando
                  02734 			;			break;
                  02735 			;		}
                  02736 			;	for (i = 1; i < 21; i++) enviar_literal (' '); 	// Envio 20 carcteres en blanco y posiciono en la siguiente lnea.
000448 0E01       02737 m051	MOVLW 1
00044A 6E7F       02738 	MOVWF i_6,0
00044C 0E15       02739 m052	MOVLW 21
00044E 607F       02740 	CPFSLT i_6,0
000450 D004       02741 	BRA   m053
000452 0E20       02742 	MOVLW 32
000454 DEF3       02743 	RCALL enviar_literal
000456 2A7F       02744 	INCF  i_6,1,0
000458 D7F9       02745 	BRA   m052
                  02746 			;	enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.	
00045A 0E0C       02747 m053	MOVLW 12
00045C D6B4       02748 	BRA   enviar_comando
                  02749 			;}
                  02750 			;
                  02751 			;void borrar_lcd (void)
                  02752 			;{
                  02753 borrar_lcd
                  02754 			;	enviar_comando (0b.0000.0001);  				// Borrado del display y cursor en la posicin inicial.	
00045E 0E01       02755 	MOVLW 1
000460 D6B2       02756 	BRA   enviar_comando
                  02757 			;}
                  02758 			;
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 47

ADDR   CODE       LINE  SOURCE

                  02759 			;void Enviar_lcd (char linea, char columna, uns16 dato, bit bd, bit dp, bit xi,bit ndp)
                  02760 			;            //fila , col , uns16 , bd -> si 0 posa espai si "0" a l'esquerra ,, dp -> si "0"--> posa punt decimal
                  02761 			;{
                  02762 Enviar_lcd
                  02763 			;// Aquesta funcio, posiciona Fila i Columna d'un LCD 4x20 i envia una xifra uns16 descomposant-la i posant 
                  02764 			;//  decimal o no, segons sigui dp, si "0"--> posa punt decimal , si dp "1" -> no posa dp
                  02765 			;//  si bd = "0" -> posa espai, si bd = "1"  --> No  posa espai i posa el 0.
                  02766 			;// si xi = 0 -> 3 xifres,, si xi = 1  -> 4 xifres
                  02767 			;// Atencio, amb dp S'UTILIZA un ESPAI MES
                  02768 			;// amb 4 xifres, tambe es representen 3, pero es gasta un espai de mes.
                  02769 			;// ESPI utilitzat...3 per 3 xifres,, 4 per 3xifres + dp   O 4xifres s/dp ,, 5 per 4 xifres + dp
                  02770 			;// ndp ..si "0"...1decimal... si "1"   2 decimals
                  02771 			;	uns16 num, u_milers, cent;
                  02772 			;	char dec, unid, resto1;
                  02773 			;	char i, xx, yy, dat,xy;
                  02774 			;	
                  02775 			;	//CON_LCD ();
                  02776 			;	//posiciono
                  02777 			;	switch (linea) 									// (se resta una unidad a la coordenada lnea para que la posicin colum
                           na inicial sea 1 y no 0).
000462 507F       02778 	MOVF  linea_3,W,0
000464 0A01       02779 	XORLW 1
000466 B4D8       02780 	BTFSC 0xFD8,Zero_,0
000468 D00A       02781 	BRA   m054
00046A 0A03       02782 	XORLW 3
00046C B4D8       02783 	BTFSC 0xFD8,Zero_,0
00046E D00B       02784 	BRA   m055
000470 0A01       02785 	XORLW 1
000472 B4D8       02786 	BTFSC 0xFD8,Zero_,0
000474 D00C       02787 	BRA   m056
000476 0A07       02788 	XORLW 7
000478 B4D8       02789 	BTFSC 0xFD8,Zero_,0
00047A D00D       02790 	BRA   m057
00047C D012       02791 	BRA   m058
                  02792 			;		{
                  02793 			;			case 1:	enviar_comando (127 + columna); 	// inicio primera linea.
00047E 0E7F       02794 m054	MOVLW 127
000480 247F       02795 	ADDWF columna_2,W,0
000482 DEA1       02796 	RCALL enviar_comando
                  02797 			;			break;	
000484 D00E       02798 	BRA   m058
                  02799 			;			case 2:	enviar_comando (191 + columna); 	// inicio segunda lnea.
000486 0EBF       02800 m055	MOVLW 191
000488 247F       02801 	ADDWF columna_2,W,0
00048A DE9D       02802 	RCALL enviar_comando
                  02803 			;			break;			
00048C D00A       02804 	BRA   m058
                  02805 			;			case 3:	enviar_comando (147 + columna); 	// inicio tercera lnea (cursor en posicin 20 de la primera lnea).
00048E 0E93       02806 m056	MOVLW 147
000490 247F       02807 	ADDWF columna_2,W,0
000492 DE99       02808 	RCALL enviar_comando
                  02809 			;			break;				
000494 D006       02810 	BRA   m058
                  02811 			;			case 4:	enviar_comando (211 + columna); 	// inicio cuarta lnea (cursor en posicin 20 de la segunda lnea).
000496 0ED3       02812 m057	MOVLW 211
000498 247F       02813 	ADDWF columna_2,W,0
00049A DE95       02814 	RCALL enviar_comando
                  02815 			;			break;	
00049C D002       02816 	BRA   m058
                  02817 			;			enviar_comando (0b.0000.1100);			// pantalla encendida, sin cursor
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 48

ADDR   CODE       LINE  SOURCE

00049E 0E0C       02818 	MOVLW 12
0004A0 DE92       02819 	RCALL enviar_comando
                  02820 			;		}				
                  02821 			;		if (!xi)
0004A2 B07F       02822 m058	BTFSC 0xF7F,xi,0
0004A4 D011       02823 	BRA   m059
                  02824 			;		{
                  02825 			;			xy = 2;
0004A6 0E02       02826 	MOVLW 2
0004A8 6E7F       02827 	MOVWF xy,0
                  02828 			;			u_milers = 0;
0004AA 6A7F       02829 	CLRF  u_milers,0
0004AC 6A7F       02830 	CLRF  u_milers+1,0
                  02831 			;			if (dato > 999) { enviar_literal ('>');enviar_literal ('E');enviar_literal ('r'); goto so; }
0004AE 0EE8       02832 	MOVLW 232
0004B0 5C7F       02833 	SUBWF dato_3,W,0
0004B2 0E03       02834 	MOVLW 3
0004B4 587F       02835 	SUBWFB dato_3+1,W,0
0004B6 A0D8       02836 	BTFSS 0xFD8,Carry,0
0004B8 D04D       02837 	BRA   m065
0004BA 0E3E       02838 	MOVLW 62
0004BC DEBF       02839 	RCALL enviar_literal
0004BE 0E45       02840 	MOVLW 69
0004C0 DEBD       02841 	RCALL enviar_literal
0004C2 0E72       02842 	MOVLW 114
0004C4 DEBB       02843 	RCALL enviar_literal
0004C6 D13B       02844 	BRA   m095
                  02845 			;		    else goto sa;
                  02846 			;		}
                  02847 			;		else
                  02848 			;		{
                  02849 			;			xy = 1;
0004C8 0E01       02850 m059	MOVLW 1
0004CA 6E7F       02851 	MOVWF xy,0
                  02852 			;			if (dato > 9999) { enviar_literal ('>');enviar_literal ('E');enviar_literal ('r'); goto so; }
0004CC 0E10       02853 	MOVLW 16
0004CE 5C7F       02854 	SUBWF dato_3,W,0
0004D0 0E27       02855 	MOVLW 39
0004D2 587F       02856 	SUBWFB dato_3+1,W,0
0004D4 A0D8       02857 	BTFSS 0xFD8,Carry,0
0004D6 D007       02858 	BRA   m060
0004D8 0E3E       02859 	MOVLW 62
0004DA DEB0       02860 	RCALL enviar_literal
0004DC 0E45       02861 	MOVLW 69
0004DE DEAE       02862 	RCALL enviar_literal
0004E0 0E72       02863 	MOVLW 114
0004E2 DEAC       02864 	RCALL enviar_literal
0004E4 D12C       02865 	BRA   m095
                  02866 			;		}
                  02867 			;			// Separo per 4 xifres
                  02868 			;			num = dato; // per 4 xifres
0004E6 CF7F FF7F  02869 m060	MOVFF dato_3,num
0004EA CF7F FF7F  02870 	MOVFF dato_3+1,num+1
                  02871 			;			u_milers = num / 1000;
0004EE 507F       02872 	MOVF  num,W,0
0004F0 6E7F       02873 	MOVWF C4tmp,0
0004F2 507F       02874 	MOVF  num+1,W,0
0004F4 6E7F       02875 	MOVWF C4tmp+1,0
0004F6 6A7F       02876 	CLRF  C5rem,0
0004F8 6A7F       02877 	CLRF  C5rem+1,0
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 49

ADDR   CODE       LINE  SOURCE

0004FA 0E10       02878 	MOVLW 16
0004FC 6E7F       02879 	MOVWF C3cnt,0
0004FE 367F       02880 m061	RLCF  C4tmp,1,0
000500 367F       02881 	RLCF  C4tmp+1,1,0
000502 367F       02882 	RLCF  C5rem,1,0
000504 367F       02883 	RLCF  C5rem+1,1,0
000506 0EE8       02884 	MOVLW 232
000508 5C7F       02885 	SUBWF C5rem,W,0
00050A 0E03       02886 	MOVLW 3
00050C 587F       02887 	SUBWFB C5rem+1,W,0
00050E A0D8       02888 	BTFSS 0xFD8,Carry,0
000510 D005       02889 	BRA   m062
000512 0EE8       02890 	MOVLW 232
000514 5E7F       02891 	SUBWF C5rem,1,0
000516 0E03       02892 	MOVLW 3
000518 5A7F       02893 	SUBWFB C5rem+1,1,0
00051A 80D8       02894 	BSF   0xFD8,Carry,0
00051C 367F       02895 m062	RLCF  u_milers,1,0
00051E 367F       02896 	RLCF  u_milers+1,1,0
000520 2E7F       02897 	DECFSZ C3cnt,1,0
000522 D7ED       02898 	BRA   m061
                  02899 			;			dato = num % 1000;
000524 507F       02900 	MOVF  num,W,0
000526 6E7F       02901 	MOVWF C7tmp,0
000528 507F       02902 	MOVF  num+1,W,0
00052A 6E7F       02903 	MOVWF C7tmp+1,0
00052C 6A7F       02904 	CLRF  dato_3,0
00052E 6A7F       02905 	CLRF  dato_3+1,0
000530 0E10       02906 	MOVLW 16
000532 6E7F       02907 	MOVWF C6cnt,0
000534 367F       02908 m063	RLCF  C7tmp,1,0
000536 367F       02909 	RLCF  C7tmp+1,1,0
000538 367F       02910 	RLCF  dato_3,1,0
00053A 367F       02911 	RLCF  dato_3+1,1,0
00053C 0EE8       02912 	MOVLW 232
00053E 5C7F       02913 	SUBWF dato_3,W,0
000540 0E03       02914 	MOVLW 3
000542 587F       02915 	SUBWFB dato_3+1,W,0
000544 A0D8       02916 	BTFSS 0xFD8,Carry,0
000546 D004       02917 	BRA   m064
000548 0EE8       02918 	MOVLW 232
00054A 5E7F       02919 	SUBWF dato_3,1,0
00054C 0E03       02920 	MOVLW 3
00054E 5A7F       02921 	SUBWFB dato_3+1,1,0
000550 2E7F       02922 m064	DECFSZ C6cnt,1,0
000552 D7F0       02923 	BRA   m063
                  02924 			;			// Separo per 3 xifres
                  02925 			;sa:			cent   = dato   / 100;   	
000554 507F       02926 m065	MOVF  dato_3,W,0
000556 6E7F       02927 	MOVWF C9tmp,0
000558 507F       02928 	MOVF  dato_3+1,W,0
00055A 6E7F       02929 	MOVWF C9tmp+1,0
00055C 6A7F       02930 	CLRF  C10rem,0
00055E 0E10       02931 	MOVLW 16
000560 6E7F       02932 	MOVWF C8cnt,0
000562 367F       02933 m066	RLCF  C9tmp,1,0
000564 367F       02934 	RLCF  C9tmp+1,1,0
000566 367F       02935 	RLCF  C10rem,1,0
000568 B0D8       02936 	BTFSC 0xFD8,Carry,0
00056A D004       02937 	BRA   m067
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 50

ADDR   CODE       LINE  SOURCE

00056C 0E64       02938 	MOVLW 100
00056E 5C7F       02939 	SUBWF C10rem,W,0
000570 A0D8       02940 	BTFSS 0xFD8,Carry,0
000572 D003       02941 	BRA   m068
000574 0E64       02942 m067	MOVLW 100
000576 5E7F       02943 	SUBWF C10rem,1,0
000578 80D8       02944 	BSF   0xFD8,Carry,0
00057A 367F       02945 m068	RLCF  cent,1,0
00057C 367F       02946 	RLCF  cent+1,1,0
00057E 2E7F       02947 	DECFSZ C8cnt,1,0
000580 D7F0       02948 	BRA   m066
                  02949 			;			resto1 = dato   % 100;
000582 507F       02950 	MOVF  dato_3,W,0
000584 6E7F       02951 	MOVWF C12tmp,0
000586 507F       02952 	MOVF  dato_3+1,W,0
000588 6E7F       02953 	MOVWF C12tmp+1,0
00058A 6A7F       02954 	CLRF  resto1,0
00058C 0E10       02955 	MOVLW 16
00058E 6E7F       02956 	MOVWF C11cnt,0
000590 367F       02957 m069	RLCF  C12tmp,1,0
000592 367F       02958 	RLCF  C12tmp+1,1,0
000594 367F       02959 	RLCF  resto1,1,0
000596 B0D8       02960 	BTFSC 0xFD8,Carry,0
000598 D004       02961 	BRA   m070
00059A 0E64       02962 	MOVLW 100
00059C 5C7F       02963 	SUBWF resto1,W,0
00059E A0D8       02964 	BTFSS 0xFD8,Carry,0
0005A0 D002       02965 	BRA   m071
0005A2 0E64       02966 m070	MOVLW 100
0005A4 5E7F       02967 	SUBWF resto1,1,0
0005A6 2E7F       02968 m071	DECFSZ C11cnt,1,0
0005A8 D7F3       02969 	BRA   m069
                  02970 			;			dec    = resto1 /  10;  
0005AA 507F       02971 	MOVF  resto1,W,0
0005AC 6E7F       02972 	MOVWF C14tmp,0
0005AE 6A7F       02973 	CLRF  C15rem,0
0005B0 0E08       02974 	MOVLW 8
0005B2 6E7F       02975 	MOVWF C13cnt,0
0005B4 367F       02976 m072	RLCF  C14tmp,1,0
0005B6 367F       02977 	RLCF  C15rem,1,0
0005B8 0E0A       02978 	MOVLW 10
0005BA 5C7F       02979 	SUBWF C15rem,W,0
0005BC A0D8       02980 	BTFSS 0xFD8,Carry,0
0005BE D003       02981 	BRA   m073
0005C0 0E0A       02982 	MOVLW 10
0005C2 5E7F       02983 	SUBWF C15rem,1,0
0005C4 80D8       02984 	BSF   0xFD8,Carry,0
0005C6 367F       02985 m073	RLCF  dec,1,0
0005C8 2E7F       02986 	DECFSZ C13cnt,1,0
0005CA D7F4       02987 	BRA   m072
                  02988 			;			unid   = resto1 %  10; 		
0005CC 507F       02989 	MOVF  resto1,W,0
0005CE 6E7F       02990 	MOVWF C17tmp,0
0005D0 6A7F       02991 	CLRF  unid,0
0005D2 0E08       02992 	MOVLW 8
0005D4 6E7F       02993 	MOVWF C16cnt,0
0005D6 367F       02994 m074	RLCF  C17tmp,1,0
0005D8 367F       02995 	RLCF  unid,1,0
0005DA 0E0A       02996 	MOVLW 10
0005DC 5C7F       02997 	SUBWF unid,W,0
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 51

ADDR   CODE       LINE  SOURCE

0005DE A0D8       02998 	BTFSS 0xFD8,Carry,0
0005E0 D002       02999 	BRA   m075
0005E2 0E0A       03000 	MOVLW 10
0005E4 5E7F       03001 	SUBWF unid,1,0
0005E6 2E7F       03002 m075	DECFSZ C16cnt,1,0
0005E8 D7F6       03003 	BRA   m074
                  03004 			;		// Envio
                  03005 			;		for (xx = xy; xx < 7; xx++)
0005EA CF7F FF7F  03006 	MOVFF xy,xx
0005EE 0E07       03007 m076	MOVLW 7
0005F0 607F       03008 	CPFSLT xx,0
0005F2 D0A5       03009 	BRA   m095
                  03010 			;		{
                  03011 			;			clrwdt () ;
0005F4 0004       03012 	CLRWDT
                  03013 			;			if (xx == 1) 
0005F6 2C7F       03014 	DECFSZ xx,W,0
0005F8 D00B       03015 	BRA   m078
                  03016 			;			{
                  03017 			;				if ((u_milers==0)&&(!bd)) dat = ' '; // bd =0 --> espai
0005FA 507F       03018 	MOVF  u_milers,W,0
0005FC 107F       03019 	IORWF u_milers+1,W,0
0005FE A4D8       03020 	BTFSS 0xFD8,Zero_,0
000600 D005       03021 	BRA   m077
000602 B07F       03022 	BTFSC 0xF7F,bd,0
000604 D003       03023 	BRA   m077
000606 0E20       03024 	MOVLW 32
000608 6E7F       03025 	MOVWF dat,0
                  03026 			;				else dat = u_milers;
00060A D002       03027 	BRA   m078
00060C CF7F FF7F  03028 m077	MOVFF u_milers,dat
                  03029 			;			}
                  03030 			;			if (xx == 2) 
000610 0E02       03031 m078	MOVLW 2
000612 627F       03032 	CPFSEQ xx,0
000614 D00F       03033 	BRA   m080
                  03034 			;			{
                  03035 			;				if ((u_milers==0)&&(cent==0)&&(!bd)) dat = ' '; // bd =0 --> espai
000616 507F       03036 	MOVF  u_milers,W,0
000618 107F       03037 	IORWF u_milers+1,W,0
00061A A4D8       03038 	BTFSS 0xFD8,Zero_,0
00061C D009       03039 	BRA   m079
00061E 507F       03040 	MOVF  cent,W,0
000620 107F       03041 	IORWF cent+1,W,0
000622 A4D8       03042 	BTFSS 0xFD8,Zero_,0
000624 D005       03043 	BRA   m079
000626 B07F       03044 	BTFSC 0xF7F,bd,0
000628 D003       03045 	BRA   m079
00062A 0E20       03046 	MOVLW 32
00062C 6E7F       03047 	MOVWF dat,0
                  03048 			;				else dat = cent;
00062E D002       03049 	BRA   m080
000630 CF7F FF7F  03050 m079	MOVFF cent,dat
                  03051 			;			}
                  03052 			;			if (xx == 3) 
000634 0E03       03053 m080	MOVLW 3
000636 627F       03054 	CPFSEQ xx,0
000638 D00A       03055 	BRA   m083
                  03056 			;			{
                  03057 			;				if(ndp) { if (dp==0) dat = '.';
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 52

ADDR   CODE       LINE  SOURCE

00063A A07F       03058 	BTFSS 0xF7F,ndp,0
00063C D007       03059 	BRA   m082
00063E B07F       03060 	BTFSC 0xF7F,dp,0
000640 D003       03061 	BRA   m081
000642 0E2E       03062 	MOVLW 46
000644 6E7F       03063 	MOVWF dat,0
                  03064 			;				          else xx++;  
000646 D003       03065 	BRA   m083
000648 2A7F       03066 m081	INCF  xx,1,0
                  03067 			;				        }
                  03068 			;				else xx++;		
00064A D001       03069 	BRA   m083
00064C 2A7F       03070 m082	INCF  xx,1,0
                  03071 			;			}
                  03072 			;			if (xx == 4)
00064E 0E04       03073 m083	MOVLW 4
000650 627F       03074 	CPFSEQ xx,0
000652 D012       03075 	BRA   m085
                  03076 			;			{
                  03077 			;				if ((u_milers==0)&&(cent==0)&&(dec==0)&&(!bd)) dat = ' ';
000654 507F       03078 	MOVF  u_milers,W,0
000656 107F       03079 	IORWF u_milers+1,W,0
000658 A4D8       03080 	BTFSS 0xFD8,Zero_,0
00065A D00C       03081 	BRA   m084
00065C 507F       03082 	MOVF  cent,W,0
00065E 107F       03083 	IORWF cent+1,W,0
000660 A4D8       03084 	BTFSS 0xFD8,Zero_,0
000662 D008       03085 	BRA   m084
000664 507F       03086 	MOVF  dec,W,0
000666 A4D8       03087 	BTFSS 0xFD8,Zero_,0
000668 D005       03088 	BRA   m084
00066A B07F       03089 	BTFSC 0xF7F,bd,0
00066C D003       03090 	BRA   m084
00066E 0E20       03091 	MOVLW 32
000670 6E7F       03092 	MOVWF dat,0
                  03093 			;				else dat = dec ;
000672 D002       03094 	BRA   m085
000674 CF7F FF7F  03095 m084	MOVFF dec,dat
                  03096 			;			}
                  03097 			;			if (xx == 5)
000678 0E05       03098 m085	MOVLW 5
00067A 627F       03099 	CPFSEQ xx,0
00067C D00A       03100 	BRA   m088
                  03101 			;			{
                  03102 			;				if(!ndp) { if (dp==0) dat = '.';	
00067E B07F       03103 	BTFSC 0xF7F,ndp,0
000680 D007       03104 	BRA   m087
000682 B07F       03105 	BTFSC 0xF7F,dp,0
000684 D003       03106 	BRA   m086
000686 0E2E       03107 	MOVLW 46
000688 6E7F       03108 	MOVWF dat,0
                  03109 			;				           else xx++;
00068A D003       03110 	BRA   m088
00068C 2A7F       03111 m086	INCF  xx,1,0
                  03112 			;						 }
                  03113 			;				else xx++;		 
00068E D001       03114 	BRA   m088
000690 2A7F       03115 m087	INCF  xx,1,0
                  03116 			;			}
                  03117 			;			if (xx == 6) dat = unid;
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 53

ADDR   CODE       LINE  SOURCE

000692 0E06       03118 m088	MOVLW 6
000694 627F       03119 	CPFSEQ xx,0
000696 D002       03120 	BRA   m089
000698 CF7F FF7F  03121 	MOVFF unid,dat
                  03122 			;						
                  03123 			;			if ((dat!='.')&&(dat!=' ')) dat = dat + 0x30;
00069C 507F       03124 m089	MOVF  dat,W,0
00069E 0A2E       03125 	XORLW 46
0006A0 B4D8       03126 	BTFSC 0xFD8,Zero_,0
0006A2 D006       03127 	BRA   m090
0006A4 507F       03128 	MOVF  dat,W,0
0006A6 0A20       03129 	XORLW 32
0006A8 B4D8       03130 	BTFSC 0xFD8,Zero_,0
0006AA D002       03131 	BRA   m090
0006AC 0E30       03132 	MOVLW 48
0006AE 267F       03133 	ADDWF dat,1,0
                  03134 			;
                  03135 			;			PORTB.0 = dat.4;nop();
0006B0 A87F       03136 m090	BTFSS dat,4,0
0006B2 9081       03137 	BCF   PORTB,0,0
0006B4 B87F       03138 	BTFSC dat,4,0
0006B6 8081       03139 	BSF   PORTB,0,0
0006B8 0000       03140 	NOP  
                  03141 			;			PORTB.1 = dat.5;nop();
0006BA AA7F       03142 	BTFSS dat,5,0
0006BC 9281       03143 	BCF   PORTB,1,0
0006BE BA7F       03144 	BTFSC dat,5,0
0006C0 8281       03145 	BSF   PORTB,1,0
0006C2 0000       03146 	NOP  
                  03147 			;			PORTB.2 = dat.6;nop();
0006C4 AC7F       03148 	BTFSS dat,6,0
0006C6 9481       03149 	BCF   PORTB,2,0
0006C8 BC7F       03150 	BTFSC dat,6,0
0006CA 8481       03151 	BSF   PORTB,2,0
0006CC 0000       03152 	NOP  
                  03153 			;			PORTB.3 = dat.7;nop();
0006CE AE7F       03154 	BTFSS dat,7,0
0006D0 9681       03155 	BCF   PORTB,3,0
0006D2 BE7F       03156 	BTFSC dat,7,0
0006D4 8681       03157 	BSF   PORTB,3,0
0006D6 0000       03158 	NOP  
                  03159 			;			PORTB.4 = 1;  									// Modo dato.
0006D8 8881       03160 	BSF   PORTB,4,0
                  03161 			;			retardo_20u ();
0006DA DD13       03162 	RCALL retardo_20u
                  03163 			;			PORTB.5 = 1;  									// Breve pulso.
0006DC 8A81       03164 	BSF   PORTB,5,0
                  03165 			;			retardo_20u ();
0006DE DD11       03166 	RCALL retardo_20u
                  03167 			;			PORTB.5 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
0006E0 9A81       03168 	BCF   PORTB,5,0
                  03169 			;			for (i = 1; i <= 6; i++) retardo_20u ();
0006E2 0E01       03170 	MOVLW 1
0006E4 6E7F       03171 	MOVWF i_7,0
0006E6 0E07       03172 m091	MOVLW 7
0006E8 607F       03173 	CPFSLT i_7,0
0006EA D003       03174 	BRA   m092
0006EC DD0A       03175 	RCALL retardo_20u
0006EE 2A7F       03176 	INCF  i_7,1,0
0006F0 D7FA       03177 	BRA   m091
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 54

ADDR   CODE       LINE  SOURCE

                  03178 			;			dat = swap (dat);
0006F2 3A7F       03179 m092	SWAPF dat,1,0
                  03180 			;			PORTB.0 = dat.4;nop();
0006F4 A87F       03181 	BTFSS dat,4,0
0006F6 9081       03182 	BCF   PORTB,0,0
0006F8 B87F       03183 	BTFSC dat,4,0
0006FA 8081       03184 	BSF   PORTB,0,0
0006FC 0000       03185 	NOP  
                  03186 			;			PORTB.1 = dat.5;nop();
0006FE AA7F       03187 	BTFSS dat,5,0
000700 9281       03188 	BCF   PORTB,1,0
000702 BA7F       03189 	BTFSC dat,5,0
000704 8281       03190 	BSF   PORTB,1,0
000706 0000       03191 	NOP  
                  03192 			;			PORTB.2 = dat.6;nop();
000708 AC7F       03193 	BTFSS dat,6,0
00070A 9481       03194 	BCF   PORTB,2,0
00070C BC7F       03195 	BTFSC dat,6,0
00070E 8481       03196 	BSF   PORTB,2,0
000710 0000       03197 	NOP  
                  03198 			;			PORTB.3 = dat.7;
000712 AE7F       03199 	BTFSS dat,7,0
000714 9681       03200 	BCF   PORTB,3,0
000716 BE7F       03201 	BTFSC dat,7,0
000718 8681       03202 	BSF   PORTB,3,0
                  03203 			;			retardo_1m ();
00071A DCFD       03204 	RCALL retardo_1m
                  03205 			;			PORTB.4 = 1;  									// Modo dato.
00071C 8881       03206 	BSF   PORTB,4,0
                  03207 			;			retardo_1m ();
00071E DCFB       03208 	RCALL retardo_1m
                  03209 			;			PORTB.5 = 1;  									// Breve pulso.
000720 8A81       03210 	BSF   PORTB,5,0
                  03211 			;			retardo_20u ();
000722 DCEF       03212 	RCALL retardo_20u
                  03213 			;			PORTB.5 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
000724 9A81       03214 	BCF   PORTB,5,0
                  03215 			;			for (i = 1; i<= 6; i++) retardo_20u ();
000726 0E01       03216 	MOVLW 1
000728 6E7F       03217 	MOVWF i_7,0
00072A 0E07       03218 m093	MOVLW 7
00072C 607F       03219 	CPFSLT i_7,0
00072E D003       03220 	BRA   m094
000730 DCE8       03221 	RCALL retardo_20u
000732 2A7F       03222 	INCF  i_7,1,0
000734 D7FA       03223 	BRA   m093
                  03224 			;			enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.			
000736 0E0C       03225 m094	MOVLW 12
000738 DD46       03226 	RCALL enviar_comando
                  03227 			;		}
00073A 2A7F       03228 	INCF  xx,1,0
00073C D758       03229 	BRA   m076
                  03230 			;so:	//DESCON_LCD ();
                  03231 			;	return;
00073E 0012       03232 m095	RETURN
                  03233 			;}
                  03234 			;
                  03235 			;void Enviar_uns16(char linea,char columna,uns16 dato){
                  03236 Enviar_uns16
                  03237 			;	//utilizaremos esta funcion en caso de necesitar un numero entero hasta 65536(16bits)
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 55

ADDR   CODE       LINE  SOURCE

                  03238 			;	uns16 num, u_milers, cent, d_milers;
                  03239 			;	char dec, unid, resto1;
                  03240 			;	char i, xx, yy, dat,xy;
                  03241 			;
                  03242 			;	switch (linea) 									// (se resta una unidad a la coordenada lnea para que la posicin colum
                           na inicial sea 1 y no 0).
000740 507F       03243 	MOVF  linea_4,W,0
000742 0A01       03244 	XORLW 1
000744 B4D8       03245 	BTFSC 0xFD8,Zero_,0
000746 D00A       03246 	BRA   m096
000748 0A03       03247 	XORLW 3
00074A B4D8       03248 	BTFSC 0xFD8,Zero_,0
00074C D00B       03249 	BRA   m097
00074E 0A01       03250 	XORLW 1
000750 B4D8       03251 	BTFSC 0xFD8,Zero_,0
000752 D00C       03252 	BRA   m098
000754 0A07       03253 	XORLW 7
000756 B4D8       03254 	BTFSC 0xFD8,Zero_,0
000758 D00D       03255 	BRA   m099
00075A D012       03256 	BRA   m100
                  03257 			;		{
                  03258 			;			case 1:	enviar_comando (127 + columna); 	// inicio primera linea.
00075C 0E7F       03259 m096	MOVLW 127
00075E 247F       03260 	ADDWF columna_3,W,0
000760 DD32       03261 	RCALL enviar_comando
                  03262 			;			break;	
000762 D00E       03263 	BRA   m100
                  03264 			;			case 2:	enviar_comando (191 + columna); 	// inicio segunda lnea.
000764 0EBF       03265 m097	MOVLW 191
000766 247F       03266 	ADDWF columna_3,W,0
000768 DD2E       03267 	RCALL enviar_comando
                  03268 			;			break;			
00076A D00A       03269 	BRA   m100
                  03270 			;			case 3:	enviar_comando (147 + columna); 	// inicio tercera lnea (cursor en posicin 20 de la primera lnea).
00076C 0E93       03271 m098	MOVLW 147
00076E 247F       03272 	ADDWF columna_3,W,0
000770 DD2A       03273 	RCALL enviar_comando
                  03274 			;			break;				
000772 D006       03275 	BRA   m100
                  03276 			;			case 4:	enviar_comando (211 + columna); 	// inicio cuarta lnea (cursor en posicin 20 de la segunda lnea).
000774 0ED3       03277 m099	MOVLW 211
000776 247F       03278 	ADDWF columna_3,W,0
000778 DD26       03279 	RCALL enviar_comando
                  03280 			;			break;	
00077A D002       03281 	BRA   m100
                  03282 			;			enviar_comando (0b.0000.1100);			// pantalla encendida, sin cursor
00077C 0E0C       03283 	MOVLW 12
00077E DD23       03284 	RCALL enviar_comando
                  03285 			;		}				
                  03286 			;	
                  03287 			;			
                  03288 			;			num = dato; 
000780 CF7F FF7F  03289 m100	MOVFF dato_4,num_2
000784 CF7F FF7F  03290 	MOVFF dato_4+1,num_2+1
                  03291 			;			d_milers =num/10000;
000788 507F       03292 	MOVF  num_2,W,0
00078A 6E7F       03293 	MOVWF C19tmp,0
00078C 507F       03294 	MOVF  num_2+1,W,0
00078E 6E7F       03295 	MOVWF C19tmp+1,0
000790 6A7F       03296 	CLRF  C20rem,0
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 56

ADDR   CODE       LINE  SOURCE

000792 6A7F       03297 	CLRF  C20rem+1,0
000794 0E10       03298 	MOVLW 16
000796 6E7F       03299 	MOVWF C18cnt,0
000798 367F       03300 m101	RLCF  C19tmp,1,0
00079A 367F       03301 	RLCF  C19tmp+1,1,0
00079C 367F       03302 	RLCF  C20rem,1,0
00079E 367F       03303 	RLCF  C20rem+1,1,0
0007A0 0E10       03304 	MOVLW 16
0007A2 5C7F       03305 	SUBWF C20rem,W,0
0007A4 0E27       03306 	MOVLW 39
0007A6 587F       03307 	SUBWFB C20rem+1,W,0
0007A8 A0D8       03308 	BTFSS 0xFD8,Carry,0
0007AA D005       03309 	BRA   m102
0007AC 0E10       03310 	MOVLW 16
0007AE 5E7F       03311 	SUBWF C20rem,1,0
0007B0 0E27       03312 	MOVLW 39
0007B2 5A7F       03313 	SUBWFB C20rem+1,1,0
0007B4 80D8       03314 	BSF   0xFD8,Carry,0
0007B6 367F       03315 m102	RLCF  d_milers,1,0
0007B8 367F       03316 	RLCF  d_milers+1,1,0
0007BA 2E7F       03317 	DECFSZ C18cnt,1,0
0007BC D7ED       03318 	BRA   m101
                  03319 			;			num= num%10000;
0007BE 507F       03320 	MOVF  num_2,W,0
0007C0 6E7F       03321 	MOVWF C22tmp,0
0007C2 507F       03322 	MOVF  num_2+1,W,0
0007C4 6E7F       03323 	MOVWF C22tmp+1,0
0007C6 6A7F       03324 	CLRF  num_2,0
0007C8 6A7F       03325 	CLRF  num_2+1,0
0007CA 0E10       03326 	MOVLW 16
0007CC 6E7F       03327 	MOVWF C21cnt,0
0007CE 367F       03328 m103	RLCF  C22tmp,1,0
0007D0 367F       03329 	RLCF  C22tmp+1,1,0
0007D2 367F       03330 	RLCF  num_2,1,0
0007D4 367F       03331 	RLCF  num_2+1,1,0
0007D6 0E10       03332 	MOVLW 16
0007D8 5C7F       03333 	SUBWF num_2,W,0
0007DA 0E27       03334 	MOVLW 39
0007DC 587F       03335 	SUBWFB num_2+1,W,0
0007DE A0D8       03336 	BTFSS 0xFD8,Carry,0
0007E0 D004       03337 	BRA   m104
0007E2 0E10       03338 	MOVLW 16
0007E4 5E7F       03339 	SUBWF num_2,1,0
0007E6 0E27       03340 	MOVLW 39
0007E8 5A7F       03341 	SUBWFB num_2+1,1,0
0007EA 2E7F       03342 m104	DECFSZ C21cnt,1,0
0007EC D7F0       03343 	BRA   m103
                  03344 			;			u_milers = num / 1000;
0007EE 507F       03345 	MOVF  num_2,W,0
0007F0 6E7F       03346 	MOVWF C24tmp,0
0007F2 507F       03347 	MOVF  num_2+1,W,0
0007F4 6E7F       03348 	MOVWF C24tmp+1,0
0007F6 6A7F       03349 	CLRF  C25rem,0
0007F8 6A7F       03350 	CLRF  C25rem+1,0
0007FA 0E10       03351 	MOVLW 16
0007FC 6E7F       03352 	MOVWF C23cnt,0
0007FE 367F       03353 m105	RLCF  C24tmp,1,0
000800 367F       03354 	RLCF  C24tmp+1,1,0
000802 367F       03355 	RLCF  C25rem,1,0
000804 367F       03356 	RLCF  C25rem+1,1,0
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 57

ADDR   CODE       LINE  SOURCE

000806 0EE8       03357 	MOVLW 232
000808 5C7F       03358 	SUBWF C25rem,W,0
00080A 0E03       03359 	MOVLW 3
00080C 587F       03360 	SUBWFB C25rem+1,W,0
00080E A0D8       03361 	BTFSS 0xFD8,Carry,0
000810 D005       03362 	BRA   m106
000812 0EE8       03363 	MOVLW 232
000814 5E7F       03364 	SUBWF C25rem,1,0
000816 0E03       03365 	MOVLW 3
000818 5A7F       03366 	SUBWFB C25rem+1,1,0
00081A 80D8       03367 	BSF   0xFD8,Carry,0
00081C 367F       03368 m106	RLCF  u_milers_2,1,0
00081E 367F       03369 	RLCF  u_milers_2+1,1,0
000820 2E7F       03370 	DECFSZ C23cnt,1,0
000822 D7ED       03371 	BRA   m105
                  03372 			;			dato = num % 1000;
000824 507F       03373 	MOVF  num_2,W,0
000826 6E7F       03374 	MOVWF C27tmp,0
000828 507F       03375 	MOVF  num_2+1,W,0
00082A 6E7F       03376 	MOVWF C27tmp+1,0
00082C 6A7F       03377 	CLRF  dato_4,0
00082E 6A7F       03378 	CLRF  dato_4+1,0
000830 0E10       03379 	MOVLW 16
000832 6E7F       03380 	MOVWF C26cnt,0
000834 367F       03381 m107	RLCF  C27tmp,1,0
000836 367F       03382 	RLCF  C27tmp+1,1,0
000838 367F       03383 	RLCF  dato_4,1,0
00083A 367F       03384 	RLCF  dato_4+1,1,0
00083C 0EE8       03385 	MOVLW 232
00083E 5C7F       03386 	SUBWF dato_4,W,0
000840 0E03       03387 	MOVLW 3
000842 587F       03388 	SUBWFB dato_4+1,W,0
000844 A0D8       03389 	BTFSS 0xFD8,Carry,0
000846 D004       03390 	BRA   m108
000848 0EE8       03391 	MOVLW 232
00084A 5E7F       03392 	SUBWF dato_4,1,0
00084C 0E03       03393 	MOVLW 3
00084E 5A7F       03394 	SUBWFB dato_4+1,1,0
000850 2E7F       03395 m108	DECFSZ C26cnt,1,0
000852 D7F0       03396 	BRA   m107
                  03397 			;
                  03398 			;			cent   = dato   / 100;   	
000854 507F       03399 	MOVF  dato_4,W,0
000856 6E7F       03400 	MOVWF C29tmp,0
000858 507F       03401 	MOVF  dato_4+1,W,0
00085A 6E7F       03402 	MOVWF C29tmp+1,0
00085C 6A7F       03403 	CLRF  C30rem,0
00085E 0E10       03404 	MOVLW 16
000860 6E7F       03405 	MOVWF C28cnt,0
000862 367F       03406 m109	RLCF  C29tmp,1,0
000864 367F       03407 	RLCF  C29tmp+1,1,0
000866 367F       03408 	RLCF  C30rem,1,0
000868 B0D8       03409 	BTFSC 0xFD8,Carry,0
00086A D004       03410 	BRA   m110
00086C 0E64       03411 	MOVLW 100
00086E 5C7F       03412 	SUBWF C30rem,W,0
000870 A0D8       03413 	BTFSS 0xFD8,Carry,0
000872 D003       03414 	BRA   m111
000874 0E64       03415 m110	MOVLW 100
000876 5E7F       03416 	SUBWF C30rem,1,0
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 58

ADDR   CODE       LINE  SOURCE

000878 80D8       03417 	BSF   0xFD8,Carry,0
00087A 367F       03418 m111	RLCF  cent_2,1,0
00087C 367F       03419 	RLCF  cent_2+1,1,0
00087E 2E7F       03420 	DECFSZ C28cnt,1,0
000880 D7F0       03421 	BRA   m109
                  03422 			;			resto1 = dato   % 100;
000882 507F       03423 	MOVF  dato_4,W,0
000884 6E7F       03424 	MOVWF C32tmp,0
000886 507F       03425 	MOVF  dato_4+1,W,0
000888 6E7F       03426 	MOVWF C32tmp+1,0
00088A 6A7F       03427 	CLRF  resto1_2,0
00088C 0E10       03428 	MOVLW 16
00088E 6E7F       03429 	MOVWF C31cnt,0
000890 367F       03430 m112	RLCF  C32tmp,1,0
000892 367F       03431 	RLCF  C32tmp+1,1,0
000894 367F       03432 	RLCF  resto1_2,1,0
000896 B0D8       03433 	BTFSC 0xFD8,Carry,0
000898 D004       03434 	BRA   m113
00089A 0E64       03435 	MOVLW 100
00089C 5C7F       03436 	SUBWF resto1_2,W,0
00089E A0D8       03437 	BTFSS 0xFD8,Carry,0
0008A0 D002       03438 	BRA   m114
0008A2 0E64       03439 m113	MOVLW 100
0008A4 5E7F       03440 	SUBWF resto1_2,1,0
0008A6 2E7F       03441 m114	DECFSZ C31cnt,1,0
0008A8 D7F3       03442 	BRA   m112
                  03443 			;			dec    = resto1 /  10;  
0008AA 507F       03444 	MOVF  resto1_2,W,0
0008AC 6E7F       03445 	MOVWF C34tmp,0
0008AE 6A7F       03446 	CLRF  C35rem,0
0008B0 0E08       03447 	MOVLW 8
0008B2 6E7F       03448 	MOVWF C33cnt,0
0008B4 367F       03449 m115	RLCF  C34tmp,1,0
0008B6 367F       03450 	RLCF  C35rem,1,0
0008B8 0E0A       03451 	MOVLW 10
0008BA 5C7F       03452 	SUBWF C35rem,W,0
0008BC A0D8       03453 	BTFSS 0xFD8,Carry,0
0008BE D003       03454 	BRA   m116
0008C0 0E0A       03455 	MOVLW 10
0008C2 5E7F       03456 	SUBWF C35rem,1,0
0008C4 80D8       03457 	BSF   0xFD8,Carry,0
0008C6 367F       03458 m116	RLCF  dec_2,1,0
0008C8 2E7F       03459 	DECFSZ C33cnt,1,0
0008CA D7F4       03460 	BRA   m115
                  03461 			;			unid   = resto1 %  10; 		
0008CC 507F       03462 	MOVF  resto1_2,W,0
0008CE 6E7F       03463 	MOVWF C37tmp,0
0008D0 6A7F       03464 	CLRF  unid_2,0
0008D2 0E08       03465 	MOVLW 8
0008D4 6E7F       03466 	MOVWF C36cnt,0
0008D6 367F       03467 m117	RLCF  C37tmp,1,0
0008D8 367F       03468 	RLCF  unid_2,1,0
0008DA 0E0A       03469 	MOVLW 10
0008DC 5C7F       03470 	SUBWF unid_2,W,0
0008DE A0D8       03471 	BTFSS 0xFD8,Carry,0
0008E0 D002       03472 	BRA   m118
0008E2 0E0A       03473 	MOVLW 10
0008E4 5E7F       03474 	SUBWF unid_2,1,0
0008E6 2E7F       03475 m118	DECFSZ C36cnt,1,0
0008E8 D7F6       03476 	BRA   m117
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 59

ADDR   CODE       LINE  SOURCE

                  03477 			;		// Envio
                  03478 			;		for (xx=0 ; xx < 5; xx++)
0008EA 6A7F       03479 	CLRF  xx_2,0
0008EC 0E05       03480 m119	MOVLW 5
0008EE 607F       03481 	CPFSLT xx_2,0
0008F0 D0A6       03482 	BRA   m135
                  03483 			;		{
                  03484 			;			switch(xx){
0008F2 507F       03485 	MOVF  xx_2,W,0
0008F4 B4D8       03486 	BTFSC 0xFD8,Zero_,0
0008F6 D00D       03487 	BRA   m120
0008F8 0A01       03488 	XORLW 1
0008FA B4D8       03489 	BTFSC 0xFD8,Zero_,0
0008FC D014       03490 	BRA   m122
0008FE 0A03       03491 	XORLW 3
000900 B4D8       03492 	BTFSC 0xFD8,Zero_,0
000902 D01F       03493 	BRA   m124
000904 0A01       03494 	XORLW 1
000906 B4D8       03495 	BTFSC 0xFD8,Zero_,0
000908 D02E       03496 	BRA   m126
00090A 0A07       03497 	XORLW 7
00090C B4D8       03498 	BTFSC 0xFD8,Zero_,0
00090E D040       03499 	BRA   m128
000910 D041       03500 	BRA   m129
                  03501 			;				case 0:
                  03502 			;					if (d_milers==0) dat = ' '; 
000912 507F       03503 m120	MOVF  d_milers,W,0
000914 107F       03504 	IORWF d_milers+1,W,0
000916 A4D8       03505 	BTFSS 0xFD8,Zero_,0
000918 D003       03506 	BRA   m121
00091A 0E20       03507 	MOVLW 32
00091C 6E7F       03508 	MOVWF dat_2,0
                  03509 			;					else dat = d_milers;
00091E D03A       03510 	BRA   m129
000920 CF7F FF7F  03511 m121	MOVFF d_milers,dat_2
                  03512 			;					break;
000924 D037       03513 	BRA   m129
                  03514 			;				case 1:
                  03515 			;					if ((u_milers==0)&&(d_milers==0)) dat = ' ';
000926 507F       03516 m122	MOVF  u_milers_2,W,0
000928 107F       03517 	IORWF u_milers_2+1,W,0
00092A A4D8       03518 	BTFSS 0xFD8,Zero_,0
00092C D007       03519 	BRA   m123
00092E 507F       03520 	MOVF  d_milers,W,0
000930 107F       03521 	IORWF d_milers+1,W,0
000932 A4D8       03522 	BTFSS 0xFD8,Zero_,0
000934 D003       03523 	BRA   m123
000936 0E20       03524 	MOVLW 32
000938 6E7F       03525 	MOVWF dat_2,0
                  03526 			;					else dat = u_milers;
00093A D02C       03527 	BRA   m129
00093C CF7F FF7F  03528 m123	MOVFF u_milers_2,dat_2
                  03529 			;					break;
000940 D029       03530 	BRA   m129
                  03531 			;				case 2:
                  03532 			;					if ((d_milers==0)&&(u_milers==0)&&(cent==0)) dat = ' '; 
000942 507F       03533 m124	MOVF  d_milers,W,0
000944 107F       03534 	IORWF d_milers+1,W,0
000946 A4D8       03535 	BTFSS 0xFD8,Zero_,0
000948 D00B       03536 	BRA   m125
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 60

ADDR   CODE       LINE  SOURCE

00094A 507F       03537 	MOVF  u_milers_2,W,0
00094C 107F       03538 	IORWF u_milers_2+1,W,0
00094E A4D8       03539 	BTFSS 0xFD8,Zero_,0
000950 D007       03540 	BRA   m125
000952 507F       03541 	MOVF  cent_2,W,0
000954 107F       03542 	IORWF cent_2+1,W,0
000956 A4D8       03543 	BTFSS 0xFD8,Zero_,0
000958 D003       03544 	BRA   m125
00095A 0E20       03545 	MOVLW 32
00095C 6E7F       03546 	MOVWF dat_2,0
                  03547 			;					else dat = cent;
00095E D01A       03548 	BRA   m129
000960 CF7F FF7F  03549 m125	MOVFF cent_2,dat_2
                  03550 			;					break;
000964 D017       03551 	BRA   m129
                  03552 			;				case 3:
                  03553 			;					if ((u_milers==0)&&(cent==0)&&(dec==0)&&(d_milers==0)) dat = ' ';
000966 507F       03554 m126	MOVF  u_milers_2,W,0
000968 107F       03555 	IORWF u_milers_2+1,W,0
00096A A4D8       03556 	BTFSS 0xFD8,Zero_,0
00096C D00E       03557 	BRA   m127
00096E 507F       03558 	MOVF  cent_2,W,0
000970 107F       03559 	IORWF cent_2+1,W,0
000972 A4D8       03560 	BTFSS 0xFD8,Zero_,0
000974 D00A       03561 	BRA   m127
000976 507F       03562 	MOVF  dec_2,W,0
000978 A4D8       03563 	BTFSS 0xFD8,Zero_,0
00097A D007       03564 	BRA   m127
00097C 507F       03565 	MOVF  d_milers,W,0
00097E 107F       03566 	IORWF d_milers+1,W,0
000980 A4D8       03567 	BTFSS 0xFD8,Zero_,0
000982 D003       03568 	BRA   m127
000984 0E20       03569 	MOVLW 32
000986 6E7F       03570 	MOVWF dat_2,0
                  03571 			;					else dat = dec ;
000988 D005       03572 	BRA   m129
00098A CF7F FF7F  03573 m127	MOVFF dec_2,dat_2
                  03574 			;					break;
00098E D002       03575 	BRA   m129
                  03576 			;				case 4:
                  03577 			;					dat = unid;
000990 CF7F FF7F  03578 m128	MOVFF unid_2,dat_2
                  03579 			;					break;
                  03580 			;			}		
                  03581 			;			if (dat!=' ') dat = dat + 0x30;
000994 507F       03582 m129	MOVF  dat_2,W,0
000996 0A20       03583 	XORLW 32
000998 B4D8       03584 	BTFSC 0xFD8,Zero_,0
00099A D002       03585 	BRA   m130
00099C 0E30       03586 	MOVLW 48
00099E 267F       03587 	ADDWF dat_2,1,0
                  03588 			;			PORTB.0 = dat.4;nop();
0009A0 A87F       03589 m130	BTFSS dat_2,4,0
0009A2 9081       03590 	BCF   PORTB,0,0
0009A4 B87F       03591 	BTFSC dat_2,4,0
0009A6 8081       03592 	BSF   PORTB,0,0
0009A8 0000       03593 	NOP  
                  03594 			;			PORTB.1 = dat.5;nop();
0009AA AA7F       03595 	BTFSS dat_2,5,0
0009AC 9281       03596 	BCF   PORTB,1,0
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 61

ADDR   CODE       LINE  SOURCE

0009AE BA7F       03597 	BTFSC dat_2,5,0
0009B0 8281       03598 	BSF   PORTB,1,0
0009B2 0000       03599 	NOP  
                  03600 			;			PORTB.2 = dat.6;nop();
0009B4 AC7F       03601 	BTFSS dat_2,6,0
0009B6 9481       03602 	BCF   PORTB,2,0
0009B8 BC7F       03603 	BTFSC dat_2,6,0
0009BA 8481       03604 	BSF   PORTB,2,0
0009BC 0000       03605 	NOP  
                  03606 			;			PORTB.3 = dat.7;nop();
0009BE AE7F       03607 	BTFSS dat_2,7,0
0009C0 9681       03608 	BCF   PORTB,3,0
0009C2 BE7F       03609 	BTFSC dat_2,7,0
0009C4 8681       03610 	BSF   PORTB,3,0
0009C6 0000       03611 	NOP  
                  03612 			;			PORTB.4 = 1;  									// Modo dato.
0009C8 8881       03613 	BSF   PORTB,4,0
                  03614 			;			retardo_20u ();
0009CA EC81 F000  03615 	CALL  retardo_20u
                  03616 			;			PORTB.5 = 1;  									// Breve pulso.
0009CE 8A81       03617 	BSF   PORTB,5,0
                  03618 			;			retardo_20u ();
0009D0 EC81 F000  03619 	CALL  retardo_20u
                  03620 			;			PORTB.5 = 0;									// Lo envia y saca por LCD; deshabilita LCD.
0009D4 9A81       03621 	BCF   PORTB,5,0
                  03622 			;			for (i = 1; i <= 6; i++) retardo_20u ();
0009D6 0E01       03623 	MOVLW 1
0009D8 6E7F       03624 	MOVWF i_8,0
0009DA 0E07       03625 m131	MOVLW 7
0009DC 607F       03626 	CPFSLT i_8,0
0009DE D004       03627 	BRA   m132
0009E0 EC81 F000  03628 	CALL  retardo_20u
0009E4 2A7F       03629 	INCF  i_8,1,0
0009E6 D7F9       03630 	BRA   m131
                  03631 			;			dat = swap (dat);
0009E8 3A7F       03632 m132	SWAPF dat_2,1,0
                  03633 			;			PORTB.0 = dat.4;nop();
0009EA A87F       03634 	BTFSS dat_2,4,0
0009EC 9081       03635 	BCF   PORTB,0,0
0009EE B87F       03636 	BTFSC dat_2,4,0
0009F0 8081       03637 	BSF   PORTB,0,0
0009F2 0000       03638 	NOP  
                  03639 			;			PORTB.1 = dat.5;nop();
0009F4 AA7F       03640 	BTFSS dat_2,5,0
0009F6 9281       03641 	BCF   PORTB,1,0
0009F8 BA7F       03642 	BTFSC dat_2,5,0
0009FA 8281       03643 	BSF   PORTB,1,0
0009FC 0000       03644 	NOP  
                  03645 			;			PORTB.2 = dat.6;nop();
0009FE AC7F       03646 	BTFSS dat_2,6,0
000A00 9481       03647 	BCF   PORTB,2,0
000A02 BC7F       03648 	BTFSC dat_2,6,0
000A04 8481       03649 	BSF   PORTB,2,0
000A06 0000       03650 	NOP  
                  03651 			;			PORTB.3 = dat.7;
000A08 AE7F       03652 	BTFSS dat_2,7,0
000A0A 9681       03653 	BCF   PORTB,3,0
000A0C BE7F       03654 	BTFSC dat_2,7,0
000A0E 8681       03655 	BSF   PORTB,3,0
                  03656 			;			retardo_1m ();
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 62

ADDR   CODE       LINE  SOURCE

000A10 EC8B F000  03657 	CALL  retardo_1m
                  03658 			;			PORTB.4 = 1;  									// Modo dato.
000A14 8881       03659 	BSF   PORTB,4,0
                  03660 			;			retardo_1m ();
000A16 EC8B F000  03661 	CALL  retardo_1m
                  03662 			;			PORTB.5 = 1;  									// Breve pulso.
000A1A 8A81       03663 	BSF   PORTB,5,0
                  03664 			;			retardo_20u ();
000A1C EC81 F000  03665 	CALL  retardo_20u
                  03666 			;			PORTB.5 = 0; 									// Lo envia y saca por LCD; deshabilita LCD.
000A20 9A81       03667 	BCF   PORTB,5,0
                  03668 			;			for (i = 1; i<= 6; i++) retardo_20u ();
000A22 0E01       03669 	MOVLW 1
000A24 6E7F       03670 	MOVWF i_8,0
000A26 0E07       03671 m133	MOVLW 7
000A28 607F       03672 	CPFSLT i_8,0
000A2A D004       03673 	BRA   m134
000A2C EC81 F000  03674 	CALL  retardo_20u
000A30 2A7F       03675 	INCF  i_8,1,0
000A32 D7F9       03676 	BRA   m133
                  03677 			;			enviar_comando (0b.0000.1100);					// Pantalla encendida, sin cursor.			
000A34 0E0C       03678 m134	MOVLW 12
000A36 ECE3 F000  03679 	CALL  enviar_comando
                  03680 			;		}
000A3A 2A7F       03681 	INCF  xx_2,1,0
000A3C D757       03682 	BRA   m119
                  03683 			;
                  03684 			;	return;
000A3E 0012       03685 m135	RETURN
                  03686 
                  03687   ; FILE ondulador_migrado.c
                  03688 			;
                  03689 			;//==============================================================================================
                  03690 			;#include "Temporiz_20Mhz.h"
                  03691 			;void configuraPic (void);
                  03692 			;void configura1_PWM (void); 				// Configura todos los prámetros excepto M.
                  03693 			;uns8 lectura_AD (void);
                  03694 			;
                  03695 			;#include "math24F.h"
                  03696 			;#include "math24LB.h"	
                  03697 			;
                  03698 			;#include "LCD_4bit.h"
                  03699 			;//==============================================================================================
                  03700 			;//==============================================================================================
                  03701 			;
                  03702 			;void main (void)
                  03703 			;{
                  03704 main
                  03705 			;
                  03706 			;	GIE = 0;								// Desactivamos inicialmente todas las interrupciones.
000A40 9EF2       03707 	BCF   0xFF2,GIE,0
                  03708 			;	configuraPic (); 						// Configuramos todos los puertos y PWM
000A42 D84F       03709 	RCALL configuraPic
                  03710 			;	inicializar_lcd();    
000A44 DC8A       03711 	RCALL inicializar_lcd
                  03712 			;	T0CON   = 0b.01000.001; //(PIC 18F4550)	// Equivale junto con INTCON2 al OPTION_REG del 16F88x).							
                           	
000A46 0E41       03713 	MOVLW 65
000A48 6ED5       03714 	MOVWF T0CON,0
                  03715 			;	INTCON2 = 0b.0000.0100; //(PIC 18F4550)	// Equivale junto con T0CON al OPTION_REG del 16F88x).	
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 63

ADDR   CODE       LINE  SOURCE

000A4A 0E04       03716 	MOVLW 4
000A4C 6EF1       03717 	MOVWF INTCON2,0
                  03718 			;	TMR0IF = 0;   //T0IF = 0; (PIC 16F88x)	// Ponemos el flanco de interrupciones a cero (aun no se ha efectuado ninguna).
000A4E 94F2       03719 	BCF   0xFF2,TMR0IF,0
                  03720 			;   // w1   =   0;								// Reseteamos la variable índice de la tabla.
                  03721 			;	LATD.0 =0;            Vmax = 4;
000A50 908C       03722 	BCF   LATD,0,0
000A52 0E04       03723 	MOVLW 4
000A54 0100       03724 	MOVLB 0
000A56 6F74       03725 	MOVWF Vmax,1
000A58 6B75       03726 	CLRF  Vmax+1,1
                  03727 			;
                  03728 			;	
                  03729 			;	INTCON = 0b.0100.0000;				// Interrupciones globales (bit 7) e interrupción por Timer0 (bit 5) activadas.
000A5A 0E40       03730 	MOVLW 64
000A5C 6EF2       03731 	MOVWF INTCON,0
                  03732 			;
                  03733 			;	// COMENÇO AL PAS PER 0, AMB 2 CICLES DE PWM A Ton=0 --> SON 100uS
                  03734 			;	T=0; ancho_pwm =0; bUdw=1;	// Començo carregant 0
000A5E 6B77       03735 	CLRF  T,1
000A60 6B72       03736 	CLRF  ancho_pwm,1
000A62 6B73       03737 	CLRF  ancho_pwm+1,1
000A64 8171       03738 	BSF   0x71,bUdw,1
                  03739 			;	for (i = 1; i <= 6; i ++)  ancho_pwm = rl (ancho_pwm);
000A66 0E01       03740 	MOVLW 1
000A68 6F78       03741 	MOVWF i,1
000A6A 0E07       03742 m136	MOVLW 7
000A6C 0100       03743 	MOVLB 0
000A6E 6178       03744 	CPFSLT i,1
000A70 D004       03745 	BRA   m137
000A72 3772       03746 	RLCF  ancho_pwm,1,1
000A74 3773       03747 	RLCF  ancho_pwm+1,1,1
000A76 2B78       03748 	INCF  i,1,1
000A78 D7F8       03749 	BRA   m136
                  03750 			;	CCPR1L    = ancho_pwm.high8;	CCP1CON.5 = ancho_pwm.7;	CCP1CON.4 = ancho_pwm.6; // PWM carregat a 0
000A7A C073 FFBE  03751 m137	MOVFF ancho_pwm+1,CCPR1L
000A7E 0100       03752 	MOVLB 0
000A80 AF72       03753 	BTFSS ancho_pwm,7,1
000A82 9ABD       03754 	BCF   CCP1CON,5,0
000A84 BF72       03755 	BTFSC ancho_pwm,7,1
000A86 8ABD       03756 	BSF   CCP1CON,5,0
000A88 AD72       03757 	BTFSS ancho_pwm,6,1
000A8A 98BD       03758 	BCF   CCP1CON,4,0
000A8C BD72       03759 	BTFSC ancho_pwm,6,1
000A8E 88BD       03760 	BSF   CCP1CON,4,0
                  03761 			;	TMR2IF=0;	TMR2IE=1;	GIE=1; TMR2ON  = 1;
000A90 929E       03762 	BCF   0xF9E,TMR2IF,0
000A92 829D       03763 	BSF   0xF9D,TMR2IE,0
000A94 8EF2       03764 	BSF   0xFF2,GIE,0
000A96 84CA       03765 	BSF   0xFCA,TMR2ON,0
                  03766 			;	T++; SENO = sen[T];		ancho_pwm = (uns16)SENO*Vmax; // PREPARO SEGUENT VALOR
000A98 2B77       03767 	INCF  T,1,1
000A9A 5177       03768 	MOVF  T,W,1
000A9C D84F       03769 	RCALL _const1
000A9E 0100       03770 	MOVLB 0
000AA0 6F76       03771 	MOVWF SENO,1
000AA2 5176       03772 	MOVF  SENO,W,1
000AA4 0374       03773 	MULWF Vmax,1
000AA6 CFF3 F072  03774 	MOVFF PRODL,ancho_pwm
000AAA CFF4 F073  03775 	MOVFF PRODH,ancho_pwm+1
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 64

ADDR   CODE       LINE  SOURCE

000AAE 5176       03776 	MOVF  SENO,W,1
000AB0 0375       03777 	MULWF Vmax+1,1
000AB2 50F3       03778 	MOVF  PRODL,W,0
000AB4 2773       03779 	ADDWF ancho_pwm+1,1,1
                  03780 			;	char estado;
                  03781 			;
                  03782 			;
                  03783 			;	OSCTUNE=0b.01.000000; //PLL enable 
000AB6 0E40       03784 	MOVLW 64
000AB8 6E9B       03785 	MOVWF OSCTUNE,0
                  03786 			;	
                  03787 			;	RCON = 0b.01111111; //C18 pag 80 i 167  Causes del RESET i IPEN (priority Enabled o no)
000ABA 0E7F       03788 	MOVLW 127
000ABC 6ED0       03789 	MOVWF RCON,0
                  03790 			;	OSCCON    = 0b.0.111.0.0.00;
000ABE 0E70       03791 	MOVLW 112
000AC0 6ED3       03792 	MOVWF OSCCON,0
                  03793 			;	while (1)       					    // Bucle infinito durante el cual las interrupciones irán saltando.
                  03794 			;	{
                  03795 			;		PORTC.1^=1;
000AC2 7282       03796 m138	BTG   PORTC,1,0
                  03797 			;	/*
                  03798 			;		switch(estado){
                  03799 			;			case LECTURA_VAC:
                  03800 			;				while(T!=0);//espero a que sea paso por cero
                  03801 			;				while (estado== LECTURA_VAC){
                  03802 			;					if ((T == 6) || (T == 15 ) || (T == 20)) {	
                  03803 			;					
                  03804 			;					nop();
                  03805 			;					}				
                  03806 			;				}
                  03807 			;				break;
                  03808 			;			case CALCULOS_VAC:
                  03809 			;				nop();
                  03810 			;
                  03811 			;				break;
                  03812 			;			case LECTURA_IAC:
                  03813 			;				while(T!=0);//espero a que sea paso por cero
                  03814 			;				while (estado== LECTURA_IAC){
                  03815 			;					if ((T == 6) || (T == 15 ) || (T == 20)) {	
                  03816 			;					nop();
                  03817 			;			
                  03818 			;					}
                  03819 			;				}
                  03820 			;				break;
                  03821 			;			case CALCULOS_IAC:
                  03822 			;				nop();
                  03823 			;				break;
                  03824 			;			case ENVIO_LCD:
                  03825 			;				nop();
                  03826 			;				break;
                  03827 			;
                  03828 			;		}
                  03829 			;													
                  03830 			;	*/
                  03831 			;	}	
000AC4 D7FE       03832 	BRA   m138
                  03833 			;}
                  03834 			;
                  03835 			;//=============================================================================================================
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 65

ADDR   CODE       LINE  SOURCE

                  03836 			;uns8 lectura_AD (void)						// Lee el canal analógico AN0 con resolución de 8 bits:
                  03837 			;{
                  03838 lectura_AD
                  03839 			;	uns8 valor_AD;
                  03840 			;	TRISA.0 = 1;
000AC6 8092       03841 	BSF   TRISA,0,0
                  03842 			;	//ADCON0 = 0b.00.0000.01; 				// ADCON0 = 0b.01.0000.01; // Canal AN0. (PIC 16F887)
                  03843 			;	ADCON0 = 0b.10.000.0.0.1;				// (PIC 16F877)
000AC8 0E81       03844 	MOVLW 129
000ACA 6EC2       03845 	MOVWF ADCON0,0
                  03846 			;	//ADCON1 = 0b.1000.0000; 				// Justificado a la derecha.	(PIC 16F887)
                  03847 			;	ADCON1 = 0b.1.1.00.0000;				// (PIC 16F877)
000ACC 0EC0       03848 	MOVLW 192
000ACE 6EC1       03849 	MOVWF ADCON1,0
                  03850 			;	retardo_20u ();							// Retardo de 20 us (para 20 MHz) necesario para adquirir la señal.
000AD0 EC81 F000  03851 	CALL  retardo_20u
                  03852 			;	GO = 1;									// Activamos la conversión A -> D
000AD4 82C2       03853 	BSF   0xFC2,GO,0
                  03854 			;	while (GO);								// Bloqueo mientras realiza la conversión. Al terminar, el resultado está en A
                           DRESH y ADRESL
000AD6 B2C2       03855 m139	BTFSC 0xFC2,GO,0
000AD8 D7FE       03856 	BRA   m139
                  03857 			;	//valor_AD.low8  = ADRESL;    			// Cargo en "valor_AD" el valor digital (10 bits: de 0 a 1023) de la conversión.                       
                                                                   
                  03858 			;	//valor_AD.high8 = ADRESH;				// Cargo en "valor_AD" el valor digital (10 bits: de 0 a 1023) de la conversión. 
                  03859 			;	valor_AD = ADRESH;						// Despreciamos los dos bits más bajos para poder trabajar con un char.
000ADA CFC4 FF7F  03860 	MOVFF ADRESH,valor_AD
                  03861 			;	//PORTD = valor_AD.low8; 				// ****** PRUEBA PARA VER SI HACE LA CONVERSIÓN A/D.******************
                  03862 			;	//PORTC.1 = !PORTC.1; 					// Conmutamos PORTC.1 para generar un pulso que nos indique el tiempo de conversión A/D.
                  03863 			;	
                  03864 			;return valor_AD;
000ADE 507F       03865 	MOVF  valor_AD,W,0
000AE0 0012       03866 	RETURN
                  03867 			;}
                  03868 			;			
                  03869 			;void configuraPic (void)					
                  03870 			;{
                  03871 configuraPic
                  03872 			;
                  03873 			;	OSCTUNE=0b.01.000000; //PLL enable 
000AE2 0E40       03874 	MOVLW 64
000AE4 6E9B       03875 	MOVWF OSCTUNE,0
                  03876 			;	
                  03877 			;	RCON = 0b.01111111; //C18 pag 80 i 167  Causes del RESET i IPEN (priority Enabled o no)
000AE6 0E7F       03878 	MOVLW 127
000AE8 6ED0       03879 	MOVWF RCON,0
                  03880 			;	OSCCON    = 0b.0.111.0.0.00;//C18 pag 53  //=============== ULL b3 abans 0 
000AEA 0E70       03881 	MOVLW 112
000AEC 6ED3       03882 	MOVWF OSCCON,0
                  03883 			;	
                  03884 			;	//ANSEL  = 0b.0000.0001;					// Solo el canal AN0 será entrada analógica, el resto serán entradas/salidas digitale
                           s.(PIC 816F87)
                  03885 			;	//ANSELH = 0b.0000.0000;					// Solo el canal AN0 será entrada analógica, el resto serán entradas/salidas digitale
                           s.(PIC 816F87)
                  03886 			;	
                  03887 			;	TRISA  = 0b.0000.0001;					// PORTA.0 es entrada, el resto son salidas.
000AEE 0E01       03888 	MOVLW 1
000AF0 6E92       03889 	MOVWF TRISA,0
                  03890 			;	TRISB  = 0b.0000.0000;					// PORTB todo salidas.
000AF2 6A93       03891 	CLRF  TRISB,0
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 66

ADDR   CODE       LINE  SOURCE

                  03892 			;	TRISC  = 0b.0000.0000;					// PORTC todo salidas además de la salida del PWM.
000AF4 6A94       03893 	CLRF  TRISC,0
                  03894 			;	TRISD  = 0b.0000.0000;					// PORTD todo salidas.				
000AF6 6A95       03895 	CLRF  TRISD,0
                  03896 			;	PORTB  = 0x00;							// Inicializa las salidas de PORTB a 0.
000AF8 6A81       03897 	CLRF  PORTB,0
                  03898 			;	PORTC  = 0x00;							// Inicializa las salidas de PORTC a 0.
000AFA 6A82       03899 	CLRF  PORTC,0
                  03900 			;	PORTD  = 0x00;							// Inicializa las salidas de PORTD a 0.
000AFC 6A83       03901 	CLRF  PORTD,0
                  03902 			;
                  03903 			;	//configuro ccp y pwm
                  03904 			;
                  03905 			;
                  03906 			;	T2CON   = 0b.0.0001.0.01;				// Prescaler P1 = 4, TMR2ON = 1 cuenta;	
000AFE 0E09       03907 	MOVLW 9
000B00 6ECA       03908 	MOVWF T2CON,0
                  03909 			;	PR2     = 199;
000B02 0EC7       03910 	MOVLW 199
000B04 6ECB       03911 	MOVWF PR2,0
                  03912 			;	CCP1CON = 0b.1000.1100;					// CCP1: modo PWM half bridge con bits de CCPR1L a 00 inicialmente.
000B06 0E8C       03913 	MOVLW 140
000B08 6EBD       03914 	MOVWF CCP1CON,0
                  03915 			;
                  03916 			;	PWM1CON =0b.0000.0000; //tiempo muerto entre P1A y P1B
000B0A 6AB7       03917 	CLRF  PWM1CON,0
                  03918 			; 		// a mirar con el osciloscopio xq no me fio del proteus
                  03919 			;		//0b.0000.0011;-->180nS
                  03920 			;		//0b.0000.0100;-->240nS
                  03921 			;		//0b.0111.1111;-->7.9uS !! se solapan los tiempos e invierte la salida con lo que quedan las 2 conduciendo!!
                  03922 			;}
000B0C 0012       03923 	RETURN
                  03924 			;
                  03925 			;void configura2_PWM (void) //void configura2_PWM (unsigned long ancho_pwm)	// Configura el "delta" del PWM.
                  03926 			;{
                  03927 configura2_PWM
                  03928 			;	for (i = 1; i <= 6; i ++)  ancho_pwm = rl (ancho_pwm);
000B0E 0E01       03929 	MOVLW 1
000B10 0100       03930 	MOVLB 0
000B12 6F78       03931 	MOVWF i,1
000B14 0E07       03932 m140	MOVLW 7
000B16 0100       03933 	MOVLB 0
000B18 6178       03934 	CPFSLT i,1
000B1A D004       03935 	BRA   m141
000B1C 3772       03936 	RLCF  ancho_pwm,1,1
000B1E 3773       03937 	RLCF  ancho_pwm+1,1,1
000B20 2B78       03938 	INCF  i,1,1
000B22 D7F8       03939 	BRA   m140
                  03940 			;	CCPR1L    = ancho_pwm.high8;
000B24 C073 FFBE  03941 m141	MOVFF ancho_pwm+1,CCPR1L
                  03942 			;	CCP1CON.5 = ancho_pwm.7;
000B28 0100       03943 	MOVLB 0
000B2A AF72       03944 	BTFSS ancho_pwm,7,1
000B2C 9ABD       03945 	BCF   CCP1CON,5,0
000B2E BF72       03946 	BTFSC ancho_pwm,7,1
000B30 8ABD       03947 	BSF   CCP1CON,5,0
                  03948 			;	CCP1CON.4 = ancho_pwm.6;
000B32 AD72       03949 	BTFSS ancho_pwm,6,1
000B34 98BD       03950 	BCF   CCP1CON,4,0
000B36 BD72       03951 	BTFSC ancho_pwm,6,1
CC8E Version 1.4,   File: ondulador_migrado.c 21. Apr 2015  15:08   Page 67

ADDR   CODE       LINE  SOURCE

000B38 88BD       03952 	BSF   CCP1CON,4,0
000B3A 0012       03953 	RETURN
                  03954 _const1
000B3C 0100       03955 	MOVLB 0
000B3E 6F69       03956 	MOVWF ci,1
000B40 5169       03957 	MOVF  ci,W,1
000B42 0F54       03958 	ADDLW 84
000B44 6EF6       03959 	MOVWF TBLPTR,0
000B46 0E0B       03960 	MOVLW 11
000B48 6AF7       03961 	CLRF  TBLPTR+1,0
000B4A 22F7       03962 	ADDWFC TBLPTR+1,1,0
000B4C 6AF8       03963 	CLRF  TBLPTR+2,0
000B4E 0008       03964 	TBLRD *
000B50 50F5       03965 	MOVF  TABLAT,W,0
000B52 0012       03966 	RETURN
000B54 0800       03967 	DW    0x800
000B56 1710       03968 	DW    0x1710
000B58 271F       03969 	DW    0x271F
000B5A 362F       03970 	DW    0x362F
000B5C 443D       03971 	DW    0x443D
000B5E 514B       03972 	DW    0x514B
000B60 5D57       03973 	DW    0x5D57
000B62 6762       03974 	DW    0x6762
000B64 706C       03975 	DW    0x706C
000B66 7773       03976 	DW    0x7773
000B68 7B79       03977 	DW    0x7B79
000B6A 7E7D       03978 	DW    0x7E7D
000B6C 807F       03979 	DW    0x807F
                  03980 
                  03981 	END
                  03982 
                  03983 
                  03984 ; *** KEY INFO ***
                  03985 
                  03986 ; 0x000008  117 word(s)  1 % : highPriorityTimer_0
                  03987 ; 0x000B3C   25 word(s)  0 % : _const1
                  03988 ; 0x0000F2    8 word(s)  0 % : retardo_10u
                  03989 ; 0x000102   10 word(s)  0 % : retardo_20u
                  03990 ; 0x000116   15 word(s)  0 % : retardo_1m
                  03991 ; 0x000134   24 word(s)  0 % : retardo_100m
                  03992 ; 0x000164   20 word(s)  0 % : retardo_500m
                  03993 ; 0x000AE2   22 word(s)  0 % : configuraPic
                  03994 ; 0x000AC6   14 word(s)  0 % : lectura_AD
                  03995 ; 0x00018C    1 word(s)  0 % : lcdBegin
                  03996 ; 0x00018E   28 word(s)  0 % : envia_codigo_inicial
                  03997 ; 0x0001C6   59 word(s)  0 % : enviar_comando
                  03998 ; 0x00023C   71 word(s)  0 % : enviar_literal
                  03999 ; 0x0002CA   72 word(s)  0 % : enviar_cifra
                  04000 ; 0x00035A   59 word(s)  0 % : inicializar_lcd
                  04001 ; 0x0003D0   34 word(s)  0 % : escribir_posicion
                  04002 ; 0x000414   37 word(s)  0 % : borrar_linea
                  04003 ; 0x00045E    2 word(s)  0 % : borrar_lcd
                  04004 ; 0x000462  367 word(s)  4 % : Enviar_lcd
                  04005 ; 0x000740  384 word(s)  4 % : Enviar_uns16
                  04006 ; 0x000A40   67 word(s)  0 % : main
                  04007 ; 0x000B0E   23 word(s)  0 % : configura2_PWM
                  04008 
                  04009 ; RAM usage: 26 bytes (17 local), 742 bytes free
                  04010 ; Maximum call level: 3 (+2 for interrupt)
                  04011 ; Total of 1461 code words (17 %)
